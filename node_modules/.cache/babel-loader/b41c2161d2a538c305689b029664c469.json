{"ast":null,"code":"import { Transform } from \"../transforms\";\nimport * as p from \"../../core/properties\";\nexport class Scale extends Transform {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Scale() {\n    this.internal({\n      source_range: [p.Any],\n      target_range: [p.Any]\n    });\n  }\n\n  r_compute(x0, x1) {\n    if (this.target_range.is_reversed) return [this.compute(x1), this.compute(x0)];else return [this.compute(x0), this.compute(x1)];\n  }\n\n  r_invert(sx0, sx1) {\n    if (this.target_range.is_reversed) return [this.invert(sx1), this.invert(sx0)];else return [this.invert(sx0), this.invert(sx1)];\n  } // These are needed by both LinearScale and CategoricalScale and this is the\n  // only common ancestor. TODO: Proper MI/Mixin would be better.\n\n\n  _linear_compute(x) {\n    const [factor, offset] = this._linear_compute_state();\n\n    return factor * x + offset;\n  }\n\n  _linear_v_compute(xs) {\n    const [factor, offset] = this._linear_compute_state();\n\n    const result = new Float64Array(xs.length);\n\n    for (let i = 0; i < xs.length; i++) result[i] = factor * xs[i] + offset;\n\n    return result;\n  }\n\n  _linear_invert(xprime) {\n    const [factor, offset] = this._linear_compute_state();\n\n    return (xprime - offset) / factor;\n  }\n\n  _linear_v_invert(xprimes) {\n    const [factor, offset] = this._linear_compute_state();\n\n    const result = new Float64Array(xprimes.length);\n\n    for (let i = 0; i < xprimes.length; i++) result[i] = (xprimes[i] - offset) / factor;\n\n    return result;\n  }\n  /*protected*/\n\n\n  _linear_compute_state() {\n    //\n    //  (t1 - t0)       (t1 - t0)\n    //  --------- * x - --------- * s0 + t0\n    //  (s1 - s0)       (s1 - s0)\n    //\n    // [  factor  ]     [    offset    ]\n    //\n    const source_start = this.source_range.start;\n    const source_end = this.source_range.end;\n    const target_start = this.target_range.start;\n    const target_end = this.target_range.end;\n    const factor = (target_end - target_start) / (source_end - source_start);\n    const offset = -(factor * source_start) + target_start;\n    return [factor, offset];\n  }\n\n}\nScale.__name__ = \"Scale\";\nScale.init_Scale();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/scales/scale.js"],"names":["Transform","p","Scale","constructor","attrs","init_Scale","internal","source_range","Any","target_range","r_compute","x0","x1","is_reversed","compute","r_invert","sx0","sx1","invert","_linear_compute","x","factor","offset","_linear_compute_state","_linear_v_compute","xs","result","Float64Array","length","i","_linear_invert","xprime","_linear_v_invert","xprimes","source_start","start","source_end","end","target_start","target_end","__name__"],"mappings":"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","sourcesContent":["import { Transform } from \"../transforms\";\nimport * as p from \"../../core/properties\";\nexport class Scale extends Transform {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Scale() {\n        this.internal({\n            source_range: [p.Any],\n            target_range: [p.Any],\n        });\n    }\n    r_compute(x0, x1) {\n        if (this.target_range.is_reversed)\n            return [this.compute(x1), this.compute(x0)];\n        else\n            return [this.compute(x0), this.compute(x1)];\n    }\n    r_invert(sx0, sx1) {\n        if (this.target_range.is_reversed)\n            return [this.invert(sx1), this.invert(sx0)];\n        else\n            return [this.invert(sx0), this.invert(sx1)];\n    }\n    // These are needed by both LinearScale and CategoricalScale and this is the\n    // only common ancestor. TODO: Proper MI/Mixin would be better.\n    _linear_compute(x) {\n        const [factor, offset] = this._linear_compute_state();\n        return factor * x + offset;\n    }\n    _linear_v_compute(xs) {\n        const [factor, offset] = this._linear_compute_state();\n        const result = new Float64Array(xs.length);\n        for (let i = 0; i < xs.length; i++)\n            result[i] = factor * xs[i] + offset;\n        return result;\n    }\n    _linear_invert(xprime) {\n        const [factor, offset] = this._linear_compute_state();\n        return (xprime - offset) / factor;\n    }\n    _linear_v_invert(xprimes) {\n        const [factor, offset] = this._linear_compute_state();\n        const result = new Float64Array(xprimes.length);\n        for (let i = 0; i < xprimes.length; i++)\n            result[i] = (xprimes[i] - offset) / factor;\n        return result;\n    }\n    /*protected*/ _linear_compute_state() {\n        //\n        //  (t1 - t0)       (t1 - t0)\n        //  --------- * x - --------- * s0 + t0\n        //  (s1 - s0)       (s1 - s0)\n        //\n        // [  factor  ]     [    offset    ]\n        //\n        const source_start = this.source_range.start;\n        const source_end = this.source_range.end;\n        const target_start = this.target_range.start;\n        const target_end = this.target_range.end;\n        const factor = (target_end - target_start) / (source_end - source_start);\n        const offset = -(factor * source_start) + target_start;\n        return [factor, offset];\n    }\n}\nScale.__name__ = \"Scale\";\nScale.init_Scale();\n//# sourceMappingURL=scale.js.map"]},"metadata":{},"sourceType":"module"}