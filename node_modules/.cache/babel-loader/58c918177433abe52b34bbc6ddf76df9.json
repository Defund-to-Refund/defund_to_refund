{"ast":null,"code":"import { ModelChangedEvent } from \"../document\";\nimport { Message } from \"../protocol/message\";\nimport { logger } from \"../core/logging\";\nexport class ClientSession {\n  constructor(_connection, document, id) {\n    this._connection = _connection;\n    this.document = document;\n    this.id = id;\n\n    this._document_listener = event => this._document_changed(event);\n\n    this.document.on_change(this._document_listener);\n  }\n\n  handle(message) {\n    const msgtype = message.msgtype();\n    if (msgtype === 'PATCH-DOC') this._handle_patch(message);else if (msgtype === 'OK') this._handle_ok(message);else if (msgtype === 'ERROR') this._handle_error(message);else logger.debug(`Doing nothing with message ${message.msgtype()}`);\n  }\n\n  close() {\n    this._connection.close();\n  }\n  /*protected*/\n\n\n  _connection_closed() {\n    this.document.remove_on_change(this._document_listener);\n  } // Sends a request to the server for info about the server, such as its Bokeh\n  // version. Returns a promise, the value of the promise is a free-form dictionary\n  // of server details.\n\n\n  async request_server_info() {\n    const message = Message.create('SERVER-INFO-REQ', {});\n    const reply = await this._connection.send_with_reply(message);\n    return reply.content;\n  } // Sends some request to the server (no guarantee about which one) and returns\n  // a promise which is completed when the server replies. The purpose of this\n  // is that if you wait for the promise to be completed, you know the server\n  // has processed the request. This is useful when writing tests because once\n  // the server has processed this request it should also have processed any\n  // events or requests you sent previously, which means you can check for the\n  // results of that processing without a race condition. (This assumes the\n  // server processes events in sequence, which it mostly has to semantically,\n  // since reordering events might change the final state.)\n\n\n  async force_roundtrip() {\n    await this.request_server_info();\n  }\n\n  _document_changed(event) {\n    // Filter out events that were initiated by the ClientSession itself\n    if (event.setter_id === this.id) // XXX: not all document events define this\n      return; // Filter out changes to attributes that aren't server-visible\n\n    if (event instanceof ModelChangedEvent && !(event.attr in event.model.serializable_attributes())) return; // TODO (havocp) the connection may be closed here, which will\n    // cause this send to throw an error - need to deal with it more cleanly.\n\n    const message = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));\n\n    this._connection.send(message);\n  }\n\n  _handle_patch(message) {\n    this.document.apply_json_patch(message.content, message.buffers, this.id);\n  }\n\n  _handle_ok(message) {\n    logger.trace(`Unhandled OK reply to ${message.reqid()}`);\n  }\n\n  _handle_error(message) {\n    logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content.text}`);\n  }\n\n}\nClientSession.__name__ = \"ClientSession\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/client/session.js"],"names":["ModelChangedEvent","Message","logger","ClientSession","constructor","_connection","document","id","_document_listener","event","_document_changed","on_change","handle","message","msgtype","_handle_patch","_handle_ok","_handle_error","debug","close","_connection_closed","remove_on_change","request_server_info","create","reply","send_with_reply","content","force_roundtrip","setter_id","attr","model","serializable_attributes","create_json_patch","send","apply_json_patch","buffers","trace","reqid","error","text","__name__"],"mappings":"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","sourcesContent":["import { ModelChangedEvent } from \"../document\";\nimport { Message } from \"../protocol/message\";\nimport { logger } from \"../core/logging\";\nexport class ClientSession {\n    constructor(_connection, document, id) {\n        this._connection = _connection;\n        this.document = document;\n        this.id = id;\n        this._document_listener = (event) => this._document_changed(event);\n        this.document.on_change(this._document_listener);\n    }\n    handle(message) {\n        const msgtype = message.msgtype();\n        if (msgtype === 'PATCH-DOC')\n            this._handle_patch(message);\n        else if (msgtype === 'OK')\n            this._handle_ok(message);\n        else if (msgtype === 'ERROR')\n            this._handle_error(message);\n        else\n            logger.debug(`Doing nothing with message ${message.msgtype()}`);\n    }\n    close() {\n        this._connection.close();\n    }\n    /*protected*/ _connection_closed() {\n        this.document.remove_on_change(this._document_listener);\n    }\n    // Sends a request to the server for info about the server, such as its Bokeh\n    // version. Returns a promise, the value of the promise is a free-form dictionary\n    // of server details.\n    async request_server_info() {\n        const message = Message.create('SERVER-INFO-REQ', {});\n        const reply = await this._connection.send_with_reply(message);\n        return reply.content;\n    }\n    // Sends some request to the server (no guarantee about which one) and returns\n    // a promise which is completed when the server replies. The purpose of this\n    // is that if you wait for the promise to be completed, you know the server\n    // has processed the request. This is useful when writing tests because once\n    // the server has processed this request it should also have processed any\n    // events or requests you sent previously, which means you can check for the\n    // results of that processing without a race condition. (This assumes the\n    // server processes events in sequence, which it mostly has to semantically,\n    // since reordering events might change the final state.)\n    async force_roundtrip() {\n        await this.request_server_info();\n    }\n    _document_changed(event) {\n        // Filter out events that were initiated by the ClientSession itself\n        if (event.setter_id === this.id) // XXX: not all document events define this\n            return;\n        // Filter out changes to attributes that aren't server-visible\n        if (event instanceof ModelChangedEvent && !(event.attr in event.model.serializable_attributes()))\n            return;\n        // TODO (havocp) the connection may be closed here, which will\n        // cause this send to throw an error - need to deal with it more cleanly.\n        const message = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));\n        this._connection.send(message);\n    }\n    _handle_patch(message) {\n        this.document.apply_json_patch(message.content, message.buffers, this.id);\n    }\n    _handle_ok(message) {\n        logger.trace(`Unhandled OK reply to ${message.reqid()}`);\n    }\n    _handle_error(message) {\n        logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content.text}`);\n    }\n}\nClientSession.__name__ = \"ClientSession\";\n//# sourceMappingURL=session.js.map"]},"metadata":{},"sourceType":"module"}