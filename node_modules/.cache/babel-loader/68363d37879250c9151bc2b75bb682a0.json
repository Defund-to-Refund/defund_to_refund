{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"../glyphs/xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nexport class MarkerView extends XYGlyphView {\n  _render(ctx, indices, {\n    sx,\n    sy,\n    _size,\n    _angle\n  }) {\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i])) continue;\n      const r = _size[i] / 2;\n      ctx.beginPath();\n      ctx.translate(sx[i], sy[i]);\n      if (_angle[i]) ctx.rotate(_angle[i]);\n\n      this._render_one(ctx, i, r, this.visuals.line, this.visuals.fill);\n\n      if (_angle[i]) ctx.rotate(-_angle[i]);\n      ctx.translate(-sx[i], -sy[i]);\n    }\n  }\n\n  _mask_data() {\n    // dilate the inner screen region by max_size and map back to data space for use in\n    // spatial query\n    const hr = this.renderer.plot_view.frame.bbox.h_range;\n    const sx0 = hr.start - this.max_size;\n    const sx1 = hr.end + this.max_size;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const vr = this.renderer.plot_view.frame.bbox.v_range;\n    const sy0 = vr.start - this.max_size;\n    const sy1 = vr.end + this.max_size;\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    return this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const sx0 = sx - this.max_size;\n    const sx1 = sx + this.max_size;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const sy0 = sy - this.max_size;\n    const sy1 = sy + this.max_size;\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const candidates = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    const hits = [];\n\n    for (const i of candidates) {\n      const s2 = this._size[i] / 2;\n      const dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);\n\n      if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\n        hits.push([i, dist]);\n      }\n    }\n\n    return hittest.create_hit_test_result_from_hits(hits);\n  }\n\n  _hit_span(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const bounds = this.bounds();\n    const ms = this.max_size / 2;\n    const result = hittest.create_empty_hit_test_result();\n    let x0, x1, y0, y1;\n\n    if (geometry.direction == 'h') {\n      y0 = bounds.y0;\n      y1 = bounds.y1;\n      const sx0 = sx - ms;\n      const sx1 = sx + ms;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    } else {\n      x0 = bounds.x0;\n      x1 = bounds.x1;\n      const sy0 = sy - ms;\n      const sy1 = sy + ms;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    const hits = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_rect(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    return result;\n  }\n\n  _hit_poly(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry; // TODO (bev) use spatial index to pare candidate list\n\n    const candidates = range(0, this.sx.length);\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n      if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) hits.push(idx);\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  draw_legend_for_index(ctx, {\n    x0,\n    x1,\n    y0,\n    y1\n  }, index) {\n    // using objects like this seems a little wonky, since the keys are coerced to\n    // stings, but it works\n    const len = index + 1;\n    const sx = new Array(len);\n    sx[index] = (x0 + x1) / 2;\n    const sy = new Array(len);\n    sy[index] = (y0 + y1) / 2;\n    const size = new Array(len);\n    size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n    const angle = new Array(len);\n    angle[index] = 0; // don't attempt to match glyph angle\n\n    this._render(ctx, [index], {\n      sx,\n      sy,\n      _size: size,\n      _angle: angle\n    }); // XXX\n\n  }\n\n}\nMarkerView.__name__ = \"MarkerView\";\nexport class Marker extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Marker() {\n    this.mixins(['line', 'fill']);\n    this.define({\n      size: [p.DistanceSpec, {\n        units: \"screen\",\n        value: 4\n      }],\n      angle: [p.AngleSpec, 0]\n    });\n  }\n\n}\nMarker.__name__ = \"Marker\";\nMarker.init_Marker();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/markers/marker.js"],"names":["XYGlyph","XYGlyphView","hittest","p","range","MarkerView","_render","ctx","indices","sx","sy","_size","_angle","i","isNaN","r","beginPath","translate","rotate","_render_one","visuals","line","fill","_mask_data","hr","renderer","plot_view","frame","bbox","h_range","sx0","start","max_size","sx1","end","x0","x1","xscale","r_invert","vr","v_range","sy0","sy1","y0","y1","yscale","index","_hit_point","geometry","candidates","hits","s2","dist","Math","abs","push","create_hit_test_result_from_hits","_hit_span","bounds","ms","result","create_empty_hit_test_result","direction","_hit_rect","_hit_poly","length","idx","point_in_poly","draw_legend_for_index","len","Array","size","min","angle","__name__","Marker","constructor","attrs","init_Marker","mixins","define","DistanceSpec","units","value","AngleSpec"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,WAAlB,QAAqC,oBAArC;AACA,OAAO,KAAKC,OAAZ,MAAyB,oBAAzB;AACA,OAAO,KAAKC,CAAZ,MAAmB,uBAAnB;AACA,SAASC,KAAT,QAAsB,uBAAtB;AACA,OAAO,MAAMC,UAAN,SAAyBJ,WAAzB,CAAqC;AACxCK,EAAAA,OAAO,CAACC,GAAD,EAAMC,OAAN,EAAe;AAAEC,IAAAA,EAAF;AAAMC,IAAAA,EAAN;AAAUC,IAAAA,KAAV;AAAiBC,IAAAA;AAAjB,GAAf,EAA0C;AAC7C,SAAK,MAAMC,CAAX,IAAgBL,OAAhB,EAAyB;AACrB,UAAIM,KAAK,CAACL,EAAE,CAACI,CAAD,CAAF,GAAQH,EAAE,CAACG,CAAD,CAAV,GAAgBF,KAAK,CAACE,CAAD,CAArB,GAA2BD,MAAM,CAACC,CAAD,CAAlC,CAAT,EACI;AACJ,YAAME,CAAC,GAAGJ,KAAK,CAACE,CAAD,CAAL,GAAW,CAArB;AACAN,MAAAA,GAAG,CAACS,SAAJ;AACAT,MAAAA,GAAG,CAACU,SAAJ,CAAcR,EAAE,CAACI,CAAD,CAAhB,EAAqBH,EAAE,CAACG,CAAD,CAAvB;AACA,UAAID,MAAM,CAACC,CAAD,CAAV,EACIN,GAAG,CAACW,MAAJ,CAAWN,MAAM,CAACC,CAAD,CAAjB;;AACJ,WAAKM,WAAL,CAAiBZ,GAAjB,EAAsBM,CAAtB,EAAyBE,CAAzB,EAA4B,KAAKK,OAAL,CAAaC,IAAzC,EAA+C,KAAKD,OAAL,CAAaE,IAA5D;;AACA,UAAIV,MAAM,CAACC,CAAD,CAAV,EACIN,GAAG,CAACW,MAAJ,CAAW,CAACN,MAAM,CAACC,CAAD,CAAlB;AACJN,MAAAA,GAAG,CAACU,SAAJ,CAAc,CAACR,EAAE,CAACI,CAAD,CAAjB,EAAsB,CAACH,EAAE,CAACG,CAAD,CAAzB;AACH;AACJ;;AACDU,EAAAA,UAAU,GAAG;AACT;AACA;AACA,UAAMC,EAAE,GAAG,KAAKC,QAAL,CAAcC,SAAd,CAAwBC,KAAxB,CAA8BC,IAA9B,CAAmCC,OAA9C;AACA,UAAMC,GAAG,GAAGN,EAAE,CAACO,KAAH,GAAW,KAAKC,QAA5B;AACA,UAAMC,GAAG,GAAGT,EAAE,CAACU,GAAH,GAAS,KAAKF,QAA1B;AACA,UAAM,CAACG,EAAD,EAAKC,EAAL,IAAW,KAAKX,QAAL,CAAcY,MAAd,CAAqBC,QAArB,CAA8BR,GAA9B,EAAmCG,GAAnC,CAAjB;AACA,UAAMM,EAAE,GAAG,KAAKd,QAAL,CAAcC,SAAd,CAAwBC,KAAxB,CAA8BC,IAA9B,CAAmCY,OAA9C;AACA,UAAMC,GAAG,GAAGF,EAAE,CAACR,KAAH,GAAW,KAAKC,QAA5B;AACA,UAAMU,GAAG,GAAGH,EAAE,CAACL,GAAH,GAAS,KAAKF,QAA1B;AACA,UAAM,CAACW,EAAD,EAAKC,EAAL,IAAW,KAAKnB,QAAL,CAAcoB,MAAd,CAAqBP,QAArB,CAA8BG,GAA9B,EAAmCC,GAAnC,CAAjB;AACA,WAAO,KAAKI,KAAL,CAAWtC,OAAX,CAAmB;AAAE2B,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUO,MAAAA,EAAV;AAAcC,MAAAA;AAAd,KAAnB,CAAP;AACH;;AACDG,EAAAA,UAAU,CAACC,QAAD,EAAW;AACjB,UAAM;AAAEvC,MAAAA,EAAF;AAAMC,MAAAA;AAAN,QAAasC,QAAnB;AACA,UAAMlB,GAAG,GAAGrB,EAAE,GAAG,KAAKuB,QAAtB;AACA,UAAMC,GAAG,GAAGxB,EAAE,GAAG,KAAKuB,QAAtB;AACA,UAAM,CAACG,EAAD,EAAKC,EAAL,IAAW,KAAKX,QAAL,CAAcY,MAAd,CAAqBC,QAArB,CAA8BR,GAA9B,EAAmCG,GAAnC,CAAjB;AACA,UAAMQ,GAAG,GAAG/B,EAAE,GAAG,KAAKsB,QAAtB;AACA,UAAMU,GAAG,GAAGhC,EAAE,GAAG,KAAKsB,QAAtB;AACA,UAAM,CAACW,EAAD,EAAKC,EAAL,IAAW,KAAKnB,QAAL,CAAcoB,MAAd,CAAqBP,QAArB,CAA8BG,GAA9B,EAAmCC,GAAnC,CAAjB;AACA,UAAMO,UAAU,GAAG,KAAKH,KAAL,CAAWtC,OAAX,CAAmB;AAAE2B,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUO,MAAAA,EAAV;AAAcC,MAAAA;AAAd,KAAnB,CAAnB;AACA,UAAMM,IAAI,GAAG,EAAb;;AACA,SAAK,MAAMrC,CAAX,IAAgBoC,UAAhB,EAA4B;AACxB,YAAME,EAAE,GAAG,KAAKxC,KAAL,CAAWE,CAAX,IAAgB,CAA3B;AACA,YAAMuC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAK7C,EAAL,CAAQI,CAAR,IAAaJ,EAAtB,IAA4B4C,IAAI,CAACC,GAAL,CAAS,KAAK5C,EAAL,CAAQG,CAAR,IAAaH,EAAtB,CAAzC;;AACA,UAAI2C,IAAI,CAACC,GAAL,CAAS,KAAK7C,EAAL,CAAQI,CAAR,IAAaJ,EAAtB,KAA6B0C,EAA7B,IAAmCE,IAAI,CAACC,GAAL,CAAS,KAAK5C,EAAL,CAAQG,CAAR,IAAaH,EAAtB,KAA6ByC,EAApE,EAAwE;AACpED,QAAAA,IAAI,CAACK,IAAL,CAAU,CAAC1C,CAAD,EAAIuC,IAAJ,CAAV;AACH;AACJ;;AACD,WAAOlD,OAAO,CAACsD,gCAAR,CAAyCN,IAAzC,CAAP;AACH;;AACDO,EAAAA,SAAS,CAACT,QAAD,EAAW;AAChB,UAAM;AAAEvC,MAAAA,EAAF;AAAMC,MAAAA;AAAN,QAAasC,QAAnB;AACA,UAAMU,MAAM,GAAG,KAAKA,MAAL,EAAf;AACA,UAAMC,EAAE,GAAG,KAAK3B,QAAL,GAAgB,CAA3B;AACA,UAAM4B,MAAM,GAAG1D,OAAO,CAAC2D,4BAAR,EAAf;AACA,QAAI1B,EAAJ,EAAQC,EAAR,EAAYO,EAAZ,EAAgBC,EAAhB;;AACA,QAAII,QAAQ,CAACc,SAAT,IAAsB,GAA1B,EAA+B;AAC3BnB,MAAAA,EAAE,GAAGe,MAAM,CAACf,EAAZ;AACAC,MAAAA,EAAE,GAAGc,MAAM,CAACd,EAAZ;AACA,YAAMd,GAAG,GAAGrB,EAAE,GAAGkD,EAAjB;AACA,YAAM1B,GAAG,GAAGxB,EAAE,GAAGkD,EAAjB;AACA,OAACxB,EAAD,EAAKC,EAAL,IAAW,KAAKX,QAAL,CAAcY,MAAd,CAAqBC,QAArB,CAA8BR,GAA9B,EAAmCG,GAAnC,CAAX;AACH,KAND,MAOK;AACDE,MAAAA,EAAE,GAAGuB,MAAM,CAACvB,EAAZ;AACAC,MAAAA,EAAE,GAAGsB,MAAM,CAACtB,EAAZ;AACA,YAAMK,GAAG,GAAG/B,EAAE,GAAGiD,EAAjB;AACA,YAAMjB,GAAG,GAAGhC,EAAE,GAAGiD,EAAjB;AACA,OAAChB,EAAD,EAAKC,EAAL,IAAW,KAAKnB,QAAL,CAAcoB,MAAd,CAAqBP,QAArB,CAA8BG,GAA9B,EAAmCC,GAAnC,CAAX;AACH;;AACD,UAAMQ,IAAI,GAAG,KAAKJ,KAAL,CAAWtC,OAAX,CAAmB;AAAE2B,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUO,MAAAA,EAAV;AAAcC,MAAAA;AAAd,KAAnB,CAAb;AACAgB,IAAAA,MAAM,CAACpD,OAAP,GAAiB0C,IAAjB;AACA,WAAOU,MAAP;AACH;;AACDG,EAAAA,SAAS,CAACf,QAAD,EAAW;AAChB,UAAM;AAAElB,MAAAA,GAAF;AAAOG,MAAAA,GAAP;AAAYQ,MAAAA,GAAZ;AAAiBC,MAAAA;AAAjB,QAAyBM,QAA/B;AACA,UAAM,CAACb,EAAD,EAAKC,EAAL,IAAW,KAAKX,QAAL,CAAcY,MAAd,CAAqBC,QAArB,CAA8BR,GAA9B,EAAmCG,GAAnC,CAAjB;AACA,UAAM,CAACU,EAAD,EAAKC,EAAL,IAAW,KAAKnB,QAAL,CAAcoB,MAAd,CAAqBP,QAArB,CAA8BG,GAA9B,EAAmCC,GAAnC,CAAjB;AACA,UAAMkB,MAAM,GAAG1D,OAAO,CAAC2D,4BAAR,EAAf;AACAD,IAAAA,MAAM,CAACpD,OAAP,GAAiB,KAAKsC,KAAL,CAAWtC,OAAX,CAAmB;AAAE2B,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUO,MAAAA,EAAV;AAAcC,MAAAA;AAAd,KAAnB,CAAjB;AACA,WAAOgB,MAAP;AACH;;AACDI,EAAAA,SAAS,CAAChB,QAAD,EAAW;AAChB,UAAM;AAAEvC,MAAAA,EAAF;AAAMC,MAAAA;AAAN,QAAasC,QAAnB,CADgB,CAEhB;;AACA,UAAMC,UAAU,GAAG7C,KAAK,CAAC,CAAD,EAAI,KAAKK,EAAL,CAAQwD,MAAZ,CAAxB;AACA,UAAMf,IAAI,GAAG,EAAb;;AACA,SAAK,IAAIrC,CAAC,GAAG,CAAR,EAAWqB,GAAG,GAAGe,UAAU,CAACgB,MAAjC,EAAyCpD,CAAC,GAAGqB,GAA7C,EAAkDrB,CAAC,EAAnD,EAAuD;AACnD,YAAMqD,GAAG,GAAGjB,UAAU,CAACpC,CAAD,CAAtB;AACA,UAAIX,OAAO,CAACiE,aAAR,CAAsB,KAAK1D,EAAL,CAAQI,CAAR,CAAtB,EAAkC,KAAKH,EAAL,CAAQG,CAAR,CAAlC,EAA8CJ,EAA9C,EAAkDC,EAAlD,CAAJ,EACIwC,IAAI,CAACK,IAAL,CAAUW,GAAV;AACP;;AACD,UAAMN,MAAM,GAAG1D,OAAO,CAAC2D,4BAAR,EAAf;AACAD,IAAAA,MAAM,CAACpD,OAAP,GAAiB0C,IAAjB;AACA,WAAOU,MAAP;AACH;;AACDQ,EAAAA,qBAAqB,CAAC7D,GAAD,EAAM;AAAE4B,IAAAA,EAAF;AAAMC,IAAAA,EAAN;AAAUO,IAAAA,EAAV;AAAcC,IAAAA;AAAd,GAAN,EAA0BE,KAA1B,EAAiC;AAClD;AACA;AACA,UAAMuB,GAAG,GAAGvB,KAAK,GAAG,CAApB;AACA,UAAMrC,EAAE,GAAG,IAAI6D,KAAJ,CAAUD,GAAV,CAAX;AACA5D,IAAAA,EAAE,CAACqC,KAAD,CAAF,GAAY,CAACX,EAAE,GAAGC,EAAN,IAAY,CAAxB;AACA,UAAM1B,EAAE,GAAG,IAAI4D,KAAJ,CAAUD,GAAV,CAAX;AACA3D,IAAAA,EAAE,CAACoC,KAAD,CAAF,GAAY,CAACH,EAAE,GAAGC,EAAN,IAAY,CAAxB;AACA,UAAM2B,IAAI,GAAG,IAAID,KAAJ,CAAUD,GAAV,CAAb;AACAE,IAAAA,IAAI,CAACzB,KAAD,CAAJ,GAAcO,IAAI,CAACmB,GAAL,CAASnB,IAAI,CAACC,GAAL,CAASlB,EAAE,GAAGD,EAAd,CAAT,EAA4BkB,IAAI,CAACC,GAAL,CAASV,EAAE,GAAGD,EAAd,CAA5B,IAAiD,GAA/D;AACA,UAAM8B,KAAK,GAAG,IAAIH,KAAJ,CAAUD,GAAV,CAAd;AACAI,IAAAA,KAAK,CAAC3B,KAAD,CAAL,GAAe,CAAf,CAXkD,CAWhC;;AAClB,SAAKxC,OAAL,CAAaC,GAAb,EAAkB,CAACuC,KAAD,CAAlB,EAA2B;AAAErC,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUC,MAAAA,KAAK,EAAE4D,IAAjB;AAAuB3D,MAAAA,MAAM,EAAE6D;AAA/B,KAA3B,EAZkD,CAYkB;;AACvE;;AA3GuC;AA6G5CpE,UAAU,CAACqE,QAAX,GAAsB,YAAtB;AACA,OAAO,MAAMC,MAAN,SAAqB3E,OAArB,CAA6B;AAChC4E,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,WAAP,GAAqB;AACjB,SAAKC,MAAL,CAAY,CAAC,MAAD,EAAS,MAAT,CAAZ;AACA,SAAKC,MAAL,CAAY;AACRT,MAAAA,IAAI,EAAE,CAACpE,CAAC,CAAC8E,YAAH,EAAiB;AAAEC,QAAAA,KAAK,EAAE,QAAT;AAAmBC,QAAAA,KAAK,EAAE;AAA1B,OAAjB,CADE;AAERV,MAAAA,KAAK,EAAE,CAACtE,CAAC,CAACiF,SAAH,EAAc,CAAd;AAFC,KAAZ;AAIH;;AAV+B;AAYpCT,MAAM,CAACD,QAAP,GAAkB,QAAlB;AACAC,MAAM,CAACG,WAAP","sourcesContent":["import { XYGlyph, XYGlyphView } from \"../glyphs/xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nexport class MarkerView extends XYGlyphView {\n    _render(ctx, indices, { sx, sy, _size, _angle }) {\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i]))\n                continue;\n            const r = _size[i] / 2;\n            ctx.beginPath();\n            ctx.translate(sx[i], sy[i]);\n            if (_angle[i])\n                ctx.rotate(_angle[i]);\n            this._render_one(ctx, i, r, this.visuals.line, this.visuals.fill);\n            if (_angle[i])\n                ctx.rotate(-_angle[i]);\n            ctx.translate(-sx[i], -sy[i]);\n        }\n    }\n    _mask_data() {\n        // dilate the inner screen region by max_size and map back to data space for use in\n        // spatial query\n        const hr = this.renderer.plot_view.frame.bbox.h_range;\n        const sx0 = hr.start - this.max_size;\n        const sx1 = hr.end + this.max_size;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const vr = this.renderer.plot_view.frame.bbox.v_range;\n        const sy0 = vr.start - this.max_size;\n        const sy1 = vr.end + this.max_size;\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        return this.index.indices({ x0, x1, y0, y1 });\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const sx0 = sx - this.max_size;\n        const sx1 = sx + this.max_size;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const sy0 = sy - this.max_size;\n        const sy1 = sy + this.max_size;\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const candidates = this.index.indices({ x0, x1, y0, y1 });\n        const hits = [];\n        for (const i of candidates) {\n            const s2 = this._size[i] / 2;\n            const dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);\n            if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_hit_test_result_from_hits(hits);\n    }\n    _hit_span(geometry) {\n        const { sx, sy } = geometry;\n        const bounds = this.bounds();\n        const ms = this.max_size / 2;\n        const result = hittest.create_empty_hit_test_result();\n        let x0, x1, y0, y1;\n        if (geometry.direction == 'h') {\n            y0 = bounds.y0;\n            y1 = bounds.y1;\n            const sx0 = sx - ms;\n            const sx1 = sx + ms;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        }\n        else {\n            x0 = bounds.x0;\n            x1 = bounds.x1;\n            const sy0 = sy - ms;\n            const sy1 = sy + ms;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        const hits = this.index.indices({ x0, x1, y0, y1 });\n        result.indices = hits;\n        return result;\n    }\n    _hit_rect(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = this.index.indices({ x0, x1, y0, y1 });\n        return result;\n    }\n    _hit_poly(geometry) {\n        const { sx, sy } = geometry;\n        // TODO (bev) use spatial index to pare candidate list\n        const candidates = range(0, this.sx.length);\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy))\n                hits.push(idx);\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index) {\n        // using objects like this seems a little wonky, since the keys are coerced to\n        // stings, but it works\n        const len = index + 1;\n        const sx = new Array(len);\n        sx[index] = (x0 + x1) / 2;\n        const sy = new Array(len);\n        sy[index] = (y0 + y1) / 2;\n        const size = new Array(len);\n        size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n        const angle = new Array(len);\n        angle[index] = 0; // don't attempt to match glyph angle\n        this._render(ctx, [index], { sx, sy, _size: size, _angle: angle }); // XXX\n    }\n}\nMarkerView.__name__ = \"MarkerView\";\nexport class Marker extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Marker() {\n        this.mixins(['line', 'fill']);\n        this.define({\n            size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\n            angle: [p.AngleSpec, 0],\n        });\n    }\n}\nMarker.__name__ = \"Marker\";\nMarker.init_Marker();\n//# sourceMappingURL=marker.js.map"]},"metadata":{},"sourceType":"module"}