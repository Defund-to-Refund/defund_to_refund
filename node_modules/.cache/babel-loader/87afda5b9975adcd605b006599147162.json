{"ast":null,"code":"import { Program, VertexBuffer, IndexBuffer, Texture2D } from \"@bokeh/gloo2\";\nimport { BaseGLGlyph } from \"./base\";\nimport { vertex_shader } from \"./line.vert\";\nimport { fragment_shader } from \"./line.frag\";\nimport { color2rgba } from \"../../../core/util/color\";\n\nclass DashAtlas {\n  constructor(gl) {\n    this._atlas = {};\n    this._index = 0;\n    this._width = 256;\n    this._height = 256; // Init texture\n\n    this.tex = new Texture2D(gl);\n    this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n    this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n    this.tex.set_size([this._height, this._width], gl.RGBA);\n    this.tex.set_data([0, 0], [this._height, this._width], new Uint8Array(this._height * this._width * 4)); // Init with solid line (index 0 is reserved for this)\n\n    this.get_atlas_data([1]);\n  }\n\n  get_atlas_data(pattern) {\n    const key = pattern.join('-');\n    const findex_period = this._atlas[key];\n\n    if (findex_period === undefined) {\n      const [data, period] = this.make_pattern(pattern);\n      this.tex.set_data([this._index, 0], [1, this._width], new Uint8Array(data.map(x => x + 10)));\n      this._atlas[key] = [this._index / this._height, period];\n      this._index += 1;\n    }\n\n    return this._atlas[key];\n  }\n\n  make_pattern(pattern) {\n    // A pattern is defined as on/off sequence of segments\n    // It must be a multiple of 2\n    if (pattern.length > 1 && pattern.length % 2) {\n      pattern = pattern.concat(pattern);\n    } // Period is sum of elements\n\n\n    let period = 0;\n\n    for (const v of pattern) {\n      period += v;\n    } // Find all start and end of on-segment only\n\n\n    const C = [];\n    let c = 0;\n\n    for (let i = 0, end = pattern.length + 2; i < end; i += 2) {\n      const a = Math.max(0.0001, pattern[i % pattern.length]);\n      const b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n      C.push(c, c + a);\n      c += a + b;\n    } // Build pattern\n\n\n    const n = this._width;\n    const Z = new Float32Array(n * 4);\n\n    for (let i = 0, end = n; i < end; i++) {\n      let dash_end, dash_start, dash_type;\n      const x = period * i / (n - 1); // get index at min - index = np.argmin(abs(C-(x)))\n\n      let index = 0;\n      let val_at_index = 1e16;\n\n      for (let j = 0, endj = C.length; j < endj; j++) {\n        const val = Math.abs(C[j] - x);\n\n        if (val < val_at_index) {\n          index = j;\n          val_at_index = val;\n        }\n      }\n\n      if (index % 2 === 0) {\n        dash_type = x <= C[index] ? +1 : 0;\n        dash_start = C[index];\n        dash_end = C[index + 1];\n      } else {\n        dash_type = x > C[index] ? -1 : 0;\n        dash_start = C[index - 1];\n        dash_end = C[index];\n      }\n\n      Z[i * 4 + 0] = C[index];\n      Z[i * 4 + 1] = dash_type;\n      Z[i * 4 + 2] = dash_start;\n      Z[i * 4 + 3] = dash_end;\n    }\n\n    return [Z, period];\n  }\n\n}\n\nDashAtlas.__name__ = \"DashAtlas\";\nconst joins = {\n  miter: 0,\n  round: 1,\n  bevel: 2\n};\nconst caps = {\n  '': 0,\n  none: 0,\n  '.': 0,\n  round: 1,\n  ')': 1,\n  '(': 1,\n  o: 1,\n  'triangle in': 2,\n  '<': 2,\n  'triangle out': 3,\n  '>': 3,\n  square: 4,\n  '[': 4,\n  ']': 4,\n  '=': 4,\n  butt: 5,\n  '|': 5\n};\nexport class LineGLGlyph extends BaseGLGlyph {\n  init() {\n    const {\n      gl\n    } = this;\n    this._scale_aspect = 0; // keep track, so we know when we need to update segment data\n\n    const vert = vertex_shader;\n    const frag = fragment_shader; // The program\n\n    this.prog = new Program(gl);\n    this.prog.set_shaders(vert, frag);\n    this.index_buffer = new IndexBuffer(gl); // Buffers\n\n    this.vbo_position = new VertexBuffer(gl);\n    this.vbo_tangents = new VertexBuffer(gl);\n    this.vbo_segment = new VertexBuffer(gl);\n    this.vbo_angles = new VertexBuffer(gl);\n    this.vbo_texcoord = new VertexBuffer(gl); // Dash atlas\n\n    this.dash_atlas = new DashAtlas(gl);\n  }\n\n  draw(indices, mainGlyph, trans) {\n    const mainGlGlyph = mainGlyph.glglyph;\n\n    if (mainGlGlyph.data_changed) {\n      if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n        return; // not sure why, but it happens on init sometimes (#4367)\n      }\n\n      mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _bake() and below\n\n      mainGlGlyph._set_data();\n\n      mainGlGlyph.data_changed = false;\n    }\n\n    if (this.visuals_changed) {\n      this._set_visuals();\n\n      this.visuals_changed = false;\n    } // Decompose x-y scale into scalar scale and aspect-vector.\n\n\n    let {\n      sx,\n      sy\n    } = trans;\n    const scale_length = Math.sqrt(sx * sx + sy * sy);\n    sx /= scale_length;\n    sy /= scale_length; // Do we need to re-calculate segment data and cumsum?\n\n    if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(1e-3 * this._scale_aspect)) {\n      mainGlGlyph._update_scale(sx, sy);\n\n      this._scale_aspect = sy / sx;\n    } // Select buffers from main glyph\n    // (which may be this glyph but maybe not if this is a (non)selection glyph)\n\n\n    this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n    this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n    this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n    this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n    this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord); //\n\n    this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n    this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex); // Handle transformation to device coordinates\n\n    const baked_offset = mainGlGlyph._baked_offset;\n    this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n    this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n    this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n    this.prog.set_uniform('u_scale_aspect', 'vec2', [sx, sy]);\n    this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n    this.I_triangles = mainGlGlyph.I_triangles;\n\n    if (this.I_triangles.length < 65535) {\n      // Data is small enough to draw in one pass\n      this.index_buffer.set_size(this.I_triangles.length * 2);\n      this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n      this.prog.draw(this.gl.TRIANGLES, this.index_buffer); // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n    } else {\n      // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n      // First collect indices in chunks\n      indices = Array.from(this.I_triangles);\n      const nvertices = this.I_triangles.length;\n      const chunksize = 64008; // 65536 max. 64008 is divisible by 12\n\n      const chunks = [];\n\n      for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n        chunks.push([]);\n      }\n\n      for (let i = 0, end = indices.length; i < end; i++) {\n        const uint16_index = indices[i] % chunksize;\n        const chunk = Math.floor(indices[i] / chunksize);\n        chunks[chunk].push(uint16_index);\n      } // Then draw each chunk\n\n\n      for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n        const these_indices = new Uint16Array(chunks[chunk]);\n        const offset = chunk * chunksize * 4;\n\n        if (these_indices.length === 0) {\n          continue;\n        }\n\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2); // The actual drawing\n\n        this.index_buffer.set_size(these_indices.length * 2);\n        this.index_buffer.set_data(0, these_indices);\n        this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n      }\n    }\n  }\n\n  _set_data() {\n    this._bake();\n\n    this.vbo_position.set_size(this.V_position.length * 4);\n    this.vbo_position.set_data(0, this.V_position);\n    this.vbo_tangents.set_size(this.V_tangents.length * 4);\n    this.vbo_tangents.set_data(0, this.V_tangents);\n    this.vbo_angles.set_size(this.V_angles.length * 4);\n    this.vbo_angles.set_data(0, this.V_angles);\n    this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n    this.vbo_texcoord.set_data(0, this.V_texcoord);\n  }\n\n  _set_visuals() {\n    const color = color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n    const cap = caps[this.glyph.visuals.line.line_cap.value()];\n    const join = joins[this.glyph.visuals.line.line_join.value()];\n    this.prog.set_uniform('u_color', 'vec4', color);\n    this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n    this.prog.set_uniform('u_antialias', 'float', [0.9]); // Smaller aa-region to obtain crisper images\n\n    this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\n    this.prog.set_uniform('u_linejoin', 'float', [join]);\n    this.prog.set_uniform('u_miter_limit', 'float', [10.0]); // 10 should be a good value\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n\n    const dash_pattern = this.glyph.visuals.line.line_dash.value();\n    let dash_index = 0;\n    let dash_period = 1;\n\n    if (dash_pattern.length) {\n      [dash_index, dash_period] = this.dash_atlas.get_atlas_data(dash_pattern);\n    }\n\n    this.prog.set_uniform('u_dash_index', 'float', [dash_index]); // 0 means solid line\n\n    this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n    this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n    this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\n    this.prog.set_uniform('u_closed', 'float', [0]); // We dont do closed lines\n  }\n\n  _bake() {\n    // This is what you get if you port 50 lines of numpy code to JS.\n    // V_segment is handled in another method, because it depends on the aspect\n    // ratio of the scale (The original paper/code assumed isotropic scaling).\n    //\n    // Buffer dtype from the Python implementation:\n    //\n    // self.vtype = np.dtype( [('a_position', 'f4', 2),\n    //                         ('a_segment',  'f4', 2),\n    //                         ('a_angles',   'f4', 2),\n    //                         ('a_tangents', 'f4', 4),\n    //                         ('a_texcoord', 'f4', 2) ])\n    // Init array of implicit shape nx2\n    let I, T, V_angles2, V_position2, V_tangents2, V_texcoord2, Vp, Vt;\n    const n = this.nvertices;\n\n    const _x = new Float64Array(this.glyph._x);\n\n    const _y = new Float64Array(this.glyph._y); // Init vertex data\n\n\n    const V_position = Vp = new Float32Array(n * 2); //V_segment = new Float32Array(n*2)  # Done later\n\n    const V_angles = new Float32Array(n * 2);\n    const V_tangents = Vt = new Float32Array(n * 4); // mind the 4!\n    // Position\n\n    for (let i = 0, end = n; i < end; i++) {\n      V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n      V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n    } // Tangents & norms (need tangents to calculate segments based on scale)\n\n\n    this.tangents = T = new Float32Array(n * 2 - 2);\n\n    for (let i = 0, end = n - 1; i < end; i++) {\n      T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n      T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n    }\n\n    for (let i = 0, end = n - 1; i < end; i++) {\n      // V['a_tangents'][+1:, :2] = T\n      V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n      V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1]; // V['a_tangents'][:-1, 2:] = T\n\n      V_tangents[i * 4 + 2] = T[i * 2 + 0];\n      V_tangents[i * 4 + 3] = T[i * 2 + 1];\n    } // V['a_tangents'][0  , :2] = T[0]\n\n\n    V_tangents[0 * 4 + 0] = T[0];\n    V_tangents[0 * 4 + 1] = T[1]; // V['a_tangents'][ -1, 2:] = T[-1]\n\n    V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n    V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1]; // Angles\n\n    const A = new Float32Array(n);\n\n    for (let i = 0, end = n; i < end; i++) {\n      A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n    }\n\n    for (let i = 0, end = n - 1; i < end; i++) {\n      V_angles[i * 2 + 0] = A[i];\n      V_angles[i * 2 + 1] = A[i + 1];\n    } // Step 1: A -- B -- C  =>  A -- B, B' -- C\n    // Repeat our array 4 times\n\n\n    const m = 4 * n - 4;\n    this.V_position = V_position2 = new Float32Array(m * 2);\n    this.V_angles = V_angles2 = new Float32Array(m * 2);\n    this.V_tangents = V_tangents2 = new Float32Array(m * 4); // mind the 4!\n\n    this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n    const o = 2; //\n    // Arg, we really need an ndarray thing in JS :/\n\n    for (let i = 0, end = n; i < end; i++) {\n      // all nodes on the line\n      for (let j = 0; j < 4; j++) {\n        // the four quad vertices\n        for (let k = 0; k < 2; k++) {\n          // xy\n          V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n          V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n        } // no offset\n\n\n        for (let k = 0; k < 4; k++) {\n          V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n        }\n      }\n    }\n\n    for (let i = 0, end = n; i < end; i++) {\n      V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n      V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n      V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n      V_texcoord2[(i * 4 + 3) * 2 + 0] = +1; //\n\n      V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n      V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n      V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n      V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n    } // Indices\n    //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n    //I += np.repeat( 4*np.arange(n-1), 6)\n\n\n    const ni = (n - 1) * 6;\n    this.I_triangles = I = new Uint32Array(ni); // Order of indices is such that drawing as line_strip reveals the line skeleton\n    // Might have implications on culling, if we ever turn that on.\n    // Order in paper was: 0 1 2 1 2 3\n\n    for (let i = 0, end = n; i < end; i++) {\n      I[i * 6 + 0] = 0 + 4 * i;\n      I[i * 6 + 1] = 1 + 4 * i;\n      I[i * 6 + 2] = 3 + 4 * i;\n      I[i * 6 + 3] = 2 + 4 * i;\n      I[i * 6 + 4] = 0 + 4 * i;\n      I[i * 6 + 5] = 3 + 4 * i;\n    }\n  }\n\n  _update_scale(sx, sy) {\n    // Update segment data and cumsum so the length along the line has the\n    // scale aspect ratio in it. In the vertex shader we multiply with the\n    // \"isotropic part\" of the scale.\n    let V_segment2;\n    const n = this.nvertices;\n    const m = 4 * n - 4; // Prepare arrays\n\n    const T = this.tangents;\n    const N = new Float32Array(n - 1);\n    const V_segment = new Float32Array(n * 2); // Elements are initialized with 0\n\n    this.V_segment = V_segment2 = new Float32Array(m * 2); // Calculate vector lengths - with scale aspect ratio taken into account\n\n    for (let i = 0, end = n - 1; i < end; i++) {\n      N[i] = Math.sqrt((T[i * 2 + 0] * sx) ** 2 + (T[i * 2 + 1] * sy) ** 2);\n    } // Calculate Segments\n\n\n    let cumsum = 0;\n\n    for (let i = 0, end = n - 1; i < end; i++) {\n      cumsum += N[i];\n      V_segment[(i + 1) * 2 + 0] = cumsum;\n      V_segment[i * 2 + 1] = cumsum;\n    } // Upscale (same loop as in _bake())\n\n\n    for (let i = 0, end = n; i < end; i++) {\n      for (let j = 0; j < 4; j++) {\n        for (let k = 0; k < 2; k++) {\n          V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n        }\n      }\n    } // Update\n\n\n    this.cumsum = cumsum; // L[-1] in Nico's code\n\n    this.vbo_segment.set_size(this.V_segment.length * 4);\n    this.vbo_segment.set_data(0, this.V_segment);\n  }\n\n}\nLineGLGlyph.__name__ = \"LineGLGlyph\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/line.js"],"names":["Program","VertexBuffer","IndexBuffer","Texture2D","BaseGLGlyph","vertex_shader","fragment_shader","color2rgba","DashAtlas","constructor","gl","_atlas","_index","_width","_height","tex","set_wrapping","REPEAT","set_interpolation","NEAREST","set_size","RGBA","set_data","Uint8Array","get_atlas_data","pattern","key","join","findex_period","undefined","data","period","make_pattern","map","x","length","concat","v","C","c","i","end","a","Math","max","b","push","n","Z","Float32Array","dash_end","dash_start","dash_type","index","val_at_index","j","endj","val","abs","__name__","joins","miter","round","bevel","caps","none","o","square","butt","LineGLGlyph","init","_scale_aspect","vert","frag","prog","set_shaders","index_buffer","vbo_position","vbo_tangents","vbo_segment","vbo_angles","vbo_texcoord","dash_atlas","draw","indices","mainGlyph","trans","mainGlGlyph","glglyph","data_changed","isFinite","dx","dy","_baked_offset","_set_data","visuals_changed","_set_visuals","sx","sy","scale_length","sqrt","_update_scale","set_attribute","set_uniform","cumsum","set_texture","baked_offset","pixel_ratio","width","height","I_triangles","Uint16Array","TRIANGLES","Array","from","nvertices","chunksize","chunks","ceil","uint16_index","chunk","floor","these_indices","offset","_bake","V_position","V_tangents","V_angles","V_texcoord","color","glyph","visuals","line","line_color","value","line_alpha","cap","line_cap","line_join","line_width","dash_pattern","line_dash","dash_index","dash_period","line_dash_offset","I","T","V_angles2","V_position2","V_tangents2","V_texcoord2","Vp","Vt","_x","Float64Array","_y","tangents","A","atan2","m","k","ni","Uint32Array","V_segment2","N","V_segment"],"mappings":"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","sourcesContent":["import { Program, VertexBuffer, IndexBuffer, Texture2D } from \"@bokeh/gloo2\";\nimport { BaseGLGlyph } from \"./base\";\nimport { vertex_shader } from \"./line.vert\";\nimport { fragment_shader } from \"./line.frag\";\nimport { color2rgba } from \"../../../core/util/color\";\nclass DashAtlas {\n    constructor(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        // Init texture\n        this.tex = new Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([this._height, this._width], gl.RGBA);\n        this.tex.set_data([0, 0], [this._height, this._width], new Uint8Array(this._height * this._width * 4));\n        // Init with solid line (index 0 is reserved for this)\n        this.get_atlas_data([1]);\n    }\n    get_atlas_data(pattern) {\n        const key = pattern.join('-');\n        const findex_period = this._atlas[key];\n        if (findex_period === undefined) {\n            const [data, period] = this.make_pattern(pattern);\n            this.tex.set_data([this._index, 0], [1, this._width], new Uint8Array(data.map((x) => x + 10)));\n            this._atlas[key] = [this._index / this._height, period];\n            this._index += 1;\n        }\n        return this._atlas[key];\n    }\n    make_pattern(pattern) {\n        // A pattern is defined as on/off sequence of segments\n        // It must be a multiple of 2\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        // Period is sum of elements\n        let period = 0;\n        for (const v of pattern) {\n            period += v;\n        }\n        // Find all start and end of on-segment only\n        const C = [];\n        let c = 0;\n        for (let i = 0, end = pattern.length + 2; i < end; i += 2) {\n            const a = Math.max(0.0001, pattern[i % pattern.length]);\n            const b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push(c, c + a);\n            c += a + b;\n        }\n        // Build pattern\n        const n = this._width;\n        const Z = new Float32Array(n * 4);\n        for (let i = 0, end = n; i < end; i++) {\n            let dash_end, dash_start, dash_type;\n            const x = (period * i) / (n - 1);\n            // get index at min - index = np.argmin(abs(C-(x)))\n            let index = 0;\n            let val_at_index = 1e16;\n            for (let j = 0, endj = C.length; j < endj; j++) {\n                const val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if ((index % 2) === 0) {\n                dash_type = (x <= C[index]) ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            }\n            else {\n                dash_type = (x > C[index]) ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[(i * 4) + 0] = C[index];\n            Z[(i * 4) + 1] = dash_type;\n            Z[(i * 4) + 2] = dash_start;\n            Z[(i * 4) + 3] = dash_end;\n        }\n        return [Z, period];\n    }\n}\nDashAtlas.__name__ = \"DashAtlas\";\nconst joins = { miter: 0, round: 1, bevel: 2 };\nconst caps = {\n    '': 0, none: 0, '.': 0,\n    round: 1, ')': 1, '(': 1, o: 1,\n    'triangle in': 2, '<': 2,\n    'triangle out': 3, '>': 3,\n    square: 4, '[': 4, ']': 4, '=': 4,\n    butt: 5, '|': 5,\n};\nexport class LineGLGlyph extends BaseGLGlyph {\n    init() {\n        const { gl } = this;\n        this._scale_aspect = 0; // keep track, so we know when we need to update segment data\n        const vert = vertex_shader;\n        const frag = fragment_shader;\n        // The program\n        this.prog = new Program(gl);\n        this.prog.set_shaders(vert, frag);\n        this.index_buffer = new IndexBuffer(gl);\n        // Buffers\n        this.vbo_position = new VertexBuffer(gl);\n        this.vbo_tangents = new VertexBuffer(gl);\n        this.vbo_segment = new VertexBuffer(gl);\n        this.vbo_angles = new VertexBuffer(gl);\n        this.vbo_texcoord = new VertexBuffer(gl);\n        // Dash atlas\n        this.dash_atlas = new DashAtlas(gl);\n    }\n    draw(indices, mainGlyph, trans) {\n        const mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return; // not sure why, but it happens on init sometimes (#4367)\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _bake() and below\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        // Decompose x-y scale into scalar scale and aspect-vector.\n        let { sx, sy } = trans;\n        const scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        // Do we need to re-calculate segment data and cumsum?\n        if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(1e-3 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        //\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        // Handle transformation to device coordinates\n        const baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [sx, sy]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            // Data is small enough to draw in one pass\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n            // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n        }\n        else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            indices = Array.from(this.I_triangles);\n            const nvertices = this.I_triangles.length;\n            const chunksize = 64008; // 65536 max. 64008 is divisible by 12\n            const chunks = [];\n            for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n                chunks.push([]);\n            }\n            for (let i = 0, end = indices.length; i < end; i++) {\n                const uint16_index = indices[i] % chunksize;\n                const chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            // Then draw each chunk\n            for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n                const these_indices = new Uint16Array(chunks[chunk]);\n                const offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n            }\n        }\n    }\n    _set_data() {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        this.vbo_texcoord.set_data(0, this.V_texcoord);\n    }\n    _set_visuals() {\n        const color = color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        const cap = caps[this.glyph.visuals.line.line_cap.value()];\n        const join = joins[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]); // Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10.0]); // 10 should be a good value\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n        const dash_pattern = this.glyph.visuals.line.line_dash.value();\n        let dash_index = 0;\n        let dash_period = 1;\n        if (dash_pattern.length) {\n            [dash_index, dash_period] = this.dash_atlas.get_atlas_data(dash_pattern);\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]); // 0 means solid line\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_closed', 'float', [0]); // We dont do closed lines\n    }\n    _bake() {\n        // This is what you get if you port 50 lines of numpy code to JS.\n        // V_segment is handled in another method, because it depends on the aspect\n        // ratio of the scale (The original paper/code assumed isotropic scaling).\n        //\n        // Buffer dtype from the Python implementation:\n        //\n        // self.vtype = np.dtype( [('a_position', 'f4', 2),\n        //                         ('a_segment',  'f4', 2),\n        //                         ('a_angles',   'f4', 2),\n        //                         ('a_tangents', 'f4', 4),\n        //                         ('a_texcoord', 'f4', 2) ])\n        // Init array of implicit shape nx2\n        let I, T, V_angles2, V_position2, V_tangents2, V_texcoord2, Vp, Vt;\n        const n = this.nvertices;\n        const _x = new Float64Array(this.glyph._x);\n        const _y = new Float64Array(this.glyph._y);\n        // Init vertex data\n        const V_position = (Vp = new Float32Array(n * 2));\n        //V_segment = new Float32Array(n*2)  # Done later\n        const V_angles = new Float32Array(n * 2);\n        const V_tangents = (Vt = new Float32Array(n * 4)); // mind the 4!\n        // Position\n        for (let i = 0, end = n; i < end; i++) {\n            V_position[(i * 2) + 0] = _x[i] + this._baked_offset[0];\n            V_position[(i * 2) + 1] = _y[i] + this._baked_offset[1];\n        }\n        // Tangents & norms (need tangents to calculate segments based on scale)\n        this.tangents = (T = new Float32Array((n * 2) - 2));\n        for (let i = 0, end = n - 1; i < end; i++) {\n            T[(i * 2) + 0] = Vp[((i + 1) * 2) + 0] - Vp[(i * 2) + 0];\n            T[(i * 2) + 1] = Vp[((i + 1) * 2) + 1] - Vp[(i * 2) + 1];\n        }\n        for (let i = 0, end = n - 1; i < end; i++) {\n            // V['a_tangents'][+1:, :2] = T\n            V_tangents[((i + 1) * 4) + 0] = T[(i * 2) + 0];\n            V_tangents[((i + 1) * 4) + 1] = T[(i * 2) + 1];\n            // V['a_tangents'][:-1, 2:] = T\n            V_tangents[(i * 4) + 2] = T[(i * 2) + 0];\n            V_tangents[(i * 4) + 3] = T[(i * 2) + 1];\n        }\n        // V['a_tangents'][0  , :2] = T[0]\n        V_tangents[(0 * 4) + 0] = T[0];\n        V_tangents[(0 * 4) + 1] = T[1];\n        // V['a_tangents'][ -1, 2:] = T[-1]\n        V_tangents[((n - 1) * 4) + 2] = T[((n - 2) * 2) + 0];\n        V_tangents[((n - 1) * 4) + 3] = T[((n - 2) * 2) + 1];\n        // Angles\n        const A = new Float32Array(n);\n        for (let i = 0, end = n; i < end; i++) {\n            A[i] = Math.atan2((Vt[(i * 4) + 0] * Vt[(i * 4) + 3]) - (Vt[(i * 4) + 1] * Vt[(i * 4) + 2]), (Vt[(i * 4) + 0] * Vt[(i * 4) + 2]) + (Vt[(i * 4) + 1] * Vt[(i * 4) + 3]));\n        }\n        for (let i = 0, end = n - 1; i < end; i++) {\n            V_angles[(i * 2) + 0] = A[i];\n            V_angles[(i * 2) + 1] = A[i + 1];\n        }\n        // Step 1: A -- B -- C  =>  A -- B, B' -- C\n        // Repeat our array 4 times\n        const m = (4 * n) - 4;\n        this.V_position = (V_position2 = new Float32Array(m * 2));\n        this.V_angles = (V_angles2 = new Float32Array(m * 2));\n        this.V_tangents = (V_tangents2 = new Float32Array(m * 4)); // mind the 4!\n        this.V_texcoord = (V_texcoord2 = new Float32Array(m * 2));\n        const o = 2;\n        //\n        // Arg, we really need an ndarray thing in JS :/\n        for (let i = 0, end = n; i < end; i++) { // all nodes on the line\n            for (let j = 0; j < 4; j++) { // the four quad vertices\n                for (let k = 0; k < 2; k++) { // xy\n                    V_position2[((((i * 4) + j) - o) * 2) + k] = V_position[(i * 2) + k];\n                    V_angles2[(((i * 4) + j) * 2) + k] = V_angles[(i * 2) + k];\n                } // no offset\n                for (let k = 0; k < 4; k++) {\n                    V_tangents2[((((i * 4) + j) - o) * 4) + k] = V_tangents[(i * 4) + k];\n                }\n            }\n        }\n        for (let i = 0, end = n; i < end; i++) {\n            V_texcoord2[(((i * 4) + 0) * 2) + 0] = -1;\n            V_texcoord2[(((i * 4) + 1) * 2) + 0] = -1;\n            V_texcoord2[(((i * 4) + 2) * 2) + 0] = +1;\n            V_texcoord2[(((i * 4) + 3) * 2) + 0] = +1;\n            //\n            V_texcoord2[(((i * 4) + 0) * 2) + 1] = -1;\n            V_texcoord2[(((i * 4) + 1) * 2) + 1] = +1;\n            V_texcoord2[(((i * 4) + 2) * 2) + 1] = -1;\n            V_texcoord2[(((i * 4) + 3) * 2) + 1] = +1;\n        }\n        // Indices\n        //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n        //I += np.repeat( 4*np.arange(n-1), 6)\n        const ni = (n - 1) * 6;\n        this.I_triangles = (I = new Uint32Array(ni));\n        // Order of indices is such that drawing as line_strip reveals the line skeleton\n        // Might have implications on culling, if we ever turn that on.\n        // Order in paper was: 0 1 2 1 2 3\n        for (let i = 0, end = n; i < end; i++) {\n            I[(i * 6) + 0] = 0 + (4 * i);\n            I[(i * 6) + 1] = 1 + (4 * i);\n            I[(i * 6) + 2] = 3 + (4 * i);\n            I[(i * 6) + 3] = 2 + (4 * i);\n            I[(i * 6) + 4] = 0 + (4 * i);\n            I[(i * 6) + 5] = 3 + (4 * i);\n        }\n    }\n    _update_scale(sx, sy) {\n        // Update segment data and cumsum so the length along the line has the\n        // scale aspect ratio in it. In the vertex shader we multiply with the\n        // \"isotropic part\" of the scale.\n        let V_segment2;\n        const n = this.nvertices;\n        const m = (4 * n) - 4;\n        // Prepare arrays\n        const T = this.tangents;\n        const N = new Float32Array(n - 1);\n        const V_segment = new Float32Array(n * 2); // Elements are initialized with 0\n        this.V_segment = (V_segment2 = new Float32Array(m * 2));\n        // Calculate vector lengths - with scale aspect ratio taken into account\n        for (let i = 0, end = n - 1; i < end; i++) {\n            N[i] = Math.sqrt((T[(i * 2) + 0] * sx) ** 2 + (T[(i * 2) + 1] * sy) ** 2);\n        }\n        // Calculate Segments\n        let cumsum = 0;\n        for (let i = 0, end = n - 1; i < end; i++) {\n            cumsum += N[i];\n            V_segment[((i + 1) * 2) + 0] = cumsum;\n            V_segment[(i * 2) + 1] = cumsum;\n        }\n        // Upscale (same loop as in _bake())\n        for (let i = 0, end = n; i < end; i++) {\n            for (let j = 0; j < 4; j++) {\n                for (let k = 0; k < 2; k++) {\n                    V_segment2[(((i * 4) + j) * 2) + k] = V_segment[(i * 2) + k];\n                }\n            }\n        }\n        // Update\n        this.cumsum = cumsum; // L[-1] in Nico's code\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        this.vbo_segment.set_data(0, this.V_segment);\n    }\n}\nLineGLGlyph.__name__ = \"LineGLGlyph\";\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}