{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { angle_between } from \"../../core/util/math\";\nexport class WedgeView extends XYGlyphView {\n  _map_data() {\n    if (this.model.properties.radius.units == \"data\") this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);else this.sradius = this._radius;\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    sradius,\n    _start_angle,\n    _end_angle\n  }) {\n    const direction = this.model.properties.direction.value();\n\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) continue;\n      ctx.beginPath();\n      ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n      ctx.lineTo(sx[i], sy[i]);\n      ctx.closePath();\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n        ctx.fill();\n      }\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    let dist, sx0, sx1, sy0, sy1, x0, x1, y0, y1;\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy); // check diameter first\n\n    const max_diameter = 2 * this.max_radius;\n\n    if (this.model.properties.radius.units === \"data\") {\n      x0 = x - max_diameter;\n      x1 = x + max_diameter;\n      y0 = y - max_diameter;\n      y1 = y + max_diameter;\n    } else {\n      sx0 = sx - max_diameter;\n      sx1 = sx + max_diameter;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      sy0 = sy - max_diameter;\n      sy1 = sy + max_diameter;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    const candidates = [];\n\n    for (const i of this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    })) {\n      const r2 = this.sradius[i] ** 2;\n      [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n      [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n      dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n\n      if (dist <= r2) {\n        candidates.push([i, dist]);\n      }\n    }\n\n    const direction = this.model.properties.direction.value();\n    const hits = [];\n\n    for (const [i, dist] of candidates) {\n      // NOTE: minus the angle because JS uses non-mathy convention for angles\n      const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n\n      if (angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n        hits.push([i, dist]);\n      }\n    }\n\n    return hittest.create_hit_test_result_from_hits(hits);\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_area_legend(this.visuals, ctx, bbox, index);\n  }\n\n  _scenterxy(i) {\n    const r = this.sradius[i] / 2;\n    const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n    return {\n      x: this.sx[i] + r * Math.cos(a),\n      y: this.sy[i] + r * Math.sin(a)\n    };\n  }\n\n  scenterx(i) {\n    return this._scenterxy(i).x;\n  }\n\n  scentery(i) {\n    return this._scenterxy(i).y;\n  }\n\n}\nWedgeView.__name__ = \"WedgeView\";\nexport class Wedge extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Wedge() {\n    this.prototype.default_view = WedgeView;\n    this.mixins(['line', 'fill']);\n    this.define({\n      direction: [p.Direction, 'anticlock'],\n      radius: [p.DistanceSpec],\n      start_angle: [p.AngleSpec],\n      end_angle: [p.AngleSpec]\n    });\n  }\n\n}\nWedge.__name__ = \"Wedge\";\nWedge.init_Wedge();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/wedge.js"],"names":["XYGlyph","XYGlyphView","generic_area_legend","hittest","p","angle_between","WedgeView","_map_data","model","properties","radius","units","sradius","sdist","renderer","xscale","_x","_radius","_render","ctx","indices","sx","sy","_start_angle","_end_angle","direction","value","i","isNaN","beginPath","arc","lineTo","closePath","visuals","fill","doit","set_vectorize","line","stroke","_hit_point","geometry","dist","sx0","sx1","sy0","sy1","x0","x1","y0","y1","x","invert","y","yscale","max_diameter","max_radius","r_invert","candidates","index","r2","r_compute","_y","push","hits","angle","Math","atan2","create_hit_test_result_from_hits","draw_legend_for_index","bbox","_scenterxy","r","a","cos","sin","scenterx","scentery","__name__","Wedge","constructor","attrs","init_Wedge","prototype","default_view","mixins","define","Direction","DistanceSpec","start_angle","AngleSpec","end_angle"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { angle_between } from \"../../core/util/math\";\nexport class WedgeView extends XYGlyphView {\n    _map_data() {\n        if (this.model.properties.radius.units == \"data\")\n            this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n        else\n            this.sradius = this._radius;\n    }\n    _render(ctx, indices, { sx, sy, sradius, _start_angle, _end_angle }) {\n        const direction = this.model.properties.direction.value();\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i]))\n                continue;\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n            ctx.lineTo(sx[i], sy[i]);\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        let dist, sx0, sx1, sy0, sy1, x0, x1, y0, y1;\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        // check diameter first\n        const max_diameter = 2 * this.max_radius;\n        if (this.model.properties.radius.units === \"data\") {\n            x0 = x - max_diameter;\n            x1 = x + max_diameter;\n            y0 = y - max_diameter;\n            y1 = y + max_diameter;\n        }\n        else {\n            sx0 = sx - max_diameter;\n            sx1 = sx + max_diameter;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            sy0 = sy - max_diameter;\n            sy1 = sy + max_diameter;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        const candidates = [];\n        for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n            const r2 = this.sradius[i] ** 2;\n            [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n            [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n            dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n            if (dist <= r2) {\n                candidates.push([i, dist]);\n            }\n        }\n        const direction = this.model.properties.direction.value();\n        const hits = [];\n        for (const [i, dist] of candidates) {\n            // NOTE: minus the angle because JS uses non-mathy convention for angles\n            const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_hit_test_result_from_hits(hits);\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_area_legend(this.visuals, ctx, bbox, index);\n    }\n    _scenterxy(i) {\n        const r = this.sradius[i] / 2;\n        const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n        return { x: this.sx[i] + (r * Math.cos(a)), y: this.sy[i] + (r * Math.sin(a)) };\n    }\n    scenterx(i) {\n        return this._scenterxy(i).x;\n    }\n    scentery(i) {\n        return this._scenterxy(i).y;\n    }\n}\nWedgeView.__name__ = \"WedgeView\";\nexport class Wedge extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Wedge() {\n        this.prototype.default_view = WedgeView;\n        this.mixins(['line', 'fill']);\n        this.define({\n            direction: [p.Direction, 'anticlock'],\n            radius: [p.DistanceSpec],\n            start_angle: [p.AngleSpec],\n            end_angle: [p.AngleSpec],\n        });\n    }\n}\nWedge.__name__ = \"Wedge\";\nWedge.init_Wedge();\n//# sourceMappingURL=wedge.js.map"]},"metadata":{},"sourceType":"module"}