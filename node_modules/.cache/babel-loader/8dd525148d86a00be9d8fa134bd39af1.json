{"ast":null,"code":"import { AdaptiveTicker } from \"./adaptive_ticker\";\nimport { range } from \"../../core/util/array\";\nexport class LogTicker extends AdaptiveTicker {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_LogTicker() {\n    this.override({\n      mantissas: [1, 5]\n    });\n  }\n\n  get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n    const num_minor_ticks = this.num_minor_ticks;\n    const minor_ticks = [];\n    const base = this.base;\n    const log_low = Math.log(data_low) / Math.log(base);\n    const log_high = Math.log(data_high) / Math.log(base);\n    const log_interval = log_high - log_low;\n    let ticks;\n\n    if (!isFinite(log_interval)) {\n      ticks = [];\n    } else if (log_interval < 2) {\n      // treat as linear ticker\n      const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n      const start_factor = Math.floor(data_low / interval);\n      const end_factor = Math.ceil(data_high / interval);\n      ticks = range(start_factor, end_factor + 1).filter(factor => factor != 0).map(factor => factor * interval).filter(tick => data_low <= tick && tick <= data_high);\n\n      if (num_minor_ticks > 0 && ticks.length > 0) {\n        const minor_interval = interval / num_minor_ticks;\n        const minor_offsets = range(0, num_minor_ticks).map(i => i * minor_interval);\n\n        for (const x of minor_offsets.slice(1)) {\n          minor_ticks.push(ticks[0] - x);\n        }\n\n        for (const tick of ticks) {\n          for (const x of minor_offsets) {\n            minor_ticks.push(tick + x);\n          }\n        }\n      }\n    } else {\n      const startlog = Math.ceil(log_low * 0.999999);\n      const endlog = Math.floor(log_high * 1.000001);\n      const interval = Math.ceil((endlog - startlog) / 9.0);\n      ticks = range(startlog - 1, endlog + 1, interval).map(i => base ** i);\n\n      if (num_minor_ticks > 0 && ticks.length > 0) {\n        const minor_interval = base ** interval / num_minor_ticks;\n        const minor_offsets = range(1, num_minor_ticks + 1).map(i => i * minor_interval);\n\n        for (const x of minor_offsets) {\n          minor_ticks.push(ticks[0] / x);\n        }\n\n        minor_ticks.push(ticks[0]);\n\n        for (const tick of ticks) {\n          for (const x of minor_offsets) {\n            minor_ticks.push(tick * x);\n          }\n        }\n      }\n    }\n\n    return {\n      major: ticks.filter(tick => data_low <= tick && tick <= data_high),\n      minor: minor_ticks.filter(tick => data_low <= tick && tick <= data_high)\n    };\n  }\n\n}\nLogTicker.__name__ = \"LogTicker\";\nLogTicker.init_LogTicker();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/log_ticker.js"],"names":["AdaptiveTicker","range","LogTicker","constructor","attrs","init_LogTicker","override","mantissas","get_ticks_no_defaults","data_low","data_high","_cross_loc","desired_n_ticks","num_minor_ticks","minor_ticks","base","log_low","Math","log","log_high","log_interval","ticks","isFinite","interval","get_interval","start_factor","floor","end_factor","ceil","filter","factor","map","tick","length","minor_interval","minor_offsets","i","x","slice","push","startlog","endlog","major","minor","__name__"],"mappings":"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","sourcesContent":["import { AdaptiveTicker } from \"./adaptive_ticker\";\nimport { range } from \"../../core/util/array\";\nexport class LogTicker extends AdaptiveTicker {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_LogTicker() {\n        this.override({\n            mantissas: [1, 5],\n        });\n    }\n    get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n        const num_minor_ticks = this.num_minor_ticks;\n        const minor_ticks = [];\n        const base = this.base;\n        const log_low = Math.log(data_low) / Math.log(base);\n        const log_high = Math.log(data_high) / Math.log(base);\n        const log_interval = log_high - log_low;\n        let ticks;\n        if (!isFinite(log_interval)) {\n            ticks = [];\n        }\n        else if (log_interval < 2) { // treat as linear ticker\n            const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n            const start_factor = Math.floor(data_low / interval);\n            const end_factor = Math.ceil(data_high / interval);\n            ticks = range(start_factor, end_factor + 1)\n                .filter((factor) => factor != 0)\n                .map((factor) => factor * interval)\n                .filter((tick) => data_low <= tick && tick <= data_high);\n            if (num_minor_ticks > 0 && ticks.length > 0) {\n                const minor_interval = interval / num_minor_ticks;\n                const minor_offsets = range(0, num_minor_ticks).map((i) => i * minor_interval);\n                for (const x of minor_offsets.slice(1)) {\n                    minor_ticks.push(ticks[0] - x);\n                }\n                for (const tick of ticks) {\n                    for (const x of minor_offsets) {\n                        minor_ticks.push(tick + x);\n                    }\n                }\n            }\n        }\n        else {\n            const startlog = Math.ceil(log_low * 0.999999);\n            const endlog = Math.floor(log_high * 1.000001);\n            const interval = Math.ceil((endlog - startlog) / 9.0);\n            ticks = range(startlog - 1, endlog + 1, interval)\n                .map((i) => base ** i);\n            if (num_minor_ticks > 0 && ticks.length > 0) {\n                const minor_interval = base ** interval / num_minor_ticks;\n                const minor_offsets = range(1, num_minor_ticks + 1).map((i) => i * minor_interval);\n                for (const x of minor_offsets) {\n                    minor_ticks.push(ticks[0] / x);\n                }\n                minor_ticks.push(ticks[0]);\n                for (const tick of ticks) {\n                    for (const x of minor_offsets) {\n                        minor_ticks.push(tick * x);\n                    }\n                }\n            }\n        }\n        return {\n            major: ticks.filter((tick) => data_low <= tick && tick <= data_high),\n            minor: minor_ticks.filter((tick) => data_low <= tick && tick <= data_high),\n        };\n    }\n}\nLogTicker.__name__ = \"LogTicker\";\nLogTicker.init_LogTicker();\n//# sourceMappingURL=log_ticker.js.map"]},"metadata":{},"sourceType":"module"}