{"ast":null,"code":"import { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport { min, max } from \"../../core/util/array\";\nimport { sum } from \"../../core/util/arrayable\";\nimport * as hittest from \"../../core/hittest\";\nimport { isArray, isTypedArray } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nexport class MultiPolygonsView extends GlyphView {\n  _index_data() {\n    const points = [];\n\n    for (let i = 0, end = this._xs.length; i < end; i++) {\n      for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n        const xs = this._xs[i][j][0]; // do not use holes\n\n        const ys = this._ys[i][j][0]; // do not use holes\n\n        if (xs.length == 0) continue;\n        points.push({\n          x0: min(xs),\n          y0: min(ys),\n          x1: max(xs),\n          y1: max(ys),\n          i\n        });\n      }\n    }\n\n    this.hole_index = this._index_hole_data(); // should this be set here?\n\n    return new SpatialIndex(points);\n  }\n\n  _index_hole_data() {\n    // need advice on how to use this sure if this could be more useful\n    const points = [];\n\n    for (let i = 0, end = this._xs.length; i < end; i++) {\n      for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n        if (this._xs[i][j].length > 1) {\n          for (let k = 1, endk = this._xs[i][j].length; k < endk; k++) {\n            const xs = this._xs[i][j][k]; // only use holes\n\n            const ys = this._ys[i][j][k]; // only use holes\n\n            if (xs.length == 0) continue;\n            points.push({\n              x0: min(xs),\n              y0: min(ys),\n              x1: max(xs),\n              y1: max(ys),\n              i\n            });\n          }\n        }\n      }\n    }\n\n    return new SpatialIndex(points);\n  }\n\n  _mask_data() {\n    const xr = this.renderer.plot_view.frame.x_ranges.default;\n    const [x0, x1] = [xr.min, xr.max];\n    const yr = this.renderer.plot_view.frame.y_ranges.default;\n    const [y0, y1] = [yr.min, yr.max];\n    const indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    }); // TODO this is probably needed in patches as well so that we don't draw glyphs multiple times\n\n    return indices.sort((a, b) => a - b).filter((value, index, array) => {\n      return index === 0 || value !== array[index - 1];\n    });\n  }\n\n  _inner_loop(ctx, sx, sy) {\n    ctx.beginPath();\n\n    for (let j = 0, endj = sx.length; j < endj; j++) {\n      for (let k = 0, endk = sx[j].length; k < endk; k++) {\n        const _sx = sx[j][k];\n        const _sy = sy[j][k];\n\n        for (let l = 0, endl = _sx.length; l < endl; l++) {\n          if (l == 0) {\n            ctx.moveTo(_sx[l], _sy[l]);\n            continue;\n          } else ctx.lineTo(_sx[l], _sy[l]);\n        }\n\n        ctx.closePath();\n      }\n    }\n  }\n\n  _render(ctx, indices, {\n    sxs,\n    sys\n  }) {\n    if (this.visuals.fill.doit || this.visuals.line.doit) {\n      for (const i of indices) {\n        const [sx, sy] = [sxs[i], sys[i]];\n\n        if (this.visuals.fill.doit) {\n          this.visuals.fill.set_vectorize(ctx, i);\n\n          this._inner_loop(ctx, sx, sy);\n\n          ctx.fill(\"evenodd\");\n        }\n\n        this.visuals.hatch.doit2(ctx, i, () => {\n          this._inner_loop(ctx, sx, sy);\n\n          ctx.fill(\"evenodd\");\n        }, () => this.renderer.request_render());\n\n        if (this.visuals.line.doit) {\n          this.visuals.line.set_vectorize(ctx, i);\n\n          this._inner_loop(ctx, sx, sy);\n\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  _hit_rect(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const xs = [sx0, sx1, sx1, sx0];\n    const ys = [sy0, sy0, sy1, sy1];\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const candidates = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n      const sxss = this.sxs[idx];\n      const syss = this.sys[idx];\n      let hit = true;\n\n      for (let j = 0, endj = sxss.length; j < endj; j++) {\n        for (let k = 0, endk = sxss[j][0].length; k < endk; k++) {\n          const sx = sxss[j][0][k];\n          const sy = syss[j][0][k];\n\n          if (!hittest.point_in_poly(sx, sy, xs, ys)) {\n            hit = false;\n            break;\n          }\n        }\n\n        if (!hit) break;\n      }\n\n      if (hit) hits.push(idx);\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy);\n    const candidates = this.index.indices({\n      x0: x,\n      y0: y,\n      x1: x,\n      y1: y\n    });\n    const hole_candidates = this.hole_index.indices({\n      x0: x,\n      y0: y,\n      x1: x,\n      y1: y\n    });\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n      const sxs = this.sxs[idx];\n      const sys = this.sys[idx];\n\n      for (let j = 0, endj = sxs.length; j < endj; j++) {\n        const nk = sxs[j].length;\n\n        if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {\n          if (nk == 1) {\n            hits.push(idx);\n          } else if (hole_candidates.indexOf(idx) == -1) {\n            hits.push(idx);\n          } else if (nk > 1) {\n            let in_a_hole = false;\n\n            for (let k = 1; k < nk; k++) {\n              const sxs_k = sxs[j][k];\n              const sys_k = sys[j][k];\n\n              if (hittest.point_in_poly(sx, sy, sxs_k, sys_k)) {\n                in_a_hole = true;\n                break;\n              } else {\n                continue;\n              }\n            }\n\n            if (!in_a_hole) {\n              hits.push(idx);\n            }\n          }\n        }\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _get_snap_coord(array) {\n    return sum(array) / array.length;\n  }\n\n  scenterx(i, sx, sy) {\n    if (this.sxs[i].length == 1) {\n      // We don't have discontinuous objects so we're ok\n      return this._get_snap_coord(this.sxs[i][0][0]);\n    } else {\n      // We have discontinuous objects, so we need to find which\n      // one we're in, we can use point_in_poly again\n      const sxs = this.sxs[i];\n      const sys = this.sys[i];\n\n      for (let j = 0, end = sxs.length; j < end; j++) {\n        if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) return this._get_snap_coord(sxs[j][0]);\n      }\n    }\n\n    unreachable();\n  }\n\n  scentery(i, sx, sy) {\n    if (this.sys[i].length == 1) {\n      // We don't have discontinuous objects so we're ok\n      return this._get_snap_coord(this.sys[i][0][0]);\n    } else {\n      // We have discontinuous objects, so we need to find which\n      // one we're in, we can use point_in_poly again\n      const sxs = this.sxs[i];\n      const sys = this.sys[i];\n\n      for (let j = 0, end = sxs.length; j < end; j++) {\n        if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) return this._get_snap_coord(sys[j][0]);\n      }\n    }\n\n    unreachable();\n  }\n\n  map_data() {\n    const self = this;\n\n    for (let [xname, yname] of this.model._coords) {\n      const sxname = `s${xname}`;\n      const syname = `s${yname}`;\n      xname = `_${xname}`;\n      yname = `_${yname}`;\n\n      if (self[xname] != null && (isArray(self[xname][0]) || isTypedArray(self[xname][0]))) {\n        const ni = self[xname].length;\n        self[sxname] = new Array(ni);\n        self[syname] = new Array(ni);\n\n        for (let i = 0; i < ni; i++) {\n          const nj = self[xname][i].length;\n          self[sxname][i] = new Array(nj);\n          self[syname][i] = new Array(nj);\n\n          for (let j = 0; j < nj; j++) {\n            const nk = self[xname][i][j].length;\n            self[sxname][i][j] = new Array(nk);\n            self[syname][i][j] = new Array(nk);\n\n            for (let k = 0; k < nk; k++) {\n              const [sx, sy] = this.map_to_screen(self[xname][i][j][k], self[yname][i][j][k]);\n              self[sxname][i][j][k] = sx;\n              self[syname][i][j][k] = sy;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_area_legend(this.visuals, ctx, bbox, index);\n  }\n\n}\nMultiPolygonsView.__name__ = \"MultiPolygonsView\";\nexport class MultiPolygons extends Glyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_MultiPolygons() {\n    this.prototype.default_view = MultiPolygonsView;\n    this.coords([['xs', 'ys']]);\n    this.mixins(['line', 'fill', 'hatch']);\n  }\n\n}\nMultiPolygons.__name__ = \"MultiPolygons\";\nMultiPolygons.init_MultiPolygons();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/multi_polygons.js"],"names":["SpatialIndex","Glyph","GlyphView","generic_area_legend","min","max","sum","hittest","isArray","isTypedArray","unreachable","MultiPolygonsView","_index_data","points","i","end","_xs","length","j","endj","xs","ys","_ys","push","x0","y0","x1","y1","hole_index","_index_hole_data","k","endk","_mask_data","xr","renderer","plot_view","frame","x_ranges","default","yr","y_ranges","indices","index","sort","a","b","filter","value","array","_inner_loop","ctx","sx","sy","beginPath","_sx","_sy","l","endl","moveTo","lineTo","closePath","_render","sxs","sys","visuals","fill","doit","line","set_vectorize","hatch","doit2","request_render","stroke","_hit_rect","geometry","sx0","sx1","sy0","sy1","xscale","r_invert","yscale","candidates","hits","idx","sxss","syss","hit","point_in_poly","result","create_empty_hit_test_result","_hit_point","x","invert","y","hole_candidates","nk","indexOf","in_a_hole","sxs_k","sys_k","_get_snap_coord","scenterx","scentery","map_data","self","xname","yname","model","_coords","sxname","syname","ni","Array","nj","map_to_screen","draw_legend_for_index","bbox","__name__","MultiPolygons","constructor","attrs","init_MultiPolygons","prototype","default_view","coords","mixins"],"mappings":"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","sourcesContent":["import { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport { min, max } from \"../../core/util/array\";\nimport { sum } from \"../../core/util/arrayable\";\nimport * as hittest from \"../../core/hittest\";\nimport { isArray, isTypedArray } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nexport class MultiPolygonsView extends GlyphView {\n    _index_data() {\n        const points = [];\n        for (let i = 0, end = this._xs.length; i < end; i++) {\n            for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n                const xs = this._xs[i][j][0]; // do not use holes\n                const ys = this._ys[i][j][0]; // do not use holes\n                if (xs.length == 0)\n                    continue;\n                points.push({ x0: min(xs), y0: min(ys), x1: max(xs), y1: max(ys), i });\n            }\n        }\n        this.hole_index = this._index_hole_data(); // should this be set here?\n        return new SpatialIndex(points);\n    }\n    _index_hole_data() {\n        // need advice on how to use this sure if this could be more useful\n        const points = [];\n        for (let i = 0, end = this._xs.length; i < end; i++) {\n            for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n                if (this._xs[i][j].length > 1) {\n                    for (let k = 1, endk = this._xs[i][j].length; k < endk; k++) {\n                        const xs = this._xs[i][j][k]; // only use holes\n                        const ys = this._ys[i][j][k]; // only use holes\n                        if (xs.length == 0)\n                            continue;\n                        points.push({ x0: min(xs), y0: min(ys), x1: max(xs), y1: max(ys), i });\n                    }\n                }\n            }\n        }\n        return new SpatialIndex(points);\n    }\n    _mask_data() {\n        const xr = this.renderer.plot_view.frame.x_ranges.default;\n        const [x0, x1] = [xr.min, xr.max];\n        const yr = this.renderer.plot_view.frame.y_ranges.default;\n        const [y0, y1] = [yr.min, yr.max];\n        const indices = this.index.indices({ x0, x1, y0, y1 });\n        // TODO this is probably needed in patches as well so that we don't draw glyphs multiple times\n        return indices.sort((a, b) => a - b).filter((value, index, array) => {\n            return (index === 0) || (value !== array[index - 1]);\n        });\n    }\n    _inner_loop(ctx, sx, sy) {\n        ctx.beginPath();\n        for (let j = 0, endj = sx.length; j < endj; j++) {\n            for (let k = 0, endk = sx[j].length; k < endk; k++) {\n                const _sx = sx[j][k];\n                const _sy = sy[j][k];\n                for (let l = 0, endl = _sx.length; l < endl; l++) {\n                    if (l == 0) {\n                        ctx.moveTo(_sx[l], _sy[l]);\n                        continue;\n                    }\n                    else\n                        ctx.lineTo(_sx[l], _sy[l]);\n                }\n                ctx.closePath();\n            }\n        }\n    }\n    _render(ctx, indices, { sxs, sys }) {\n        if (this.visuals.fill.doit || this.visuals.line.doit) {\n            for (const i of indices) {\n                const [sx, sy] = [sxs[i], sys[i]];\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    this._inner_loop(ctx, sx, sy);\n                    ctx.fill(\"evenodd\");\n                }\n                this.visuals.hatch.doit2(ctx, i, () => {\n                    this._inner_loop(ctx, sx, sy);\n                    ctx.fill(\"evenodd\");\n                }, () => this.renderer.request_render());\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    this._inner_loop(ctx, sx, sy);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n    _hit_rect(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const xs = [sx0, sx1, sx1, sx0];\n        const ys = [sy0, sy0, sy1, sy1];\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const candidates = this.index.indices({ x0, x1, y0, y1 });\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            const sxss = this.sxs[idx];\n            const syss = this.sys[idx];\n            let hit = true;\n            for (let j = 0, endj = sxss.length; j < endj; j++) {\n                for (let k = 0, endk = sxss[j][0].length; k < endk; k++) {\n                    const sx = sxss[j][0][k];\n                    const sy = syss[j][0][k];\n                    if (!hittest.point_in_poly(sx, sy, xs, ys)) {\n                        hit = false;\n                        break;\n                    }\n                }\n                if (!hit)\n                    break;\n            }\n            if (hit)\n                hits.push(idx);\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n        const hole_candidates = this.hole_index.indices({ x0: x, y0: y, x1: x, y1: y });\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            const sxs = this.sxs[idx];\n            const sys = this.sys[idx];\n            for (let j = 0, endj = sxs.length; j < endj; j++) {\n                const nk = sxs[j].length;\n                if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {\n                    if (nk == 1) {\n                        hits.push(idx);\n                    }\n                    else if (hole_candidates.indexOf(idx) == -1) {\n                        hits.push(idx);\n                    }\n                    else if (nk > 1) {\n                        let in_a_hole = false;\n                        for (let k = 1; k < nk; k++) {\n                            const sxs_k = sxs[j][k];\n                            const sys_k = sys[j][k];\n                            if (hittest.point_in_poly(sx, sy, sxs_k, sys_k)) {\n                                in_a_hole = true;\n                                break;\n                            }\n                            else {\n                                continue;\n                            }\n                        }\n                        if (!in_a_hole) {\n                            hits.push(idx);\n                        }\n                    }\n                }\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _get_snap_coord(array) {\n        return sum(array) / array.length;\n    }\n    scenterx(i, sx, sy) {\n        if (this.sxs[i].length == 1) {\n            // We don't have discontinuous objects so we're ok\n            return this._get_snap_coord(this.sxs[i][0][0]);\n        }\n        else {\n            // We have discontinuous objects, so we need to find which\n            // one we're in, we can use point_in_poly again\n            const sxs = this.sxs[i];\n            const sys = this.sys[i];\n            for (let j = 0, end = sxs.length; j < end; j++) {\n                if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0]))\n                    return this._get_snap_coord(sxs[j][0]);\n            }\n        }\n        unreachable();\n    }\n    scentery(i, sx, sy) {\n        if (this.sys[i].length == 1) {\n            // We don't have discontinuous objects so we're ok\n            return this._get_snap_coord(this.sys[i][0][0]);\n        }\n        else {\n            // We have discontinuous objects, so we need to find which\n            // one we're in, we can use point_in_poly again\n            const sxs = this.sxs[i];\n            const sys = this.sys[i];\n            for (let j = 0, end = sxs.length; j < end; j++) {\n                if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0]))\n                    return this._get_snap_coord(sys[j][0]);\n            }\n        }\n        unreachable();\n    }\n    map_data() {\n        const self = this;\n        for (let [xname, yname] of this.model._coords) {\n            const sxname = `s${xname}`;\n            const syname = `s${yname}`;\n            xname = `_${xname}`;\n            yname = `_${yname}`;\n            if (self[xname] != null && (isArray(self[xname][0]) || isTypedArray(self[xname][0]))) {\n                const ni = self[xname].length;\n                self[sxname] = new Array(ni);\n                self[syname] = new Array(ni);\n                for (let i = 0; i < ni; i++) {\n                    const nj = self[xname][i].length;\n                    self[sxname][i] = new Array(nj);\n                    self[syname][i] = new Array(nj);\n                    for (let j = 0; j < nj; j++) {\n                        const nk = self[xname][i][j].length;\n                        self[sxname][i][j] = new Array(nk);\n                        self[syname][i][j] = new Array(nk);\n                        for (let k = 0; k < nk; k++) {\n                            const [sx, sy] = this.map_to_screen(self[xname][i][j][k], self[yname][i][j][k]);\n                            self[sxname][i][j][k] = sx;\n                            self[syname][i][j][k] = sy;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_area_legend(this.visuals, ctx, bbox, index);\n    }\n}\nMultiPolygonsView.__name__ = \"MultiPolygonsView\";\nexport class MultiPolygons extends Glyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_MultiPolygons() {\n        this.prototype.default_view = MultiPolygonsView;\n        this.coords([['xs', 'ys']]);\n        this.mixins(['line', 'fill', 'hatch']);\n    }\n}\nMultiPolygons.__name__ = \"MultiPolygons\";\nMultiPolygons.init_MultiPolygons();\n//# sourceMappingURL=multi_polygons.js.map"]},"metadata":{},"sourceType":"module"}