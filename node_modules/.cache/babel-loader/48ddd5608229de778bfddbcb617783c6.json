{"ast":null,"code":"import * as palettes from \"./palettes\";\nimport { zip, unzip, sum, cumsum, copy, transpose } from \"../core/util/array\";\nimport { isArray } from \"../core/util/types\";\nimport { sprintf } from \"../core/util/templating\";\nimport { Plot, ColumnDataSource, GlyphRenderer, HoverTool, AnnularWedge, Quad, Text, DataRange1d, FactorRange, LinearAxis, CategoricalAxis, LinearScale, CategoricalScale, BasicTickFormatter, NumeralTickFormatter } from \"./models\";\n\nfunction num2hexcolor(num) {\n  return sprintf(\"#%06x\", num);\n}\n\nfunction hexcolor2rgb(color) {\n  const r = parseInt(color.substr(1, 2), 16);\n  const g = parseInt(color.substr(3, 2), 16);\n  const b = parseInt(color.substr(5, 2), 16);\n  return [r, g, b];\n}\n\nfunction is_dark([r, g, b]) {\n  const l = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n  return l >= 0.6;\n}\n\nfunction norm_palette(palette = \"Spectral11\") {\n  if (isArray(palette)) return palette;else {\n    return palettes[palette].map(num2hexcolor);\n  }\n}\n\nexport function pie(data, opts = {}) {\n  const labels = [];\n  const values = [];\n\n  for (let i = 0; i < Math.min(data.labels.length, data.values.length); i++) {\n    if (data.values[i] > 0) {\n      labels.push(data.labels[i]);\n      values.push(data.values[i]);\n    }\n  }\n\n  const start_angle = opts.start_angle != null ? opts.start_angle : 0;\n  const end_angle = opts.end_angle != null ? opts.end_angle : start_angle + 2 * Math.PI;\n  const angle_span = Math.abs(end_angle - start_angle);\n\n  const to_radians = x => angle_span * x;\n\n  const total_value = sum(values);\n  const normalized_values = values.map(v => v / total_value);\n  const cumulative_values = cumsum(normalized_values);\n  const end_angles = cumulative_values.map(v => start_angle + to_radians(v));\n  const start_angles = [start_angle].concat(end_angles.slice(0, -1));\n  const half_angles = zip(start_angles, end_angles).map(([start, end]) => (start + end) / 2);\n  let cx;\n  let cy;\n\n  if (opts.center == null) {\n    cx = 0;\n    cy = 0;\n  } else if (isArray(opts.center)) {\n    cx = opts.center[0];\n    cy = opts.center[1];\n  } else {\n    cx = opts.center.x;\n    cy = opts.center.y;\n  }\n\n  const inner_radius = opts.inner_radius != null ? opts.inner_radius : 0;\n  const outer_radius = opts.outer_radius != null ? opts.outer_radius : 1;\n  const palette = norm_palette(opts.palette);\n  const colors = [];\n\n  for (let i = 0; i < normalized_values.length; i++) colors.push(palette[i % palette.length]);\n\n  const text_colors = colors.map(c => is_dark(hexcolor2rgb(c)) ? \"white\" : \"black\");\n\n  function to_cartesian(r, alpha) {\n    return [r * Math.cos(alpha), r * Math.sin(alpha)];\n  }\n\n  const half_radius = (inner_radius + outer_radius) / 2;\n  let [text_cx, text_cy] = unzip(half_angles.map(half_angle => to_cartesian(half_radius, half_angle)));\n  text_cx = text_cx.map(x => x + cx);\n  text_cy = text_cy.map(y => y + cy);\n  const text_angles = half_angles.map(a => {\n    if (a >= Math.PI / 2 && a <= 3 * Math.PI / 2) return a + Math.PI;else return a;\n  });\n  const source = new ColumnDataSource({\n    data: {\n      labels,\n      values,\n      percentages: normalized_values.map(v => sprintf(\"%.2f%%\", v * 100)),\n      start_angles,\n      end_angles,\n      text_angles,\n      colors,\n      text_colors,\n      text_cx,\n      text_cy\n    }\n  });\n  const g1 = new AnnularWedge({\n    x: cx,\n    y: cy,\n    inner_radius,\n    outer_radius,\n    start_angle: {\n      field: \"start_angles\"\n    },\n    end_angle: {\n      field: \"end_angles\"\n    },\n    line_color: null,\n    line_width: 1,\n    fill_color: {\n      field: \"colors\"\n    }\n  });\n  const h1 = new AnnularWedge({\n    x: cx,\n    y: cy,\n    inner_radius,\n    outer_radius,\n    start_angle: {\n      field: \"start_angles\"\n    },\n    end_angle: {\n      field: \"end_angles\"\n    },\n    line_color: null,\n    line_width: 1,\n    fill_color: {\n      field: \"colors\"\n    },\n    fill_alpha: 0.8\n  });\n  const r1 = new GlyphRenderer({\n    data_source: source,\n    glyph: g1,\n    hover_glyph: h1\n  });\n  const g2 = new Text({\n    x: {\n      field: \"text_cx\"\n    },\n    y: {\n      field: \"text_cy\"\n    },\n    text: {\n      field: opts.slice_labels || \"labels\"\n    },\n    angle: {\n      field: \"text_angles\"\n    },\n    text_align: \"center\",\n    text_baseline: \"middle\",\n    text_color: {\n      field: \"text_colors\"\n    },\n    text_font_size: \"12px\"\n  });\n  const r2 = new GlyphRenderer({\n    data_source: source,\n    glyph: g2\n  });\n  const xdr = new DataRange1d({\n    renderers: [r1],\n    range_padding: 0.2\n  });\n  const ydr = new DataRange1d({\n    renderers: [r1],\n    range_padding: 0.2\n  });\n  const plot = new Plot({\n    x_range: xdr,\n    y_range: ydr\n  });\n  if (opts.width != null) plot.plot_width = opts.width;\n  if (opts.height != null) plot.plot_height = opts.height;\n  plot.add_renderers(r1, r2);\n  const tooltip = \"<div>@labels</div><div><b>@values</b> (@percentages)</div>\";\n  const hover = new HoverTool({\n    renderers: [r1],\n    tooltips: tooltip\n  });\n  plot.add_tools(hover);\n  return plot;\n}\nexport function bar(data, opts = {}) {\n  const column_names = data[0];\n  const row_data = data.slice(1);\n  const col_data = transpose(row_data);\n  const labels = col_data[0].map(v => v.toString());\n  const columns = col_data.slice(1);\n  let yaxis = new CategoricalAxis();\n  let ydr = new FactorRange({\n    factors: labels\n  });\n  let yscale = new CategoricalScale();\n  let xformatter;\n  if (opts.axis_number_format != null) xformatter = new NumeralTickFormatter({\n    format: opts.axis_number_format\n  });else xformatter = new BasicTickFormatter();\n  let xaxis = new LinearAxis({\n    formatter: xformatter\n  });\n  let xdr = new DataRange1d({\n    start: 0\n  });\n  let xscale = new LinearScale();\n  const palette = norm_palette(opts.palette);\n  const stacked = opts.stacked != null ? opts.stacked : false;\n  const orientation = opts.orientation != null ? opts.orientation : \"horizontal\";\n  const renderers = [];\n\n  if (stacked) {\n    const left = [];\n    const right = [];\n\n    for (let i = 0; i < columns.length; i++) {\n      const bottom = [];\n      const top = [];\n\n      for (let j = 0; j < labels.length; j++) {\n        const label = labels[j];\n\n        if (i == 0) {\n          left.push(0);\n          right.push(columns[i][j]);\n        } else {\n          left[j] += columns[i - 1][j];\n          right[j] += columns[i][j];\n        }\n\n        bottom.push([label, -0.5]);\n        top.push([label, 0.5]);\n      }\n\n      const source = new ColumnDataSource({\n        data: {\n          left: copy(left),\n          right: copy(right),\n          top,\n          bottom,\n          labels,\n          values: columns[i],\n          columns: columns[i].map(_ => column_names[i + 1])\n        }\n      });\n      const g1 = new Quad({\n        left: {\n          field: \"left\"\n        },\n        bottom: {\n          field: \"bottom\"\n        },\n        right: {\n          field: \"right\"\n        },\n        top: {\n          field: \"top\"\n        },\n        line_color: null,\n        fill_color: palette[i % palette.length]\n      });\n      const r1 = new GlyphRenderer({\n        data_source: source,\n        glyph: g1\n      });\n      renderers.push(r1);\n    }\n  } else {\n    const dy = 1 / columns.length;\n\n    for (let i = 0; i < columns.length; i++) {\n      const left = [];\n      const right = [];\n      const bottom = [];\n      const top = [];\n\n      for (let j = 0; j < labels.length; j++) {\n        const label = labels[j];\n        left.push(0);\n        right.push(columns[i][j]);\n        bottom.push([label, i * dy - 0.5]);\n        top.push([label, (i + 1) * dy - 0.5]);\n      }\n\n      const source = new ColumnDataSource({\n        data: {\n          left,\n          right,\n          top,\n          bottom,\n          labels,\n          values: columns[i],\n          columns: columns[i].map(_ => column_names[i + 1])\n        }\n      });\n      const g1 = new Quad({\n        left: {\n          field: \"left\"\n        },\n        bottom: {\n          field: \"bottom\"\n        },\n        right: {\n          field: \"right\"\n        },\n        top: {\n          field: \"top\"\n        },\n        line_color: null,\n        fill_color: palette[i % palette.length]\n      });\n      const r1 = new GlyphRenderer({\n        data_source: source,\n        glyph: g1\n      });\n      renderers.push(r1);\n    }\n  }\n\n  if (orientation == \"vertical\") {\n    [xdr, ydr] = [ydr, xdr];\n    [xaxis, yaxis] = [yaxis, xaxis];\n    [xscale, yscale] = [yscale, xscale];\n\n    for (const r of renderers) {\n      const data = r.data_source.data;\n      [data.left, data.bottom] = [data.bottom, data.left];\n      [data.right, data.top] = [data.top, data.right];\n    }\n  }\n\n  const plot = new Plot({\n    x_range: xdr,\n    y_range: ydr,\n    x_scale: xscale,\n    y_scale: yscale\n  });\n  if (opts.width != null) plot.plot_width = opts.width;\n  if (opts.height != null) plot.plot_height = opts.height;\n  plot.add_renderers(...renderers);\n  plot.add_layout(yaxis, \"left\");\n  plot.add_layout(xaxis, \"below\");\n  const tooltip = \"<div>@labels</div><div>@columns:&nbsp<b>@values</b></div>\";\n  let anchor;\n  let attachment;\n\n  if (orientation == \"horizontal\") {\n    anchor = \"center_right\";\n    attachment = \"horizontal\";\n  } else {\n    anchor = \"top_center\";\n    attachment = \"vertical\";\n  }\n\n  const hover = new HoverTool({\n    renderers,\n    tooltips: tooltip,\n    point_policy: \"snap_to_data\",\n    anchor,\n    attachment\n  });\n  plot.add_tools(hover);\n  return plot;\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/api/charts.js"],"names":["palettes","zip","unzip","sum","cumsum","copy","transpose","isArray","sprintf","Plot","ColumnDataSource","GlyphRenderer","HoverTool","AnnularWedge","Quad","Text","DataRange1d","FactorRange","LinearAxis","CategoricalAxis","LinearScale","CategoricalScale","BasicTickFormatter","NumeralTickFormatter","num2hexcolor","num","hexcolor2rgb","color","r","parseInt","substr","g","b","is_dark","l","norm_palette","palette","map","pie","data","opts","labels","values","i","Math","min","length","push","start_angle","end_angle","PI","angle_span","abs","to_radians","x","total_value","normalized_values","v","cumulative_values","end_angles","start_angles","concat","slice","half_angles","start","end","cx","cy","center","y","inner_radius","outer_radius","colors","text_colors","c","to_cartesian","alpha","cos","sin","half_radius","text_cx","text_cy","half_angle","text_angles","a","source","percentages","g1","field","line_color","line_width","fill_color","h1","fill_alpha","r1","data_source","glyph","hover_glyph","g2","text","slice_labels","angle","text_align","text_baseline","text_color","text_font_size","r2","xdr","renderers","range_padding","ydr","plot","x_range","y_range","width","plot_width","height","plot_height","add_renderers","tooltip","hover","tooltips","add_tools","bar","column_names","row_data","col_data","toString","columns","yaxis","factors","yscale","xformatter","axis_number_format","format","xaxis","formatter","xscale","stacked","orientation","left","right","bottom","top","j","label","_","dy","x_scale","y_scale","add_layout","anchor","attachment","point_policy"],"mappings":"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","sourcesContent":["import * as palettes from \"./palettes\";\nimport { zip, unzip, sum, cumsum, copy, transpose } from \"../core/util/array\";\nimport { isArray } from \"../core/util/types\";\nimport { sprintf } from \"../core/util/templating\";\nimport { Plot, ColumnDataSource, GlyphRenderer, HoverTool, AnnularWedge, Quad, Text, DataRange1d, FactorRange, LinearAxis, CategoricalAxis, LinearScale, CategoricalScale, BasicTickFormatter, NumeralTickFormatter, } from \"./models\";\nfunction num2hexcolor(num) {\n    return sprintf(\"#%06x\", num);\n}\nfunction hexcolor2rgb(color) {\n    const r = parseInt(color.substr(1, 2), 16);\n    const g = parseInt(color.substr(3, 2), 16);\n    const b = parseInt(color.substr(5, 2), 16);\n    return [r, g, b];\n}\nfunction is_dark([r, g, b]) {\n    const l = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n    return l >= 0.6;\n}\nfunction norm_palette(palette = \"Spectral11\") {\n    if (isArray(palette))\n        return palette;\n    else {\n        return palettes[palette].map(num2hexcolor);\n    }\n}\nexport function pie(data, opts = {}) {\n    const labels = [];\n    const values = [];\n    for (let i = 0; i < Math.min(data.labels.length, data.values.length); i++) {\n        if (data.values[i] > 0) {\n            labels.push(data.labels[i]);\n            values.push(data.values[i]);\n        }\n    }\n    const start_angle = opts.start_angle != null ? opts.start_angle : 0;\n    const end_angle = opts.end_angle != null ? opts.end_angle : (start_angle + 2 * Math.PI);\n    const angle_span = Math.abs(end_angle - start_angle);\n    const to_radians = (x) => angle_span * x;\n    const total_value = sum(values);\n    const normalized_values = values.map((v) => v / total_value);\n    const cumulative_values = cumsum(normalized_values);\n    const end_angles = cumulative_values.map((v) => start_angle + to_radians(v));\n    const start_angles = [start_angle].concat(end_angles.slice(0, -1));\n    const half_angles = zip(start_angles, end_angles).map(([start, end]) => (start + end) / 2);\n    let cx;\n    let cy;\n    if (opts.center == null) {\n        cx = 0;\n        cy = 0;\n    }\n    else if (isArray(opts.center)) {\n        cx = opts.center[0];\n        cy = opts.center[1];\n    }\n    else {\n        cx = opts.center.x;\n        cy = opts.center.y;\n    }\n    const inner_radius = opts.inner_radius != null ? opts.inner_radius : 0;\n    const outer_radius = opts.outer_radius != null ? opts.outer_radius : 1;\n    const palette = norm_palette(opts.palette);\n    const colors = [];\n    for (let i = 0; i < normalized_values.length; i++)\n        colors.push(palette[i % palette.length]);\n    const text_colors = colors.map((c) => is_dark(hexcolor2rgb(c)) ? \"white\" : \"black\");\n    function to_cartesian(r, alpha) {\n        return [r * Math.cos(alpha), r * Math.sin(alpha)];\n    }\n    const half_radius = (inner_radius + outer_radius) / 2;\n    let [text_cx, text_cy] = unzip(half_angles.map((half_angle) => to_cartesian(half_radius, half_angle)));\n    text_cx = text_cx.map((x) => x + cx);\n    text_cy = text_cy.map((y) => y + cy);\n    const text_angles = half_angles.map((a) => {\n        if (a >= Math.PI / 2 && a <= 3 * Math.PI / 2)\n            return a + Math.PI;\n        else\n            return a;\n    });\n    const source = new ColumnDataSource({\n        data: {\n            labels,\n            values,\n            percentages: normalized_values.map((v) => sprintf(\"%.2f%%\", v * 100)),\n            start_angles,\n            end_angles,\n            text_angles,\n            colors,\n            text_colors,\n            text_cx,\n            text_cy,\n        },\n    });\n    const g1 = new AnnularWedge({\n        x: cx, y: cy,\n        inner_radius, outer_radius,\n        start_angle: { field: \"start_angles\" }, end_angle: { field: \"end_angles\" },\n        line_color: null, line_width: 1, fill_color: { field: \"colors\" },\n    });\n    const h1 = new AnnularWedge({\n        x: cx, y: cy,\n        inner_radius, outer_radius,\n        start_angle: { field: \"start_angles\" }, end_angle: { field: \"end_angles\" },\n        line_color: null, line_width: 1, fill_color: { field: \"colors\" }, fill_alpha: 0.8,\n    });\n    const r1 = new GlyphRenderer({\n        data_source: source,\n        glyph: g1,\n        hover_glyph: h1,\n    });\n    const g2 = new Text({\n        x: { field: \"text_cx\" }, y: { field: \"text_cy\" },\n        text: { field: opts.slice_labels || \"labels\" },\n        angle: { field: \"text_angles\" },\n        text_align: \"center\", text_baseline: \"middle\",\n        text_color: { field: \"text_colors\" }, text_font_size: \"12px\",\n    });\n    const r2 = new GlyphRenderer({\n        data_source: source,\n        glyph: g2,\n    });\n    const xdr = new DataRange1d({ renderers: [r1], range_padding: 0.2 });\n    const ydr = new DataRange1d({ renderers: [r1], range_padding: 0.2 });\n    const plot = new Plot({ x_range: xdr, y_range: ydr });\n    if (opts.width != null)\n        plot.plot_width = opts.width;\n    if (opts.height != null)\n        plot.plot_height = opts.height;\n    plot.add_renderers(r1, r2);\n    const tooltip = \"<div>@labels</div><div><b>@values</b> (@percentages)</div>\";\n    const hover = new HoverTool({ renderers: [r1], tooltips: tooltip });\n    plot.add_tools(hover);\n    return plot;\n}\nexport function bar(data, opts = {}) {\n    const column_names = data[0];\n    const row_data = data.slice(1);\n    const col_data = transpose(row_data);\n    const labels = col_data[0].map((v) => v.toString());\n    const columns = col_data.slice(1);\n    let yaxis = new CategoricalAxis();\n    let ydr = new FactorRange({ factors: labels });\n    let yscale = new CategoricalScale();\n    let xformatter;\n    if (opts.axis_number_format != null)\n        xformatter = new NumeralTickFormatter({ format: opts.axis_number_format });\n    else\n        xformatter = new BasicTickFormatter();\n    let xaxis = new LinearAxis({ formatter: xformatter });\n    let xdr = new DataRange1d({ start: 0 });\n    let xscale = new LinearScale();\n    const palette = norm_palette(opts.palette);\n    const stacked = opts.stacked != null ? opts.stacked : false;\n    const orientation = opts.orientation != null ? opts.orientation : \"horizontal\";\n    const renderers = [];\n    if (stacked) {\n        const left = [];\n        const right = [];\n        for (let i = 0; i < columns.length; i++) {\n            const bottom = [];\n            const top = [];\n            for (let j = 0; j < labels.length; j++) {\n                const label = labels[j];\n                if (i == 0) {\n                    left.push(0);\n                    right.push(columns[i][j]);\n                }\n                else {\n                    left[j] += columns[i - 1][j];\n                    right[j] += columns[i][j];\n                }\n                bottom.push([label, -0.5]);\n                top.push([label, 0.5]);\n            }\n            const source = new ColumnDataSource({\n                data: {\n                    left: copy(left),\n                    right: copy(right),\n                    top,\n                    bottom,\n                    labels,\n                    values: columns[i],\n                    columns: columns[i].map((_) => column_names[i + 1]),\n                },\n            });\n            const g1 = new Quad({\n                left: { field: \"left\" }, bottom: { field: \"bottom\" },\n                right: { field: \"right\" }, top: { field: \"top\" },\n                line_color: null, fill_color: palette[i % palette.length],\n            });\n            const r1 = new GlyphRenderer({ data_source: source, glyph: g1 });\n            renderers.push(r1);\n        }\n    }\n    else {\n        const dy = 1 / columns.length;\n        for (let i = 0; i < columns.length; i++) {\n            const left = [];\n            const right = [];\n            const bottom = [];\n            const top = [];\n            for (let j = 0; j < labels.length; j++) {\n                const label = labels[j];\n                left.push(0);\n                right.push(columns[i][j]);\n                bottom.push([label, i * dy - 0.5]);\n                top.push([label, (i + 1) * dy - 0.5]);\n            }\n            const source = new ColumnDataSource({\n                data: {\n                    left,\n                    right,\n                    top,\n                    bottom,\n                    labels,\n                    values: columns[i],\n                    columns: columns[i].map((_) => column_names[i + 1]),\n                },\n            });\n            const g1 = new Quad({\n                left: { field: \"left\" }, bottom: { field: \"bottom\" },\n                right: { field: \"right\" }, top: { field: \"top\" },\n                line_color: null, fill_color: palette[i % palette.length],\n            });\n            const r1 = new GlyphRenderer({ data_source: source, glyph: g1 });\n            renderers.push(r1);\n        }\n    }\n    if (orientation == \"vertical\") {\n        [xdr, ydr] = [ydr, xdr];\n        [xaxis, yaxis] = [yaxis, xaxis];\n        [xscale, yscale] = [yscale, xscale];\n        for (const r of renderers) {\n            const data = r.data_source.data;\n            [data.left, data.bottom] = [data.bottom, data.left];\n            [data.right, data.top] = [data.top, data.right];\n        }\n    }\n    const plot = new Plot({ x_range: xdr, y_range: ydr, x_scale: xscale, y_scale: yscale });\n    if (opts.width != null)\n        plot.plot_width = opts.width;\n    if (opts.height != null)\n        plot.plot_height = opts.height;\n    plot.add_renderers(...renderers);\n    plot.add_layout(yaxis, \"left\");\n    plot.add_layout(xaxis, \"below\");\n    const tooltip = \"<div>@labels</div><div>@columns:&nbsp<b>@values</b></div>\";\n    let anchor;\n    let attachment;\n    if (orientation == \"horizontal\") {\n        anchor = \"center_right\";\n        attachment = \"horizontal\";\n    }\n    else {\n        anchor = \"top_center\";\n        attachment = \"vertical\";\n    }\n    const hover = new HoverTool({\n        renderers,\n        tooltips: tooltip,\n        point_policy: \"snap_to_data\",\n        anchor,\n        attachment,\n    });\n    plot.add_tools(hover);\n    return plot;\n}\n//# sourceMappingURL=charts.js.map"]},"metadata":{},"sourceType":"module"}