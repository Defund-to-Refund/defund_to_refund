{"ast":null,"code":"import { Range } from \"./range\";\nimport * as p from \"../../core/properties\";\nimport { map } from \"../../core/util/arrayable\";\nimport { every, sum } from \"../../core/util/array\";\nimport { isArray, isNumber, isString } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nexport function map_one_level(factors, padding, offset = 0) {\n  const mapping = {};\n\n  for (let i = 0; i < factors.length; i++) {\n    const factor = factors[i];\n    if (factor in mapping) throw new Error(`duplicate factor or subfactor: ${factor}`);else mapping[factor] = {\n      value: 0.5 + i * (1 + padding) + offset\n    };\n  }\n\n  return [mapping, (factors.length - 1) * padding];\n}\nexport function map_two_levels(factors, outer_pad, factor_pad, offset = 0) {\n  const mapping = {};\n  const tops = {};\n  const tops_order = [];\n\n  for (const [f0, f1] of factors) {\n    if (!(f0 in tops)) {\n      tops[f0] = [];\n      tops_order.push(f0);\n    }\n\n    tops[f0].push(f1);\n  }\n\n  let suboffset = offset;\n  let total_subpad = 0;\n\n  for (const f0 of tops_order) {\n    const n = tops[f0].length;\n    const [submap, subpad] = map_one_level(tops[f0], factor_pad, suboffset);\n    total_subpad += subpad;\n    const subtot = sum(tops[f0].map(f1 => submap[f1].value));\n    mapping[f0] = {\n      value: subtot / n,\n      mapping: submap\n    };\n    suboffset += n + outer_pad + subpad;\n  }\n\n  return [mapping, tops_order, (tops_order.length - 1) * outer_pad + total_subpad];\n}\nexport function map_three_levels(factors, outer_pad, inner_pad, factor_pad, offset = 0) {\n  const mapping = {};\n  const tops = {};\n  const tops_order = [];\n\n  for (const [f0, f1, f2] of factors) {\n    if (!(f0 in tops)) {\n      tops[f0] = [];\n      tops_order.push(f0);\n    }\n\n    tops[f0].push([f1, f2]);\n  }\n\n  const mids_order = [];\n  let suboffset = offset;\n  let total_subpad = 0;\n\n  for (const f0 of tops_order) {\n    const n = tops[f0].length;\n    const [submap, submids_order, subpad] = map_two_levels(tops[f0], inner_pad, factor_pad, suboffset);\n\n    for (const f1 of submids_order) mids_order.push([f0, f1]);\n\n    total_subpad += subpad;\n    const subtot = sum(tops[f0].map(([f1]) => submap[f1].value));\n    mapping[f0] = {\n      value: subtot / n,\n      mapping: submap\n    };\n    suboffset += n + outer_pad + subpad;\n  }\n\n  return [mapping, tops_order, mids_order, (tops_order.length - 1) * outer_pad + total_subpad];\n}\nexport class FactorRange extends Range {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_FactorRange() {\n    this.define({\n      factors: [p.Array, []],\n      factor_padding: [p.Number, 0],\n      subgroup_padding: [p.Number, 0.8],\n      group_padding: [p.Number, 1.4],\n      range_padding: [p.Number, 0],\n      range_padding_units: [p.PaddingUnits, \"percent\"],\n      start: [p.Number],\n      end: [p.Number]\n    });\n    this.internal({\n      levels: [p.Number],\n      mids: [p.Array, null],\n      tops: [p.Array, null],\n      tops_groups: [p.Array]\n    });\n  }\n\n  get min() {\n    return this.start;\n  }\n\n  get max() {\n    return this.end;\n  }\n\n  initialize() {\n    super.initialize();\n\n    this._init(true);\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.properties.factors.change, () => this.reset());\n    this.connect(this.properties.factor_padding.change, () => this.reset());\n    this.connect(this.properties.group_padding.change, () => this.reset());\n    this.connect(this.properties.subgroup_padding.change, () => this.reset());\n    this.connect(this.properties.range_padding.change, () => this.reset());\n    this.connect(this.properties.range_padding_units.change, () => this.reset());\n  }\n\n  reset() {\n    this._init(false);\n\n    this.change.emit();\n  }\n\n  _lookup(x) {\n    if (x.length == 1) {\n      const m = this._mapping;\n\n      if (!m.hasOwnProperty(x[0])) {\n        return NaN;\n      }\n\n      return m[x[0]].value;\n    } else if (x.length == 2) {\n      const m = this._mapping;\n\n      if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1])) {\n        return NaN;\n      }\n\n      return m[x[0]].mapping[x[1]].value;\n    } else if (x.length == 3) {\n      const m = this._mapping;\n\n      if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1]) || !m[x[0]].mapping[x[1]].mapping.hasOwnProperty(x[2])) {\n        return NaN;\n      }\n\n      return m[x[0]].mapping[x[1]].mapping[x[2]].value;\n    } else unreachable();\n  } // convert a string factor into a synthetic coordinate\n\n\n  synthetic(x) {\n    if (isNumber(x)) return x;\n    if (isString(x)) return this._lookup([x]);\n    let offset = 0;\n    const off = x[x.length - 1];\n\n    if (isNumber(off)) {\n      offset = off;\n      x = x.slice(0, -1);\n    }\n\n    return this._lookup(x) + offset;\n  } // convert an array of string factors into synthetic coordinates\n\n\n  v_synthetic(xs) {\n    return map(xs, x => this.synthetic(x));\n  }\n\n  _init(silent) {\n    let levels;\n    let inside_padding;\n    this.tops = null;\n    this.mids = null;\n\n    if (every(this.factors, isString)) {\n      levels = 1;\n      [this._mapping, inside_padding] = map_one_level(this.factors, this.factor_padding);\n    } else if (every(this.factors, x => isArray(x) && x.length == 2 && isString(x[0]) && isString(x[1]))) {\n      levels = 2;\n      [this._mapping, this.tops, inside_padding] = map_two_levels(this.factors, this.group_padding, this.factor_padding);\n    } else if (every(this.factors, x => isArray(x) && x.length == 3 && isString(x[0]) && isString(x[1]) && isString(x[2]))) {\n      levels = 3;\n      [this._mapping, this.tops, this.mids, inside_padding] = map_three_levels(this.factors, this.group_padding, this.subgroup_padding, this.factor_padding);\n    } else unreachable();\n\n    let start = 0;\n    let end = this.factors.length + inside_padding;\n\n    if (this.range_padding_units == \"percent\") {\n      const half_span = (end - start) * this.range_padding / 2;\n      start -= half_span;\n      end += half_span;\n    } else {\n      start -= this.range_padding;\n      end += this.range_padding;\n    }\n\n    this.setv({\n      start,\n      end,\n      levels\n    }, {\n      silent\n    });\n    if (this.bounds == \"auto\") this.setv({\n      bounds: [start, end]\n    }, {\n      silent: true\n    });\n  }\n\n}\nFactorRange.__name__ = \"FactorRange\";\nFactorRange.init_FactorRange();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/factor_range.js"],"names":["Range","p","map","every","sum","isArray","isNumber","isString","unreachable","map_one_level","factors","padding","offset","mapping","i","length","factor","Error","value","map_two_levels","outer_pad","factor_pad","tops","tops_order","f0","f1","push","suboffset","total_subpad","n","submap","subpad","subtot","map_three_levels","inner_pad","f2","mids_order","submids_order","FactorRange","constructor","attrs","init_FactorRange","define","Array","factor_padding","Number","subgroup_padding","group_padding","range_padding","range_padding_units","PaddingUnits","start","end","internal","levels","mids","tops_groups","min","max","initialize","_init","connect_signals","connect","properties","change","reset","emit","_lookup","x","m","_mapping","hasOwnProperty","NaN","synthetic","off","slice","v_synthetic","xs","silent","inside_padding","half_span","setv","bounds","__name__"],"mappings":"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","sourcesContent":["import { Range } from \"./range\";\nimport * as p from \"../../core/properties\";\nimport { map } from \"../../core/util/arrayable\";\nimport { every, sum } from \"../../core/util/array\";\nimport { isArray, isNumber, isString } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nexport function map_one_level(factors, padding, offset = 0) {\n    const mapping = {};\n    for (let i = 0; i < factors.length; i++) {\n        const factor = factors[i];\n        if (factor in mapping)\n            throw new Error(`duplicate factor or subfactor: ${factor}`);\n        else\n            mapping[factor] = { value: 0.5 + i * (1 + padding) + offset };\n    }\n    return [mapping, (factors.length - 1) * padding];\n}\nexport function map_two_levels(factors, outer_pad, factor_pad, offset = 0) {\n    const mapping = {};\n    const tops = {};\n    const tops_order = [];\n    for (const [f0, f1] of factors) {\n        if (!(f0 in tops)) {\n            tops[f0] = [];\n            tops_order.push(f0);\n        }\n        tops[f0].push(f1);\n    }\n    let suboffset = offset;\n    let total_subpad = 0;\n    for (const f0 of tops_order) {\n        const n = tops[f0].length;\n        const [submap, subpad] = map_one_level(tops[f0], factor_pad, suboffset);\n        total_subpad += subpad;\n        const subtot = sum(tops[f0].map((f1) => submap[f1].value));\n        mapping[f0] = { value: subtot / n, mapping: submap };\n        suboffset += n + outer_pad + subpad;\n    }\n    return [mapping, tops_order, (tops_order.length - 1) * outer_pad + total_subpad];\n}\nexport function map_three_levels(factors, outer_pad, inner_pad, factor_pad, offset = 0) {\n    const mapping = {};\n    const tops = {};\n    const tops_order = [];\n    for (const [f0, f1, f2] of factors) {\n        if (!(f0 in tops)) {\n            tops[f0] = [];\n            tops_order.push(f0);\n        }\n        tops[f0].push([f1, f2]);\n    }\n    const mids_order = [];\n    let suboffset = offset;\n    let total_subpad = 0;\n    for (const f0 of tops_order) {\n        const n = tops[f0].length;\n        const [submap, submids_order, subpad] = map_two_levels(tops[f0], inner_pad, factor_pad, suboffset);\n        for (const f1 of submids_order)\n            mids_order.push([f0, f1]);\n        total_subpad += subpad;\n        const subtot = sum(tops[f0].map(([f1]) => submap[f1].value));\n        mapping[f0] = { value: subtot / n, mapping: submap };\n        suboffset += n + outer_pad + subpad;\n    }\n    return [mapping, tops_order, mids_order, (tops_order.length - 1) * outer_pad + total_subpad];\n}\nexport class FactorRange extends Range {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_FactorRange() {\n        this.define({\n            factors: [p.Array, []],\n            factor_padding: [p.Number, 0],\n            subgroup_padding: [p.Number, 0.8],\n            group_padding: [p.Number, 1.4],\n            range_padding: [p.Number, 0],\n            range_padding_units: [p.PaddingUnits, \"percent\"],\n            start: [p.Number],\n            end: [p.Number],\n        });\n        this.internal({\n            levels: [p.Number],\n            mids: [p.Array, null],\n            tops: [p.Array, null],\n            tops_groups: [p.Array],\n        });\n    }\n    get min() {\n        return this.start;\n    }\n    get max() {\n        return this.end;\n    }\n    initialize() {\n        super.initialize();\n        this._init(true);\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.properties.factors.change, () => this.reset());\n        this.connect(this.properties.factor_padding.change, () => this.reset());\n        this.connect(this.properties.group_padding.change, () => this.reset());\n        this.connect(this.properties.subgroup_padding.change, () => this.reset());\n        this.connect(this.properties.range_padding.change, () => this.reset());\n        this.connect(this.properties.range_padding_units.change, () => this.reset());\n    }\n    reset() {\n        this._init(false);\n        this.change.emit();\n    }\n    _lookup(x) {\n        if (x.length == 1) {\n            const m = this._mapping;\n            if (!m.hasOwnProperty(x[0])) {\n                return NaN;\n            }\n            return m[x[0]].value;\n        }\n        else if (x.length == 2) {\n            const m = this._mapping;\n            if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1])) {\n                return NaN;\n            }\n            return m[x[0]].mapping[x[1]].value;\n        }\n        else if (x.length == 3) {\n            const m = this._mapping;\n            if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1]) || !m[x[0]].mapping[x[1]].mapping.hasOwnProperty(x[2])) {\n                return NaN;\n            }\n            return m[x[0]].mapping[x[1]].mapping[x[2]].value;\n        }\n        else\n            unreachable();\n    }\n    // convert a string factor into a synthetic coordinate\n    synthetic(x) {\n        if (isNumber(x))\n            return x;\n        if (isString(x))\n            return this._lookup([x]);\n        let offset = 0;\n        const off = x[x.length - 1];\n        if (isNumber(off)) {\n            offset = off;\n            x = x.slice(0, -1);\n        }\n        return this._lookup(x) + offset;\n    }\n    // convert an array of string factors into synthetic coordinates\n    v_synthetic(xs) {\n        return map(xs, (x) => this.synthetic(x));\n    }\n    _init(silent) {\n        let levels;\n        let inside_padding;\n        this.tops = null;\n        this.mids = null;\n        if (every(this.factors, isString)) {\n            levels = 1;\n            [this._mapping, inside_padding] = map_one_level(this.factors, this.factor_padding);\n        }\n        else if (every(this.factors, (x) => isArray(x) && x.length == 2 && isString(x[0]) && isString(x[1]))) {\n            levels = 2;\n            [this._mapping, this.tops, inside_padding] = map_two_levels(this.factors, this.group_padding, this.factor_padding);\n        }\n        else if (every(this.factors, (x) => isArray(x) && x.length == 3 && isString(x[0]) && isString(x[1]) && isString(x[2]))) {\n            levels = 3;\n            [this._mapping, this.tops, this.mids, inside_padding] = map_three_levels(this.factors, this.group_padding, this.subgroup_padding, this.factor_padding);\n        }\n        else\n            unreachable();\n        let start = 0;\n        let end = this.factors.length + inside_padding;\n        if (this.range_padding_units == \"percent\") {\n            const half_span = (end - start) * this.range_padding / 2;\n            start -= half_span;\n            end += half_span;\n        }\n        else {\n            start -= this.range_padding;\n            end += this.range_padding;\n        }\n        this.setv({ start, end, levels }, { silent });\n        if (this.bounds == \"auto\")\n            this.setv({ bounds: [start, end] }, { silent: true });\n    }\n}\nFactorRange.__name__ = \"FactorRange\";\nFactorRange.init_FactorRange();\n//# sourceMappingURL=factor_range.js.map"]},"metadata":{},"sourceType":"module"}