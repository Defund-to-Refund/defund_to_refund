{"ast":null,"code":"import { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport { min, max, copy, find_last_index } from \"../../core/util/array\";\nimport { sum } from \"../../core/util/arrayable\";\nimport { isStrictNaN } from \"../../core/util/types\";\nimport * as hittest from \"../../core/hittest\";\nimport { unreachable } from \"../../core/util/assert\";\nexport class PatchesView extends GlyphView {\n  _build_discontinuous_object(nanned_qs) {\n    // _s is this.xs, this.ys, this.sxs, this.sys\n    // an object of n 1-d arrays in either data or screen units\n    //\n    // Each 1-d array gets broken to an array of arrays split\n    // on any NaNs\n    //\n    // So:\n    // { 0: [x11, x12],\n    //   1: [x21, x22, x23],\n    //   2: [x31, NaN, x32]\n    // }\n    // becomes\n    // { 0: [[x11, x12]],\n    //   1: [[x21, x22, x23]],\n    //   2: [[x31],[x32]]\n    // }\n    const ds = [];\n\n    for (let i = 0, end = nanned_qs.length; i < end; i++) {\n      ds[i] = [];\n      let qs = copy(nanned_qs[i]);\n\n      while (qs.length > 0) {\n        const nan_index = find_last_index(qs, q => isStrictNaN(q));\n        let qs_part;\n        if (nan_index >= 0) qs_part = qs.splice(nan_index);else {\n          qs_part = qs;\n          qs = [];\n        }\n        const denanned = qs_part.filter(q => !isStrictNaN(q));\n        ds[i].push(denanned);\n      }\n    }\n\n    return ds;\n  }\n\n  _index_data() {\n    const xss = this._build_discontinuous_object(this._xs); // XXX\n\n\n    const yss = this._build_discontinuous_object(this._ys); // XXX\n\n\n    const points = [];\n\n    for (let i = 0, end = this._xs.length; i < end; i++) {\n      for (let j = 0, endj = xss[i].length; j < endj; j++) {\n        const xs = xss[i][j];\n        const ys = yss[i][j];\n        if (xs.length == 0) continue;\n        points.push({\n          x0: min(xs),\n          y0: min(ys),\n          x1: max(xs),\n          y1: max(ys),\n          i\n        });\n      }\n    }\n\n    return new SpatialIndex(points);\n  }\n\n  _mask_data() {\n    const xr = this.renderer.plot_view.frame.x_ranges.default;\n    const [x0, x1] = [xr.min, xr.max];\n    const yr = this.renderer.plot_view.frame.y_ranges.default;\n    const [y0, y1] = [yr.min, yr.max];\n    const indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    }); // TODO (bev) this should be under test\n\n    return indices.sort((a, b) => a - b);\n  }\n\n  _inner_loop(ctx, sx, sy, func) {\n    for (let j = 0, end = sx.length; j < end; j++) {\n      if (j == 0) {\n        ctx.beginPath();\n        ctx.moveTo(sx[j], sy[j]);\n        continue;\n      } else if (isNaN(sx[j] + sy[j])) {\n        ctx.closePath();\n        func.apply(ctx);\n        ctx.beginPath();\n        continue;\n      } else ctx.lineTo(sx[j], sy[j]);\n    }\n\n    ctx.closePath();\n    func.call(ctx);\n  }\n\n  _render(ctx, indices, {\n    sxs,\n    sys\n  }) {\n    // this.sxss and this.syss are used by _hit_point and sxc, syc\n    // This is the earliest we can build them, and only build them once\n    this.sxss = this._build_discontinuous_object(sxs); // XXX\n\n    this.syss = this._build_discontinuous_object(sys); // XXX\n\n    for (const i of indices) {\n      const [sx, sy] = [sxs[i], sys[i]];\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n\n        this._inner_loop(ctx, sx, sy, ctx.fill);\n      }\n\n      this.visuals.hatch.doit2(ctx, i, () => this._inner_loop(ctx, sx, sy, ctx.fill), () => this.renderer.request_render());\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n\n        this._inner_loop(ctx, sx, sy, ctx.stroke);\n      }\n    }\n  }\n\n  _hit_rect(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const xs = [sx0, sx1, sx1, sx0];\n    const ys = [sy0, sy0, sy1, sy1];\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const candidates = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n      const sxss = this.sxs[idx];\n      const syss = this.sys[idx];\n      let hit = true;\n\n      for (let j = 0, endj = sxss.length; j < endj; j++) {\n        const sx = sxss[j];\n        const sy = syss[j];\n\n        if (!hittest.point_in_poly(sx, sy, xs, ys)) {\n          hit = false;\n          break;\n        }\n      }\n\n      if (hit) hits.push(idx);\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy);\n    const candidates = this.index.indices({\n      x0: x,\n      y0: y,\n      x1: x,\n      y1: y\n    });\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n      const sxs = this.sxss[idx];\n      const sys = this.syss[idx];\n\n      for (let j = 0, endj = sxs.length; j < endj; j++) {\n        if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n          hits.push(idx);\n        }\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _get_snap_coord(array) {\n    return sum(array) / array.length;\n  }\n\n  scenterx(i, sx, sy) {\n    if (this.sxss[i].length == 1) {\n      // We don't have discontinuous objects so we're ok\n      return this._get_snap_coord(this.sxs[i]);\n    } else {\n      // We have discontinuous objects, so we need to find which\n      // one we're in, we can use point_in_poly again\n      const sxs = this.sxss[i];\n      const sys = this.syss[i];\n\n      for (let j = 0, end = sxs.length; j < end; j++) {\n        if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) return this._get_snap_coord(sxs[j]);\n      }\n    }\n\n    unreachable();\n  }\n\n  scentery(i, sx, sy) {\n    if (this.syss[i].length == 1) {\n      // We don't have discontinuous objects so we're ok\n      return this._get_snap_coord(this.sys[i]);\n    } else {\n      // We have discontinuous objects, so we need to find which\n      // one we're in, we can use point_in_poly again\n      const sxs = this.sxss[i];\n      const sys = this.syss[i];\n\n      for (let j = 0, end = sxs.length; j < end; j++) {\n        if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) return this._get_snap_coord(sys[j]);\n      }\n    }\n\n    unreachable();\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_area_legend(this.visuals, ctx, bbox, index);\n  }\n\n}\nPatchesView.__name__ = \"PatchesView\";\nexport class Patches extends Glyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Patches() {\n    this.prototype.default_view = PatchesView;\n    this.coords([['xs', 'ys']]);\n    this.mixins(['line', 'fill', 'hatch']);\n  }\n\n}\nPatches.__name__ = \"Patches\";\nPatches.init_Patches();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/patches.js"],"names":["SpatialIndex","Glyph","GlyphView","generic_area_legend","min","max","copy","find_last_index","sum","isStrictNaN","hittest","unreachable","PatchesView","_build_discontinuous_object","nanned_qs","ds","i","end","length","qs","nan_index","q","qs_part","splice","denanned","filter","push","_index_data","xss","_xs","yss","_ys","points","j","endj","xs","ys","x0","y0","x1","y1","_mask_data","xr","renderer","plot_view","frame","x_ranges","default","yr","y_ranges","indices","index","sort","a","b","_inner_loop","ctx","sx","sy","func","beginPath","moveTo","isNaN","closePath","apply","lineTo","call","_render","sxs","sys","sxss","syss","visuals","fill","doit","set_vectorize","hatch","doit2","request_render","line","stroke","_hit_rect","geometry","sx0","sx1","sy0","sy1","xscale","r_invert","yscale","candidates","hits","idx","hit","point_in_poly","result","create_empty_hit_test_result","_hit_point","x","invert","y","_get_snap_coord","array","scenterx","scentery","draw_legend_for_index","bbox","__name__","Patches","constructor","attrs","init_Patches","prototype","default_view","coords","mixins"],"mappings":"AAAA,SAASA,YAAT,QAA6B,yBAA7B;AACA,SAASC,KAAT,EAAgBC,SAAhB,QAAiC,SAAjC;AACA,SAASC,mBAAT,QAAoC,SAApC;AACA,SAASC,GAAT,EAAcC,GAAd,EAAmBC,IAAnB,EAAyBC,eAAzB,QAAgD,uBAAhD;AACA,SAASC,GAAT,QAAoB,2BAApB;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,OAAO,KAAKC,OAAZ,MAAyB,oBAAzB;AACA,SAASC,WAAT,QAA4B,wBAA5B;AACA,OAAO,MAAMC,WAAN,SAA0BV,SAA1B,CAAoC;AACvCW,EAAAA,2BAA2B,CAACC,SAAD,EAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,EAAE,GAAG,EAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGH,SAAS,CAACI,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AAClDD,MAAAA,EAAE,CAACC,CAAD,CAAF,GAAQ,EAAR;AACA,UAAIG,EAAE,GAAGb,IAAI,CAACQ,SAAS,CAACE,CAAD,CAAV,CAAb;;AACA,aAAOG,EAAE,CAACD,MAAH,GAAY,CAAnB,EAAsB;AAClB,cAAME,SAAS,GAAGb,eAAe,CAACY,EAAD,EAAME,CAAD,IAAOZ,WAAW,CAACY,CAAD,CAAvB,CAAjC;AACA,YAAIC,OAAJ;AACA,YAAIF,SAAS,IAAI,CAAjB,EACIE,OAAO,GAAGH,EAAE,CAACI,MAAH,CAAUH,SAAV,CAAV,CADJ,KAEK;AACDE,UAAAA,OAAO,GAAGH,EAAV;AACAA,UAAAA,EAAE,GAAG,EAAL;AACH;AACD,cAAMK,QAAQ,GAAGF,OAAO,CAACG,MAAR,CAAgBJ,CAAD,IAAO,CAACZ,WAAW,CAACY,CAAD,CAAlC,CAAjB;AACAN,QAAAA,EAAE,CAACC,CAAD,CAAF,CAAMU,IAAN,CAAWF,QAAX;AACH;AACJ;;AACD,WAAOT,EAAP;AACH;;AACDY,EAAAA,WAAW,GAAG;AACV,UAAMC,GAAG,GAAG,KAAKf,2BAAL,CAAiC,KAAKgB,GAAtC,CAAZ,CADU,CAC8C;;;AACxD,UAAMC,GAAG,GAAG,KAAKjB,2BAAL,CAAiC,KAAKkB,GAAtC,CAAZ,CAFU,CAE8C;;;AACxD,UAAMC,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIhB,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG,KAAKY,GAAL,CAASX,MAA/B,EAAuCF,CAAC,GAAGC,GAA3C,EAAgDD,CAAC,EAAjD,EAAqD;AACjD,WAAK,IAAIiB,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGN,GAAG,CAACZ,CAAD,CAAH,CAAOE,MAA9B,EAAsCe,CAAC,GAAGC,IAA1C,EAAgDD,CAAC,EAAjD,EAAqD;AACjD,cAAME,EAAE,GAAGP,GAAG,CAACZ,CAAD,CAAH,CAAOiB,CAAP,CAAX;AACA,cAAMG,EAAE,GAAGN,GAAG,CAACd,CAAD,CAAH,CAAOiB,CAAP,CAAX;AACA,YAAIE,EAAE,CAACjB,MAAH,IAAa,CAAjB,EACI;AACJc,QAAAA,MAAM,CAACN,IAAP,CAAY;AAAEW,UAAAA,EAAE,EAAEjC,GAAG,CAAC+B,EAAD,CAAT;AAAeG,UAAAA,EAAE,EAAElC,GAAG,CAACgC,EAAD,CAAtB;AAA4BG,UAAAA,EAAE,EAAElC,GAAG,CAAC8B,EAAD,CAAnC;AAAyCK,UAAAA,EAAE,EAAEnC,GAAG,CAAC+B,EAAD,CAAhD;AAAsDpB,UAAAA;AAAtD,SAAZ;AACH;AACJ;;AACD,WAAO,IAAIhB,YAAJ,CAAiBgC,MAAjB,CAAP;AACH;;AACDS,EAAAA,UAAU,GAAG;AACT,UAAMC,EAAE,GAAG,KAAKC,QAAL,CAAcC,SAAd,CAAwBC,KAAxB,CAA8BC,QAA9B,CAAuCC,OAAlD;AACA,UAAM,CAACV,EAAD,EAAKE,EAAL,IAAW,CAACG,EAAE,CAACtC,GAAJ,EAASsC,EAAE,CAACrC,GAAZ,CAAjB;AACA,UAAM2C,EAAE,GAAG,KAAKL,QAAL,CAAcC,SAAd,CAAwBC,KAAxB,CAA8BI,QAA9B,CAAuCF,OAAlD;AACA,UAAM,CAACT,EAAD,EAAKE,EAAL,IAAW,CAACQ,EAAE,CAAC5C,GAAJ,EAAS4C,EAAE,CAAC3C,GAAZ,CAAjB;AACA,UAAM6C,OAAO,GAAG,KAAKC,KAAL,CAAWD,OAAX,CAAmB;AAAEb,MAAAA,EAAF;AAAME,MAAAA,EAAN;AAAUD,MAAAA,EAAV;AAAcE,MAAAA;AAAd,KAAnB,CAAhB,CALS,CAMT;;AACA,WAAOU,OAAO,CAACE,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAA3B,CAAP;AACH;;AACDC,EAAAA,WAAW,CAACC,GAAD,EAAMC,EAAN,EAAUC,EAAV,EAAcC,IAAd,EAAoB;AAC3B,SAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWhB,GAAG,GAAGwC,EAAE,CAACvC,MAAzB,EAAiCe,CAAC,GAAGhB,GAArC,EAA0CgB,CAAC,EAA3C,EAA+C;AAC3C,UAAIA,CAAC,IAAI,CAAT,EAAY;AACRuB,QAAAA,GAAG,CAACI,SAAJ;AACAJ,QAAAA,GAAG,CAACK,MAAJ,CAAWJ,EAAE,CAACxB,CAAD,CAAb,EAAkByB,EAAE,CAACzB,CAAD,CAApB;AACA;AACH,OAJD,MAKK,IAAI6B,KAAK,CAACL,EAAE,CAACxB,CAAD,CAAF,GAAQyB,EAAE,CAACzB,CAAD,CAAX,CAAT,EAA0B;AAC3BuB,QAAAA,GAAG,CAACO,SAAJ;AACAJ,QAAAA,IAAI,CAACK,KAAL,CAAWR,GAAX;AACAA,QAAAA,GAAG,CAACI,SAAJ;AACA;AACH,OALI,MAODJ,GAAG,CAACS,MAAJ,CAAWR,EAAE,CAACxB,CAAD,CAAb,EAAkByB,EAAE,CAACzB,CAAD,CAApB;AACP;;AACDuB,IAAAA,GAAG,CAACO,SAAJ;AACAJ,IAAAA,IAAI,CAACO,IAAL,CAAUV,GAAV;AACH;;AACDW,EAAAA,OAAO,CAACX,GAAD,EAAMN,OAAN,EAAe;AAAEkB,IAAAA,GAAF;AAAOC,IAAAA;AAAP,GAAf,EAA6B;AAChC;AACA;AACA,SAAKC,IAAL,GAAY,KAAKzD,2BAAL,CAAiCuD,GAAjC,CAAZ,CAHgC,CAGmB;;AACnD,SAAKG,IAAL,GAAY,KAAK1D,2BAAL,CAAiCwD,GAAjC,CAAZ,CAJgC,CAImB;;AACnD,SAAK,MAAMrD,CAAX,IAAgBkC,OAAhB,EAAyB;AACrB,YAAM,CAACO,EAAD,EAAKC,EAAL,IAAW,CAACU,GAAG,CAACpD,CAAD,CAAJ,EAASqD,GAAG,CAACrD,CAAD,CAAZ,CAAjB;;AACA,UAAI,KAAKwD,OAAL,CAAaC,IAAb,CAAkBC,IAAtB,EAA4B;AACxB,aAAKF,OAAL,CAAaC,IAAb,CAAkBE,aAAlB,CAAgCnB,GAAhC,EAAqCxC,CAArC;;AACA,aAAKuC,WAAL,CAAiBC,GAAjB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BF,GAAG,CAACiB,IAAlC;AACH;;AACD,WAAKD,OAAL,CAAaI,KAAb,CAAmBC,KAAnB,CAAyBrB,GAAzB,EAA8BxC,CAA9B,EAAiC,MAAM,KAAKuC,WAAL,CAAiBC,GAAjB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BF,GAAG,CAACiB,IAAlC,CAAvC,EAAgF,MAAM,KAAK9B,QAAL,CAAcmC,cAAd,EAAtF;;AACA,UAAI,KAAKN,OAAL,CAAaO,IAAb,CAAkBL,IAAtB,EAA4B;AACxB,aAAKF,OAAL,CAAaO,IAAb,CAAkBJ,aAAlB,CAAgCnB,GAAhC,EAAqCxC,CAArC;;AACA,aAAKuC,WAAL,CAAiBC,GAAjB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BF,GAAG,CAACwB,MAAlC;AACH;AACJ;AACJ;;AACDC,EAAAA,SAAS,CAACC,QAAD,EAAW;AAChB,UAAM;AAAEC,MAAAA,GAAF;AAAOC,MAAAA,GAAP;AAAYC,MAAAA,GAAZ;AAAiBC,MAAAA;AAAjB,QAAyBJ,QAA/B;AACA,UAAM/C,EAAE,GAAG,CAACgD,GAAD,EAAMC,GAAN,EAAWA,GAAX,EAAgBD,GAAhB,CAAX;AACA,UAAM/C,EAAE,GAAG,CAACiD,GAAD,EAAMA,GAAN,EAAWC,GAAX,EAAgBA,GAAhB,CAAX;AACA,UAAM,CAACjD,EAAD,EAAKE,EAAL,IAAW,KAAKI,QAAL,CAAc4C,MAAd,CAAqBC,QAArB,CAA8BL,GAA9B,EAAmCC,GAAnC,CAAjB;AACA,UAAM,CAAC9C,EAAD,EAAKE,EAAL,IAAW,KAAKG,QAAL,CAAc8C,MAAd,CAAqBD,QAArB,CAA8BH,GAA9B,EAAmCC,GAAnC,CAAjB;AACA,UAAMI,UAAU,GAAG,KAAKvC,KAAL,CAAWD,OAAX,CAAmB;AAAEb,MAAAA,EAAF;AAAME,MAAAA,EAAN;AAAUD,MAAAA,EAAV;AAAcE,MAAAA;AAAd,KAAnB,CAAnB;AACA,UAAMmD,IAAI,GAAG,EAAb;;AACA,SAAK,IAAI3E,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGyE,UAAU,CAACxE,MAAjC,EAAyCF,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnD,YAAM4E,GAAG,GAAGF,UAAU,CAAC1E,CAAD,CAAtB;AACA,YAAMsD,IAAI,GAAG,KAAKF,GAAL,CAASwB,GAAT,CAAb;AACA,YAAMrB,IAAI,GAAG,KAAKF,GAAL,CAASuB,GAAT,CAAb;AACA,UAAIC,GAAG,GAAG,IAAV;;AACA,WAAK,IAAI5D,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGoC,IAAI,CAACpD,MAA5B,EAAoCe,CAAC,GAAGC,IAAxC,EAA8CD,CAAC,EAA/C,EAAmD;AAC/C,cAAMwB,EAAE,GAAGa,IAAI,CAACrC,CAAD,CAAf;AACA,cAAMyB,EAAE,GAAGa,IAAI,CAACtC,CAAD,CAAf;;AACA,YAAI,CAACvB,OAAO,CAACoF,aAAR,CAAsBrC,EAAtB,EAA0BC,EAA1B,EAA8BvB,EAA9B,EAAkCC,EAAlC,CAAL,EAA4C;AACxCyD,UAAAA,GAAG,GAAG,KAAN;AACA;AACH;AACJ;;AACD,UAAIA,GAAJ,EACIF,IAAI,CAACjE,IAAL,CAAUkE,GAAV;AACP;;AACD,UAAMG,MAAM,GAAGrF,OAAO,CAACsF,4BAAR,EAAf;AACAD,IAAAA,MAAM,CAAC7C,OAAP,GAAiByC,IAAjB;AACA,WAAOI,MAAP;AACH;;AACDE,EAAAA,UAAU,CAACf,QAAD,EAAW;AACjB,UAAM;AAAEzB,MAAAA,EAAF;AAAMC,MAAAA;AAAN,QAAawB,QAAnB;AACA,UAAMgB,CAAC,GAAG,KAAKvD,QAAL,CAAc4C,MAAd,CAAqBY,MAArB,CAA4B1C,EAA5B,CAAV;AACA,UAAM2C,CAAC,GAAG,KAAKzD,QAAL,CAAc8C,MAAd,CAAqBU,MAArB,CAA4BzC,EAA5B,CAAV;AACA,UAAMgC,UAAU,GAAG,KAAKvC,KAAL,CAAWD,OAAX,CAAmB;AAAEb,MAAAA,EAAE,EAAE6D,CAAN;AAAS5D,MAAAA,EAAE,EAAE8D,CAAb;AAAgB7D,MAAAA,EAAE,EAAE2D,CAApB;AAAuB1D,MAAAA,EAAE,EAAE4D;AAA3B,KAAnB,CAAnB;AACA,UAAMT,IAAI,GAAG,EAAb;;AACA,SAAK,IAAI3E,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGyE,UAAU,CAACxE,MAAjC,EAAyCF,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnD,YAAM4E,GAAG,GAAGF,UAAU,CAAC1E,CAAD,CAAtB;AACA,YAAMoD,GAAG,GAAG,KAAKE,IAAL,CAAUsB,GAAV,CAAZ;AACA,YAAMvB,GAAG,GAAG,KAAKE,IAAL,CAAUqB,GAAV,CAAZ;;AACA,WAAK,IAAI3D,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGkC,GAAG,CAAClD,MAA3B,EAAmCe,CAAC,GAAGC,IAAvC,EAA6CD,CAAC,EAA9C,EAAkD;AAC9C,YAAIvB,OAAO,CAACoF,aAAR,CAAsBrC,EAAtB,EAA0BC,EAA1B,EAA8BU,GAAG,CAACnC,CAAD,CAAjC,EAAsCoC,GAAG,CAACpC,CAAD,CAAzC,CAAJ,EAAmD;AAC/C0D,UAAAA,IAAI,CAACjE,IAAL,CAAUkE,GAAV;AACH;AACJ;AACJ;;AACD,UAAMG,MAAM,GAAGrF,OAAO,CAACsF,4BAAR,EAAf;AACAD,IAAAA,MAAM,CAAC7C,OAAP,GAAiByC,IAAjB;AACA,WAAOI,MAAP;AACH;;AACDM,EAAAA,eAAe,CAACC,KAAD,EAAQ;AACnB,WAAO9F,GAAG,CAAC8F,KAAD,CAAH,GAAaA,KAAK,CAACpF,MAA1B;AACH;;AACDqF,EAAAA,QAAQ,CAACvF,CAAD,EAAIyC,EAAJ,EAAQC,EAAR,EAAY;AAChB,QAAI,KAAKY,IAAL,CAAUtD,CAAV,EAAaE,MAAb,IAAuB,CAA3B,EAA8B;AAC1B;AACA,aAAO,KAAKmF,eAAL,CAAqB,KAAKjC,GAAL,CAASpD,CAAT,CAArB,CAAP;AACH,KAHD,MAIK;AACD;AACA;AACA,YAAMoD,GAAG,GAAG,KAAKE,IAAL,CAAUtD,CAAV,CAAZ;AACA,YAAMqD,GAAG,GAAG,KAAKE,IAAL,CAAUvD,CAAV,CAAZ;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAR,EAAWhB,GAAG,GAAGmD,GAAG,CAAClD,MAA1B,EAAkCe,CAAC,GAAGhB,GAAtC,EAA2CgB,CAAC,EAA5C,EAAgD;AAC5C,YAAIvB,OAAO,CAACoF,aAAR,CAAsBrC,EAAtB,EAA0BC,EAA1B,EAA8BU,GAAG,CAACnC,CAAD,CAAjC,EAAsCoC,GAAG,CAACpC,CAAD,CAAzC,CAAJ,EACI,OAAO,KAAKoE,eAAL,CAAqBjC,GAAG,CAACnC,CAAD,CAAxB,CAAP;AACP;AACJ;;AACDtB,IAAAA,WAAW;AACd;;AACD6F,EAAAA,QAAQ,CAACxF,CAAD,EAAIyC,EAAJ,EAAQC,EAAR,EAAY;AAChB,QAAI,KAAKa,IAAL,CAAUvD,CAAV,EAAaE,MAAb,IAAuB,CAA3B,EAA8B;AAC1B;AACA,aAAO,KAAKmF,eAAL,CAAqB,KAAKhC,GAAL,CAASrD,CAAT,CAArB,CAAP;AACH,KAHD,MAIK;AACD;AACA;AACA,YAAMoD,GAAG,GAAG,KAAKE,IAAL,CAAUtD,CAAV,CAAZ;AACA,YAAMqD,GAAG,GAAG,KAAKE,IAAL,CAAUvD,CAAV,CAAZ;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAR,EAAWhB,GAAG,GAAGmD,GAAG,CAAClD,MAA1B,EAAkCe,CAAC,GAAGhB,GAAtC,EAA2CgB,CAAC,EAA5C,EAAgD;AAC5C,YAAIvB,OAAO,CAACoF,aAAR,CAAsBrC,EAAtB,EAA0BC,EAA1B,EAA8BU,GAAG,CAACnC,CAAD,CAAjC,EAAsCoC,GAAG,CAACpC,CAAD,CAAzC,CAAJ,EACI,OAAO,KAAKoE,eAAL,CAAqBhC,GAAG,CAACpC,CAAD,CAAxB,CAAP;AACP;AACJ;;AACDtB,IAAAA,WAAW;AACd;;AACD8F,EAAAA,qBAAqB,CAACjD,GAAD,EAAMkD,IAAN,EAAYvD,KAAZ,EAAmB;AACpChD,IAAAA,mBAAmB,CAAC,KAAKqE,OAAN,EAAehB,GAAf,EAAoBkD,IAApB,EAA0BvD,KAA1B,CAAnB;AACH;;AAzLsC;AA2L3CvC,WAAW,CAAC+F,QAAZ,GAAuB,aAAvB;AACA,OAAO,MAAMC,OAAN,SAAsB3G,KAAtB,CAA4B;AAC/B4G,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,YAAP,GAAsB;AAClB,SAAKC,SAAL,CAAeC,YAAf,GAA8BrG,WAA9B;AACA,SAAKsG,MAAL,CAAY,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,CAAZ;AACA,SAAKC,MAAL,CAAY,CAAC,MAAD,EAAS,MAAT,EAAiB,OAAjB,CAAZ;AACH;;AAR8B;AAUnCP,OAAO,CAACD,QAAR,GAAmB,SAAnB;AACAC,OAAO,CAACG,YAAR","sourcesContent":["import { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport { min, max, copy, find_last_index } from \"../../core/util/array\";\nimport { sum } from \"../../core/util/arrayable\";\nimport { isStrictNaN } from \"../../core/util/types\";\nimport * as hittest from \"../../core/hittest\";\nimport { unreachable } from \"../../core/util/assert\";\nexport class PatchesView extends GlyphView {\n    _build_discontinuous_object(nanned_qs) {\n        // _s is this.xs, this.ys, this.sxs, this.sys\n        // an object of n 1-d arrays in either data or screen units\n        //\n        // Each 1-d array gets broken to an array of arrays split\n        // on any NaNs\n        //\n        // So:\n        // { 0: [x11, x12],\n        //   1: [x21, x22, x23],\n        //   2: [x31, NaN, x32]\n        // }\n        // becomes\n        // { 0: [[x11, x12]],\n        //   1: [[x21, x22, x23]],\n        //   2: [[x31],[x32]]\n        // }\n        const ds = [];\n        for (let i = 0, end = nanned_qs.length; i < end; i++) {\n            ds[i] = [];\n            let qs = copy(nanned_qs[i]);\n            while (qs.length > 0) {\n                const nan_index = find_last_index(qs, (q) => isStrictNaN(q));\n                let qs_part;\n                if (nan_index >= 0)\n                    qs_part = qs.splice(nan_index);\n                else {\n                    qs_part = qs;\n                    qs = [];\n                }\n                const denanned = qs_part.filter((q) => !isStrictNaN(q));\n                ds[i].push(denanned);\n            }\n        }\n        return ds;\n    }\n    _index_data() {\n        const xss = this._build_discontinuous_object(this._xs); // XXX\n        const yss = this._build_discontinuous_object(this._ys); // XXX\n        const points = [];\n        for (let i = 0, end = this._xs.length; i < end; i++) {\n            for (let j = 0, endj = xss[i].length; j < endj; j++) {\n                const xs = xss[i][j];\n                const ys = yss[i][j];\n                if (xs.length == 0)\n                    continue;\n                points.push({ x0: min(xs), y0: min(ys), x1: max(xs), y1: max(ys), i });\n            }\n        }\n        return new SpatialIndex(points);\n    }\n    _mask_data() {\n        const xr = this.renderer.plot_view.frame.x_ranges.default;\n        const [x0, x1] = [xr.min, xr.max];\n        const yr = this.renderer.plot_view.frame.y_ranges.default;\n        const [y0, y1] = [yr.min, yr.max];\n        const indices = this.index.indices({ x0, x1, y0, y1 });\n        // TODO (bev) this should be under test\n        return indices.sort((a, b) => a - b);\n    }\n    _inner_loop(ctx, sx, sy, func) {\n        for (let j = 0, end = sx.length; j < end; j++) {\n            if (j == 0) {\n                ctx.beginPath();\n                ctx.moveTo(sx[j], sy[j]);\n                continue;\n            }\n            else if (isNaN(sx[j] + sy[j])) {\n                ctx.closePath();\n                func.apply(ctx);\n                ctx.beginPath();\n                continue;\n            }\n            else\n                ctx.lineTo(sx[j], sy[j]);\n        }\n        ctx.closePath();\n        func.call(ctx);\n    }\n    _render(ctx, indices, { sxs, sys }) {\n        // this.sxss and this.syss are used by _hit_point and sxc, syc\n        // This is the earliest we can build them, and only build them once\n        this.sxss = this._build_discontinuous_object(sxs); // XXX\n        this.syss = this._build_discontinuous_object(sys); // XXX\n        for (const i of indices) {\n            const [sx, sy] = [sxs[i], sys[i]];\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                this._inner_loop(ctx, sx, sy, ctx.fill);\n            }\n            this.visuals.hatch.doit2(ctx, i, () => this._inner_loop(ctx, sx, sy, ctx.fill), () => this.renderer.request_render());\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                this._inner_loop(ctx, sx, sy, ctx.stroke);\n            }\n        }\n    }\n    _hit_rect(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const xs = [sx0, sx1, sx1, sx0];\n        const ys = [sy0, sy0, sy1, sy1];\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const candidates = this.index.indices({ x0, x1, y0, y1 });\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            const sxss = this.sxs[idx];\n            const syss = this.sys[idx];\n            let hit = true;\n            for (let j = 0, endj = sxss.length; j < endj; j++) {\n                const sx = sxss[j];\n                const sy = syss[j];\n                if (!hittest.point_in_poly(sx, sy, xs, ys)) {\n                    hit = false;\n                    break;\n                }\n            }\n            if (hit)\n                hits.push(idx);\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            const sxs = this.sxss[idx];\n            const sys = this.syss[idx];\n            for (let j = 0, endj = sxs.length; j < endj; j++) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    hits.push(idx);\n                }\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _get_snap_coord(array) {\n        return sum(array) / array.length;\n    }\n    scenterx(i, sx, sy) {\n        if (this.sxss[i].length == 1) {\n            // We don't have discontinuous objects so we're ok\n            return this._get_snap_coord(this.sxs[i]);\n        }\n        else {\n            // We have discontinuous objects, so we need to find which\n            // one we're in, we can use point_in_poly again\n            const sxs = this.sxss[i];\n            const sys = this.syss[i];\n            for (let j = 0, end = sxs.length; j < end; j++) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j]))\n                    return this._get_snap_coord(sxs[j]);\n            }\n        }\n        unreachable();\n    }\n    scentery(i, sx, sy) {\n        if (this.syss[i].length == 1) {\n            // We don't have discontinuous objects so we're ok\n            return this._get_snap_coord(this.sys[i]);\n        }\n        else {\n            // We have discontinuous objects, so we need to find which\n            // one we're in, we can use point_in_poly again\n            const sxs = this.sxss[i];\n            const sys = this.syss[i];\n            for (let j = 0, end = sxs.length; j < end; j++) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j]))\n                    return this._get_snap_coord(sys[j]);\n            }\n        }\n        unreachable();\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_area_legend(this.visuals, ctx, bbox, index);\n    }\n}\nPatchesView.__name__ = \"PatchesView\";\nexport class Patches extends Glyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Patches() {\n        this.prototype.default_view = PatchesView;\n        this.coords([['xs', 'ys']]);\n        this.mixins(['line', 'fill', 'hatch']);\n    }\n}\nPatches.__name__ = \"Patches\";\nPatches.init_Patches();\n//# sourceMappingURL=patches.js.map"]},"metadata":{},"sourceType":"module"}