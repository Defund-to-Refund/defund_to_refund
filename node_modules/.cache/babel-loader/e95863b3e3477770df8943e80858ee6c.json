{"ast":null,"code":"import { SingleIntervalTicker } from \"./single_interval_ticker\";\nimport { copy_date, last_month_no_later_than, ONE_DAY } from \"./util\";\nimport * as p from \"../../core/properties\";\nimport { concat } from \"../../core/util/array\"; // Given a start and end time in millis, returns the shortest array of\n// consecutive months (as Dates) that surrounds both times.\n\nfunction date_range_by_month(start_time, end_time) {\n  const start_date = last_month_no_later_than(new Date(start_time));\n  const end_date = last_month_no_later_than(new Date(end_time)); // XXX This is not a reliable technique in general, but it should be\n  // safe when the day of the month is 1.  (The problem case is this:\n  // Mar 31 -> Apr 31, which becomes May 1.)\n\n  end_date.setUTCMonth(end_date.getUTCMonth() + 1);\n  const dates = [];\n  const date = start_date;\n\n  while (true) {\n    dates.push(copy_date(date));\n    date.setUTCMonth(date.getUTCMonth() + 1);\n    if (date > end_date) break;\n  }\n\n  return dates;\n}\n\nexport class DaysTicker extends SingleIntervalTicker {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_DaysTicker() {\n    this.define({\n      days: [p.Array, []]\n    });\n    this.override({\n      num_minor_ticks: 0\n    });\n  }\n\n  initialize() {\n    super.initialize();\n    const days = this.days;\n    if (days.length > 1) this.interval = (days[1] - days[0]) * ONE_DAY;else this.interval = 31 * ONE_DAY;\n  }\n\n  get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\n    const month_dates = date_range_by_month(data_low, data_high);\n    const days = this.days;\n\n    const days_of_month = (month_date, interval) => {\n      const current_month = month_date.getUTCMonth();\n      const dates = [];\n\n      for (const day of days) {\n        const day_date = copy_date(month_date);\n        day_date.setUTCDate(day); // We can't use all of the values in this.days, because they may not\n        // fall within the current month.  In fact, if, e.g., our month is 28 days\n        // and we're marking every third day, we don't want day 28 to show up\n        // because it'll be right next to the 1st of the next month.  So we\n        // make sure we have a bit of room before we include a day.\n        // TODO (bev) The above description does not exactly work because JS Date\n        // is broken and will happily consider \"Feb 28 + 3*ONE_DAY\" to have month \"2\"\n\n        const future_date = new Date(day_date.getTime() + interval / 2);\n        if (future_date.getUTCMonth() == current_month) dates.push(day_date);\n      }\n\n      return dates;\n    };\n\n    const interval = this.interval;\n    const day_dates = concat(month_dates.map(date => days_of_month(date, interval)));\n    const all_ticks = day_dates.map(day_date => day_date.getTime());\n    const ticks_in_range = all_ticks.filter(tick => data_low <= tick && tick <= data_high);\n    return {\n      major: ticks_in_range,\n      minor: []\n    };\n  }\n\n}\nDaysTicker.__name__ = \"DaysTicker\";\nDaysTicker.init_DaysTicker();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/days_ticker.js"],"names":["SingleIntervalTicker","copy_date","last_month_no_later_than","ONE_DAY","p","concat","date_range_by_month","start_time","end_time","start_date","Date","end_date","setUTCMonth","getUTCMonth","dates","date","push","DaysTicker","constructor","attrs","init_DaysTicker","define","days","Array","override","num_minor_ticks","initialize","length","interval","get_ticks_no_defaults","data_low","data_high","_cross_loc","_desired_n_ticks","month_dates","days_of_month","month_date","current_month","day","day_date","setUTCDate","future_date","getTime","day_dates","map","all_ticks","ticks_in_range","filter","tick","major","minor","__name__"],"mappings":"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","sourcesContent":["import { SingleIntervalTicker } from \"./single_interval_ticker\";\nimport { copy_date, last_month_no_later_than, ONE_DAY } from \"./util\";\nimport * as p from \"../../core/properties\";\nimport { concat } from \"../../core/util/array\";\n// Given a start and end time in millis, returns the shortest array of\n// consecutive months (as Dates) that surrounds both times.\nfunction date_range_by_month(start_time, end_time) {\n    const start_date = last_month_no_later_than(new Date(start_time));\n    const end_date = last_month_no_later_than(new Date(end_time));\n    // XXX This is not a reliable technique in general, but it should be\n    // safe when the day of the month is 1.  (The problem case is this:\n    // Mar 31 -> Apr 31, which becomes May 1.)\n    end_date.setUTCMonth(end_date.getUTCMonth() + 1);\n    const dates = [];\n    const date = start_date;\n    while (true) {\n        dates.push(copy_date(date));\n        date.setUTCMonth(date.getUTCMonth() + 1);\n        if (date > end_date)\n            break;\n    }\n    return dates;\n}\nexport class DaysTicker extends SingleIntervalTicker {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_DaysTicker() {\n        this.define({\n            days: [p.Array, []],\n        });\n        this.override({\n            num_minor_ticks: 0,\n        });\n    }\n    initialize() {\n        super.initialize();\n        const days = this.days;\n        if (days.length > 1)\n            this.interval = (days[1] - days[0]) * ONE_DAY;\n        else\n            this.interval = 31 * ONE_DAY;\n    }\n    get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\n        const month_dates = date_range_by_month(data_low, data_high);\n        const days = this.days;\n        const days_of_month = (month_date, interval) => {\n            const current_month = month_date.getUTCMonth();\n            const dates = [];\n            for (const day of days) {\n                const day_date = copy_date(month_date);\n                day_date.setUTCDate(day);\n                // We can't use all of the values in this.days, because they may not\n                // fall within the current month.  In fact, if, e.g., our month is 28 days\n                // and we're marking every third day, we don't want day 28 to show up\n                // because it'll be right next to the 1st of the next month.  So we\n                // make sure we have a bit of room before we include a day.\n                // TODO (bev) The above description does not exactly work because JS Date\n                // is broken and will happily consider \"Feb 28 + 3*ONE_DAY\" to have month \"2\"\n                const future_date = new Date(day_date.getTime() + (interval / 2));\n                if (future_date.getUTCMonth() == current_month)\n                    dates.push(day_date);\n            }\n            return dates;\n        };\n        const interval = this.interval;\n        const day_dates = concat(month_dates.map((date) => days_of_month(date, interval)));\n        const all_ticks = day_dates.map((day_date) => day_date.getTime());\n        const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\n        return {\n            major: ticks_in_range,\n            minor: [],\n        };\n    }\n}\nDaysTicker.__name__ = \"DaysTicker\";\nDaysTicker.init_DaysTicker();\n//# sourceMappingURL=days_ticker.js.map"]},"metadata":{},"sourceType":"module"}