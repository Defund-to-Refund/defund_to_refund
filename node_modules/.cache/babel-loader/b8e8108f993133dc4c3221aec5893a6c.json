{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { CartesianFrame } from \"../canvas/cartesian_frame\";\nimport { Canvas } from \"../canvas/canvas\";\nimport { DataRange1d } from \"../ranges/data_range1d\";\nimport { GlyphRenderer, GlyphRendererView } from \"../renderers/glyph_renderer\";\nimport { LayoutDOMView } from \"../layouts/layout_dom\";\nimport { Title } from \"../annotations/title\";\nimport { AxisView } from \"../axes/axis\";\nimport { ToolbarPanel } from \"../annotations/toolbar_panel\";\nimport { Reset } from \"../../core/bokeh_events\";\nimport { Signal0 } from \"../../core/signaling\";\nimport { build_view, build_views, remove_views } from \"../../core/build_views\";\nimport { UIEvents } from \"../../core/ui_events\";\nimport { Visuals } from \"../../core/visuals\";\nimport { logger } from \"../../core/logging\";\nimport { throttle } from \"../../core/util/throttle\";\nimport { isArray, isStrictNaN } from \"../../core/util/types\";\nimport { copy, reversed } from \"../../core/util/array\";\nimport { values } from \"../../core/util/object\";\nimport { Sizeable, Layoutable } from \"../../core/layout\";\nimport { HStack, VStack } from \"../../core/layout/alignments\";\nimport { SidePanel } from \"../../core/layout/side_panel\";\nimport { Row, Column } from \"../../core/layout/grid\";\nimport { BBox } from \"../../core/util/bbox\";\nexport class PlotLayout extends Layoutable {\n  constructor() {\n    super(...arguments);\n    this.min_border = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n\n  _measure(viewport) {\n    viewport = new Sizeable(viewport).bounded_to(this.sizing.size);\n    const left_hint = this.left_panel.measure({\n      width: 0,\n      height: viewport.height\n    });\n    const left = Math.max(left_hint.width, this.min_border.left);\n    const right_hint = this.right_panel.measure({\n      width: 0,\n      height: viewport.height\n    });\n    const right = Math.max(right_hint.width, this.min_border.right);\n    const top_hint = this.top_panel.measure({\n      width: viewport.width,\n      height: 0\n    });\n    const top = Math.max(top_hint.height, this.min_border.top);\n    const bottom_hint = this.bottom_panel.measure({\n      width: viewport.width,\n      height: 0\n    });\n    const bottom = Math.max(bottom_hint.height, this.min_border.bottom);\n    const center_viewport = new Sizeable(viewport).shrink_by({\n      left,\n      right,\n      top,\n      bottom\n    });\n    const center = this.center_panel.measure(center_viewport);\n    const width = left + center.width + right;\n    const height = top + center.height + bottom;\n\n    const align = (() => {\n      const {\n        width_policy,\n        height_policy\n      } = this.center_panel.sizing;\n      return width_policy != \"fixed\" && height_policy != \"fixed\";\n    })();\n\n    return {\n      width,\n      height,\n      inner: {\n        left,\n        right,\n        top,\n        bottom\n      },\n      align\n    };\n  }\n\n  _set_geometry(outer, inner) {\n    super._set_geometry(outer, inner);\n\n    this.center_panel.set_geometry(inner);\n    const left_hint = this.left_panel.measure({\n      width: 0,\n      height: outer.height\n    });\n    const right_hint = this.right_panel.measure({\n      width: 0,\n      height: outer.height\n    });\n    const top_hint = this.top_panel.measure({\n      width: outer.width,\n      height: 0\n    });\n    const bottom_hint = this.bottom_panel.measure({\n      width: outer.width,\n      height: 0\n    });\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = inner;\n    this.top_panel.set_geometry(new BBox({\n      left,\n      right,\n      bottom: top,\n      height: top_hint.height\n    }));\n    this.bottom_panel.set_geometry(new BBox({\n      left,\n      right,\n      top: bottom,\n      height: bottom_hint.height\n    }));\n    this.left_panel.set_geometry(new BBox({\n      top,\n      bottom,\n      right: left,\n      width: left_hint.width\n    }));\n    this.right_panel.set_geometry(new BBox({\n      top,\n      bottom,\n      left: right,\n      width: right_hint.width\n    }));\n  }\n\n}\nPlotLayout.__name__ = \"PlotLayout\";\nexport class PlotView extends LayoutDOMView {\n  constructor() {\n    super(...arguments);\n    this._outer_bbox = new BBox();\n    this._inner_bbox = new BBox();\n    this._needs_paint = true;\n    this._needs_layout = false;\n  }\n\n  get is_paused() {\n    return this._is_paused != null && this._is_paused !== 0;\n  }\n\n  get child_models() {\n    return [];\n  }\n\n  pause() {\n    if (this._is_paused == null) this._is_paused = 1;else this._is_paused += 1;\n  }\n\n  unpause(no_render = false) {\n    if (this._is_paused == null) throw new Error(\"wasn't paused\");\n    this._is_paused -= 1;\n    if (this._is_paused == 0 && !no_render) this.request_paint();\n  } // TODO: this needs to be removed\n\n\n  request_render() {\n    this.request_paint();\n  }\n\n  request_paint() {\n    if (!this.is_paused) {\n      const promise = this.throttled_paint();\n      this._ready = this._ready.then(() => promise);\n    }\n  }\n\n  request_layout() {\n    this._needs_layout = true;\n    this.request_paint();\n  }\n\n  reset() {\n    if (this.model.reset_policy == \"standard\") {\n      this.clear_state();\n      this.reset_range();\n      this.reset_selection();\n    }\n\n    this.model.trigger_event(new Reset());\n  }\n\n  remove() {\n    this.ui_event_bus.destroy();\n    remove_views(this.renderer_views);\n    remove_views(this.tool_views);\n    this.canvas_view.remove();\n    super.remove();\n  }\n\n  render() {\n    super.render();\n    this.el.appendChild(this.canvas_view.el);\n    this.canvas_view.render();\n  }\n\n  initialize() {\n    this.pause();\n    super.initialize();\n    this.state_changed = new Signal0(this, \"state_changed\");\n    this.lod_started = false;\n    this.visuals = new Visuals(this.model); // XXX\n\n    this._initial_state_info = {\n      selection: {},\n      dimensions: {\n        width: 0,\n        height: 0\n      }\n    };\n    this.visibility_callbacks = [];\n    this.state = {\n      history: [],\n      index: -1\n    };\n    this.canvas = new Canvas({\n      use_hidpi: this.model.hidpi,\n      output_backend: this.model.output_backend\n    });\n    this.frame = new CartesianFrame(this.model.x_scale, this.model.y_scale, this.model.x_range, this.model.y_range, this.model.extra_x_ranges, this.model.extra_y_ranges);\n    this.throttled_paint = throttle(() => this.repaint(), 1000 / 60);\n    const {\n      title_location,\n      title\n    } = this.model;\n\n    if (title_location != null && title != null) {\n      this._title = title instanceof Title ? title : new Title({\n        text: title\n      });\n    }\n\n    const {\n      toolbar_location,\n      toolbar\n    } = this.model;\n\n    if (toolbar_location != null && toolbar != null) {\n      this._toolbar = new ToolbarPanel({\n        toolbar\n      });\n      toolbar.toolbar_location = toolbar_location;\n    }\n\n    this.renderer_views = {};\n    this.tool_views = {};\n  }\n\n  async lazy_initialize() {\n    this.canvas_view = await build_view(this.canvas, {\n      parent: this\n    });\n    this.ui_event_bus = new UIEvents(this, this.model.toolbar, this.canvas_view.events_el);\n    await this.build_renderer_views();\n    await this.build_tool_views();\n    this.update_dataranges();\n    this.unpause(true);\n    logger.debug(\"PlotView initialized\");\n  }\n\n  _width_policy() {\n    return this.model.frame_width == null ? super._width_policy() : \"min\";\n  }\n\n  _height_policy() {\n    return this.model.frame_height == null ? super._height_policy() : \"min\";\n  }\n\n  _update_layout() {\n    this.layout = new PlotLayout();\n    this.layout.set_sizing(this.box_sizing());\n    const {\n      frame_width,\n      frame_height\n    } = this.model;\n    this.layout.center_panel = this.frame;\n    this.layout.center_panel.set_sizing(Object.assign(Object.assign({}, frame_width != null ? {\n      width_policy: \"fixed\",\n      width: frame_width\n    } : {\n      width_policy: \"fit\"\n    }), frame_height != null ? {\n      height_policy: \"fixed\",\n      height: frame_height\n    } : {\n      height_policy: \"fit\"\n    }));\n    const above = copy(this.model.above);\n    const below = copy(this.model.below);\n    const left = copy(this.model.left);\n    const right = copy(this.model.right);\n\n    const get_side = side => {\n      switch (side) {\n        case \"above\":\n          return above;\n\n        case \"below\":\n          return below;\n\n        case \"left\":\n          return left;\n\n        case \"right\":\n          return right;\n      }\n    };\n\n    const {\n      title_location,\n      title\n    } = this.model;\n\n    if (title_location != null && title != null) {\n      get_side(title_location).push(this._title);\n    }\n\n    const {\n      toolbar_location,\n      toolbar\n    } = this.model;\n\n    if (toolbar_location != null && toolbar != null) {\n      const panels = get_side(toolbar_location);\n      let push_toolbar = true;\n\n      if (this.model.toolbar_sticky) {\n        for (let i = 0; i < panels.length; i++) {\n          const panel = panels[i];\n\n          if (panel instanceof Title) {\n            if (toolbar_location == \"above\" || toolbar_location == \"below\") panels[i] = [panel, this._toolbar];else panels[i] = [this._toolbar, panel];\n            push_toolbar = false;\n            break;\n          }\n        }\n      }\n\n      if (push_toolbar) panels.push(this._toolbar);\n    }\n\n    const set_layout = (side, model) => {\n      const view = this.renderer_views[model.id];\n      return view.layout = new SidePanel(side, view);\n    };\n\n    const set_layouts = (side, panels) => {\n      const horizontal = side == \"above\" || side == \"below\";\n      const layouts = [];\n\n      for (const panel of panels) {\n        if (isArray(panel)) {\n          const items = panel.map(subpanel => {\n            const item = set_layout(side, subpanel);\n\n            if (subpanel instanceof ToolbarPanel) {\n              const dim = horizontal ? \"width_policy\" : \"height_policy\";\n              item.set_sizing(Object.assign(Object.assign({}, item.sizing), {\n                [dim]: \"min\"\n              }));\n            }\n\n            return item;\n          });\n          let layout;\n\n          if (horizontal) {\n            layout = new Row(items);\n            layout.set_sizing({\n              width_policy: \"max\",\n              height_policy: \"min\"\n            });\n          } else {\n            layout = new Column(items);\n            layout.set_sizing({\n              width_policy: \"min\",\n              height_policy: \"max\"\n            });\n          }\n\n          layout.absolute = true;\n          layouts.push(layout);\n        } else layouts.push(set_layout(side, panel));\n      }\n\n      return layouts;\n    };\n\n    const min_border = this.model.min_border != null ? this.model.min_border : 0;\n    this.layout.min_border = {\n      left: this.model.min_border_left != null ? this.model.min_border_left : min_border,\n      top: this.model.min_border_top != null ? this.model.min_border_top : min_border,\n      right: this.model.min_border_right != null ? this.model.min_border_right : min_border,\n      bottom: this.model.min_border_bottom != null ? this.model.min_border_bottom : min_border\n    };\n    const top_panel = new VStack();\n    const bottom_panel = new VStack();\n    const left_panel = new HStack();\n    const right_panel = new HStack();\n    top_panel.children = reversed(set_layouts(\"above\", above));\n    bottom_panel.children = set_layouts(\"below\", below);\n    left_panel.children = reversed(set_layouts(\"left\", left));\n    right_panel.children = set_layouts(\"right\", right);\n    top_panel.set_sizing({\n      width_policy: \"fit\",\n      height_policy: \"min\"\n      /*, min_height: this.layout.min_border.top*/\n\n    });\n    bottom_panel.set_sizing({\n      width_policy: \"fit\",\n      height_policy: \"min\"\n      /*, min_height: this.layout.min_width.bottom*/\n\n    });\n    left_panel.set_sizing({\n      width_policy: \"min\",\n      height_policy: \"fit\"\n      /*, min_width: this.layout.min_width.left*/\n\n    });\n    right_panel.set_sizing({\n      width_policy: \"min\",\n      height_policy: \"fit\"\n      /*, min_width: this.layout.min_width.right*/\n\n    });\n    this.layout.top_panel = top_panel;\n    this.layout.bottom_panel = bottom_panel;\n    this.layout.left_panel = left_panel;\n    this.layout.right_panel = right_panel;\n  }\n\n  get axis_views() {\n    const views = [];\n\n    for (const id in this.renderer_views) {\n      const child_view = this.renderer_views[id];\n      if (child_view instanceof AxisView) views.push(child_view);\n    }\n\n    return views;\n  }\n\n  set_cursor(cursor = \"default\") {\n    this.canvas_view.el.style.cursor = cursor;\n  }\n\n  set_toolbar_visibility(visible) {\n    for (const callback of this.visibility_callbacks) callback(visible);\n  }\n\n  prepare_webgl(ratio, frame_box) {\n    // Prepare WebGL for a drawing pass\n    const {\n      webgl\n    } = this.canvas_view;\n\n    if (webgl != null) {\n      // Sync canvas size\n      const {\n        width,\n        height\n      } = this.canvas_view.bbox;\n      const {\n        pixel_ratio\n      } = this.canvas_view.model;\n      webgl.canvas.width = pixel_ratio * width;\n      webgl.canvas.height = pixel_ratio * height;\n      const {\n        gl\n      } = webgl; // Clipping\n\n      gl.enable(gl.SCISSOR_TEST);\n      const [sx, sy, w, h] = frame_box;\n      const {\n        xview,\n        yview\n      } = this.canvas_view.bbox;\n      const vx = xview.compute(sx);\n      const vy = yview.compute(sy + h);\n      gl.scissor(ratio * vx, ratio * vy, ratio * w, ratio * h); // lower left corner, width, height\n      // Setup blending\n\n      gl.enable(gl.BLEND);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE); // premultipliedAlpha == true\n    }\n  }\n\n  clear_webgl() {\n    const {\n      webgl\n    } = this.canvas_view;\n\n    if (webgl != null) {\n      // Prepare GL for drawing\n      const {\n        gl,\n        canvas\n      } = webgl;\n      gl.viewport(0, 0, canvas.width, canvas.height);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  blit_webgl() {\n    // This should be called when the ctx has no state except the HIDPI transform\n    const {\n      ctx,\n      webgl\n    } = this.canvas_view;\n\n    if (webgl != null) {\n      // Blit gl canvas into the 2D canvas. To do 1-on-1 blitting, we need\n      // to remove the hidpi transform, then blit, then restore.\n      // ctx.globalCompositeOperation = \"source-over\"  -> OK; is the default\n      logger.debug('drawing with WebGL');\n      ctx.restore();\n      ctx.drawImage(webgl.canvas, 0, 0); // Set back hidpi transform\n\n      ctx.save();\n\n      if (this.model.hidpi) {\n        const ratio = this.canvas.pixel_ratio;\n        ctx.scale(ratio, ratio);\n        ctx.translate(0.5, 0.5);\n      }\n    }\n  }\n\n  update_dataranges() {\n    // Update any DataRange1ds here\n    const bounds = {};\n    const log_bounds = {};\n    let calculate_log_bounds = false;\n\n    for (const r of values(this.frame.x_ranges).concat(values(this.frame.y_ranges))) {\n      if (r instanceof DataRange1d) {\n        if (r.scale_hint == \"log\") calculate_log_bounds = true;\n      }\n    }\n\n    for (const id in this.renderer_views) {\n      const view = this.renderer_views[id];\n\n      if (view instanceof GlyphRendererView) {\n        const bds = view.glyph.bounds();\n        if (bds != null) bounds[id] = bds;\n\n        if (calculate_log_bounds) {\n          const log_bds = view.glyph.log_bounds();\n          if (log_bds != null) log_bounds[id] = log_bds;\n        }\n      }\n    }\n\n    let follow_enabled = false;\n    let has_bounds = false;\n    const {\n      width,\n      height\n    } = this.frame.bbox;\n    let r;\n    if (this.model.match_aspect !== false && width != 0 && height != 0) r = 1 / this.model.aspect_scale * (width / height);\n\n    for (const xr of values(this.frame.x_ranges)) {\n      if (xr instanceof DataRange1d) {\n        const bounds_to_use = xr.scale_hint == \"log\" ? log_bounds : bounds;\n        xr.update(bounds_to_use, 0, this.model.id, r);\n\n        if (xr.follow) {\n          follow_enabled = true;\n        }\n      }\n\n      if (xr.bounds != null) has_bounds = true;\n    }\n\n    for (const yr of values(this.frame.y_ranges)) {\n      if (yr instanceof DataRange1d) {\n        const bounds_to_use = yr.scale_hint == \"log\" ? log_bounds : bounds;\n        yr.update(bounds_to_use, 1, this.model.id, r);\n\n        if (yr.follow) {\n          follow_enabled = true;\n        }\n      }\n\n      if (yr.bounds != null) has_bounds = true;\n    }\n\n    if (follow_enabled && has_bounds) {\n      logger.warn('Follow enabled so bounds are unset.');\n\n      for (const xr of values(this.frame.x_ranges)) {\n        xr.bounds = null;\n      }\n\n      for (const yr of values(this.frame.y_ranges)) {\n        yr.bounds = null;\n      }\n    }\n\n    this.range_update_timestamp = Date.now();\n  }\n\n  map_to_screen(x, y, x_name = \"default\", y_name = \"default\") {\n    return this.frame.map_to_screen(x, y, x_name, y_name);\n  }\n\n  push_state(type, new_info) {\n    const {\n      history,\n      index\n    } = this.state;\n    const prev_info = history[index] != null ? history[index].info : {};\n    const info = Object.assign(Object.assign(Object.assign({}, this._initial_state_info), prev_info), new_info);\n    this.state.history = this.state.history.slice(0, this.state.index + 1);\n    this.state.history.push({\n      type,\n      info\n    });\n    this.state.index = this.state.history.length - 1;\n    this.state_changed.emit();\n  }\n\n  clear_state() {\n    this.state = {\n      history: [],\n      index: -1\n    };\n    this.state_changed.emit();\n  }\n\n  can_undo() {\n    return this.state.index >= 0;\n  }\n\n  can_redo() {\n    return this.state.index < this.state.history.length - 1;\n  }\n\n  undo() {\n    if (this.can_undo()) {\n      this.state.index -= 1;\n\n      this._do_state_change(this.state.index);\n\n      this.state_changed.emit();\n    }\n  }\n\n  redo() {\n    if (this.can_redo()) {\n      this.state.index += 1;\n\n      this._do_state_change(this.state.index);\n\n      this.state_changed.emit();\n    }\n  }\n\n  _do_state_change(index) {\n    const info = this.state.history[index] != null ? this.state.history[index].info : this._initial_state_info;\n    if (info.range != null) this.update_range(info.range);\n    if (info.selection != null) this.update_selection(info.selection);\n  }\n\n  get_selection() {\n    const selection = {};\n\n    for (const renderer of this.model.renderers) {\n      if (renderer instanceof GlyphRenderer) {\n        const {\n          selected\n        } = renderer.data_source;\n        selection[renderer.id] = selected;\n      }\n    }\n\n    return selection;\n  }\n\n  update_selection(selection) {\n    for (const renderer of this.model.renderers) {\n      if (!(renderer instanceof GlyphRenderer)) continue;\n      const ds = renderer.data_source;\n\n      if (selection != null) {\n        if (selection[renderer.id] != null) ds.selected.update(selection[renderer.id], true, false);\n      } else ds.selection_manager.clear();\n    }\n  }\n\n  reset_selection() {\n    this.update_selection(null);\n  }\n\n  _update_ranges_together(range_info_iter) {\n    // Get weight needed to scale the diff of the range to honor interval limits\n    let weight = 1.0;\n\n    for (const [rng, range_info] of range_info_iter) {\n      weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\n    } // Apply shared weight to all ranges\n\n\n    if (weight < 1) {\n      for (const [rng, range_info] of range_info_iter) {\n        range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n        range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n      }\n    }\n  }\n\n  _update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus) {\n    let hit_bound = false;\n\n    for (const [rng, range_info] of range_info_iter) {\n      // Limit range interval first. Note that for scroll events,\n      // the interval has already been limited for all ranges simultaneously\n      if (!is_scrolling) {\n        const weight = this._get_weight_to_constrain_interval(rng, range_info);\n\n        if (weight < 1) {\n          range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n          range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n        }\n      } // Prevent range from going outside limits\n      // Also ensure that range keeps the same delta when panning/scrolling\n\n\n      if (rng.bounds != null && rng.bounds != \"auto\") {\n        // check `auto` for type-checking purpose\n        const [min, max] = rng.bounds;\n        const new_interval = Math.abs(range_info.end - range_info.start);\n\n        if (rng.is_reversed) {\n          if (min != null) {\n            if (min >= range_info.end) {\n              hit_bound = true;\n              range_info.end = min;\n\n              if (is_panning || is_scrolling) {\n                range_info.start = min + new_interval;\n              }\n            }\n          }\n\n          if (max != null) {\n            if (max <= range_info.start) {\n              hit_bound = true;\n              range_info.start = max;\n\n              if (is_panning || is_scrolling) {\n                range_info.end = max - new_interval;\n              }\n            }\n          }\n        } else {\n          if (min != null) {\n            if (min >= range_info.start) {\n              hit_bound = true;\n              range_info.start = min;\n\n              if (is_panning || is_scrolling) {\n                range_info.end = min + new_interval;\n              }\n            }\n          }\n\n          if (max != null) {\n            if (max <= range_info.end) {\n              hit_bound = true;\n              range_info.end = max;\n\n              if (is_panning || is_scrolling) {\n                range_info.start = max - new_interval;\n              }\n            }\n          }\n        }\n      }\n    } // Cancel the event when hitting a bound while scrolling. This ensures that\n    // the scroll-zoom tool maintains its focus position. Setting `maintain_focus`\n    // to false results in a more \"gliding\" behavior, allowing one to\n    // zoom out more smoothly, at the cost of losing the focus position.\n\n\n    if (is_scrolling && hit_bound && maintain_focus) return;\n\n    for (const [rng, range_info] of range_info_iter) {\n      rng.have_updated_interactively = true;\n      if (rng.start != range_info.start || rng.end != range_info.end) rng.setv(range_info);\n    }\n  }\n\n  _get_weight_to_constrain_interval(rng, range_info) {\n    // Get the weight by which a range-update can be applied\n    // to still honor the interval limits (including the implicit\n    // max interval imposed by the bounds)\n    const {\n      min_interval\n    } = rng;\n    let {\n      max_interval\n    } = rng; // Express bounds as a max_interval. By doing this, the application of\n    // bounds and interval limits can be applied independent from each-other.\n\n    if (rng.bounds != null && rng.bounds != \"auto\") {\n      // check `auto` for type-checking purpose\n      const [min, max] = rng.bounds;\n\n      if (min != null && max != null) {\n        const max_interval2 = Math.abs(max - min);\n        max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\n      }\n    }\n\n    let weight = 1.0;\n\n    if (min_interval != null || max_interval != null) {\n      const old_interval = Math.abs(rng.end - rng.start);\n      const new_interval = Math.abs(range_info.end - range_info.start);\n\n      if (min_interval > 0 && new_interval < min_interval) {\n        weight = (old_interval - min_interval) / (old_interval - new_interval);\n      }\n\n      if (max_interval > 0 && new_interval > max_interval) {\n        weight = (max_interval - old_interval) / (new_interval - old_interval);\n      }\n\n      weight = Math.max(0.0, Math.min(1.0, weight));\n    }\n\n    return weight;\n  }\n\n  update_range(range_info, is_panning = false, is_scrolling = false, maintain_focus = true) {\n    this.pause();\n    const {\n      x_ranges,\n      y_ranges\n    } = this.frame;\n\n    if (range_info == null) {\n      for (const name in x_ranges) {\n        const rng = x_ranges[name];\n        rng.reset();\n      }\n\n      for (const name in y_ranges) {\n        const rng = y_ranges[name];\n        rng.reset();\n      }\n\n      this.update_dataranges();\n    } else {\n      const range_info_iter = [];\n\n      for (const name in x_ranges) {\n        const rng = x_ranges[name];\n        range_info_iter.push([rng, range_info.xrs[name]]);\n      }\n\n      for (const name in y_ranges) {\n        const rng = y_ranges[name];\n        range_info_iter.push([rng, range_info.yrs[name]]);\n      }\n\n      if (is_scrolling) {\n        this._update_ranges_together(range_info_iter); // apply interval bounds while keeping aspect\n\n      }\n\n      this._update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus);\n    }\n\n    this.unpause();\n  }\n\n  reset_range() {\n    this.update_range(null);\n  }\n\n  _invalidate_layout() {\n    const needs_layout = () => {\n      for (const panel of this.model.side_panels) {\n        const view = this.renderer_views[panel.id];\n        if (view.layout.has_size_changed()) return true;\n      }\n\n      return false;\n    };\n\n    if (needs_layout()) this.root.compute_layout();\n  }\n\n  get_renderer_views() {\n    return this.computed_renderers.map(r => this.renderer_views[r.id]);\n  }\n\n  async build_renderer_views() {\n    this.computed_renderers = [];\n    const {\n      above,\n      below,\n      left,\n      right,\n      center,\n      renderers\n    } = this.model;\n    this.computed_renderers.push(...above, ...below, ...left, ...right, ...center, ...renderers);\n    if (this._title != null) this.computed_renderers.push(this._title);\n    if (this._toolbar != null) this.computed_renderers.push(this._toolbar);\n\n    for (const tool of this.model.toolbar.tools) {\n      if (tool.overlay != null) this.computed_renderers.push(tool.overlay);\n      this.computed_renderers.push(...tool.synthetic_renderers);\n    }\n\n    await build_views(this.renderer_views, this.computed_renderers, {\n      parent: this\n    });\n  }\n\n  async build_tool_views() {\n    const tool_models = this.model.toolbar.tools;\n    const new_tool_views = await build_views(this.tool_views, tool_models, {\n      parent: this\n    });\n    new_tool_views.map(tool_view => this.ui_event_bus.register_tool(tool_view));\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    const {\n      x_ranges,\n      y_ranges\n    } = this.frame;\n\n    for (const name in x_ranges) {\n      const rng = x_ranges[name];\n      this.connect(rng.change, () => {\n        this._needs_layout = true;\n        this.request_paint();\n      });\n    }\n\n    for (const name in y_ranges) {\n      const rng = y_ranges[name];\n      this.connect(rng.change, () => {\n        this._needs_layout = true;\n        this.request_paint();\n      });\n    }\n\n    const {\n      above,\n      below,\n      left,\n      right,\n      center,\n      renderers\n    } = this.model.properties;\n    this.on_change([above, below, left, right, center, renderers], async () => await this.build_renderer_views());\n    this.connect(this.model.toolbar.properties.tools.change, async () => {\n      await this.build_renderer_views();\n      await this.build_tool_views();\n    });\n    this.connect(this.model.change, () => this.request_paint());\n    this.connect(this.model.reset, () => this.reset());\n  }\n\n  set_initial_range() {\n    // check for good values for ranges before setting initial range\n    let good_vals = true;\n    const {\n      x_ranges,\n      y_ranges\n    } = this.frame;\n    const xrs = {};\n    const yrs = {};\n\n    for (const name in x_ranges) {\n      const {\n        start,\n        end\n      } = x_ranges[name];\n\n      if (start == null || end == null || isStrictNaN(start + end)) {\n        good_vals = false;\n        break;\n      }\n\n      xrs[name] = {\n        start,\n        end\n      };\n    }\n\n    if (good_vals) {\n      for (const name in y_ranges) {\n        const {\n          start,\n          end\n        } = y_ranges[name];\n\n        if (start == null || end == null || isStrictNaN(start + end)) {\n          good_vals = false;\n          break;\n        }\n\n        yrs[name] = {\n          start,\n          end\n        };\n      }\n    }\n\n    if (good_vals) {\n      this._initial_state_info.range = {\n        xrs,\n        yrs\n      };\n      logger.debug(\"initial ranges set\");\n    } else logger.warn('could not set initial ranges');\n  }\n\n  has_finished() {\n    if (!super.has_finished()) return false;\n\n    for (const id in this.renderer_views) {\n      const view = this.renderer_views[id];\n      if (!view.has_finished()) return false;\n    }\n\n    return true;\n  }\n\n  after_layout() {\n    super.after_layout();\n    this._needs_layout = false;\n    this.model.setv({\n      inner_width: Math.round(this.frame._width.value),\n      inner_height: Math.round(this.frame._height.value),\n      outer_width: Math.round(this.layout._width.value),\n      outer_height: Math.round(this.layout._height.value)\n    }, {\n      no_change: true\n    });\n\n    if (this.model.match_aspect !== false) {\n      this.pause();\n      this.update_dataranges();\n      this.unpause(true);\n    }\n\n    if (!this._outer_bbox.equals(this.layout.bbox)) {\n      const {\n        width,\n        height\n      } = this.layout.bbox;\n      this.canvas_view.prepare_canvas(width, height);\n      this._outer_bbox = this.layout.bbox;\n      this._needs_paint = true;\n    }\n\n    if (!this._inner_bbox.equals(this.frame.inner_bbox)) {\n      this._inner_bbox = this.layout.inner_bbox;\n      this._needs_paint = true;\n    }\n\n    if (this._needs_paint) {\n      // XXX: can't be this.request_paint(), because it would trigger back-and-forth\n      // layout recomputing feedback loop between plots. Plots are also much more\n      // responsive this way, especially in interactive mode.\n      this._needs_paint = false;\n      this.paint();\n    }\n  }\n\n  repaint() {\n    if (this._needs_layout) this._invalidate_layout();\n    this.paint();\n  }\n\n  paint() {\n    if (this.is_paused) return;\n    logger.trace(`PlotView.paint() for ${this.model.id}`);\n    const {\n      document\n    } = this.model;\n\n    if (document != null) {\n      const interactive_duration = document.interactive_duration();\n\n      if (interactive_duration >= 0 && interactive_duration < this.model.lod_interval) {\n        setTimeout(() => {\n          if (document.interactive_duration() > this.model.lod_timeout) {\n            document.interactive_stop(this.model);\n          }\n\n          this.request_paint();\n        }, this.model.lod_timeout);\n      } else document.interactive_stop(this.model);\n    }\n\n    for (const id in this.renderer_views) {\n      const v = this.renderer_views[id];\n\n      if (this.range_update_timestamp == null || v instanceof GlyphRendererView && v.set_data_timestamp > this.range_update_timestamp) {\n        this.update_dataranges();\n        break;\n      }\n    }\n\n    const {\n      ctx\n    } = this.canvas_view;\n    const ratio = this.canvas.pixel_ratio; // Set hidpi-transform\n\n    ctx.save(); // Save default state, do *after* getting ratio, cause setting canvas.width resets transforms\n\n    if (this.model.hidpi) {\n      ctx.scale(ratio, ratio);\n      ctx.translate(0.5, 0.5);\n    }\n\n    const frame_box = [this.frame._left.value, this.frame._top.value, this.frame._width.value, this.frame._height.value];\n\n    this._map_hook(ctx, frame_box);\n\n    this._paint_empty(ctx, frame_box);\n\n    this.prepare_webgl(ratio, frame_box);\n    this.clear_webgl();\n\n    if (this.visuals.outline_line.doit) {\n      ctx.save();\n      this.visuals.outline_line.set_value(ctx);\n      let [x0, y0, w, h] = frame_box; // XXX: shrink outline region by 1px to make right and bottom lines visible\n      // if they are on the edge of the canvas.\n\n      if (x0 + w == this.layout._width.value) {\n        w -= 1;\n      }\n\n      if (y0 + h == this.layout._height.value) {\n        h -= 1;\n      }\n\n      ctx.strokeRect(x0, y0, w, h);\n      ctx.restore();\n    }\n\n    this._paint_levels(ctx, ['image', 'underlay', 'glyph'], frame_box, true);\n\n    this._paint_levels(ctx, ['annotation'], frame_box, false);\n\n    this._paint_levels(ctx, ['overlay'], frame_box, false);\n\n    if (this._initial_state_info.range == null) this.set_initial_range();\n    ctx.restore(); // Restore to default state\n  }\n\n  _paint_levels(ctx, levels, clip_region, global_clip) {\n    for (const level of levels) {\n      for (const renderer of this.computed_renderers) {\n        if (renderer.level != level) continue;\n        const renderer_view = this.renderer_views[renderer.id];\n        ctx.save();\n\n        if (global_clip || renderer_view.needs_clip) {\n          ctx.beginPath();\n          ctx.rect(...clip_region);\n          ctx.clip();\n        }\n\n        renderer_view.render();\n        ctx.restore();\n\n        if (renderer_view.has_webgl) {\n          this.blit_webgl();\n          this.clear_webgl();\n        }\n      }\n    }\n  }\n\n  _map_hook(_ctx, _frame_box) {}\n\n  _paint_empty(ctx, frame_box) {\n    const [cx, cy, cw, ch] = [0, 0, this.layout._width.value, this.layout._height.value];\n    const [fx, fy, fw, fh] = frame_box;\n    ctx.clearRect(cx, cy, cw, ch);\n\n    if (this.visuals.border_fill.doit) {\n      this.visuals.border_fill.set_value(ctx);\n      ctx.fillRect(cx, cy, cw, ch);\n      ctx.clearRect(fx, fy, fw, fh);\n    }\n\n    if (this.visuals.background_fill.doit) {\n      this.visuals.background_fill.set_value(ctx);\n      ctx.fillRect(fx, fy, fw, fh);\n    }\n  }\n\n  save(name) {\n    this.canvas_view.save(name);\n  }\n\n  serializable_state() {\n    const _a = super.serializable_state(),\n          {\n      children\n    } = _a,\n          state = __rest(_a, [\"children\"]);\n\n    const renderers = this.get_renderer_views().map(view => view.serializable_state()).filter(item => \"bbox\" in item);\n    return Object.assign(Object.assign({}, state), {\n      children: [...children, ...renderers]\n    }); // XXX\n  }\n\n}\nPlotView.__name__ = \"PlotView\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/plots/plot_canvas.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","CartesianFrame","Canvas","DataRange1d","GlyphRenderer","GlyphRendererView","LayoutDOMView","Title","AxisView","ToolbarPanel","Reset","Signal0","build_view","build_views","remove_views","UIEvents","Visuals","logger","throttle","isArray","isStrictNaN","copy","reversed","values","Sizeable","Layoutable","HStack","VStack","SidePanel","Row","Column","BBox","PlotLayout","constructor","arguments","min_border","left","top","right","bottom","_measure","viewport","bounded_to","sizing","size","left_hint","left_panel","measure","width","height","Math","max","right_hint","right_panel","top_hint","top_panel","bottom_hint","bottom_panel","center_viewport","shrink_by","center","center_panel","align","width_policy","height_policy","inner","_set_geometry","outer","set_geometry","__name__","PlotView","_outer_bbox","_inner_bbox","_needs_paint","_needs_layout","is_paused","_is_paused","child_models","pause","unpause","no_render","Error","request_paint","request_render","promise","throttled_paint","_ready","then","request_layout","reset","model","reset_policy","clear_state","reset_range","reset_selection","trigger_event","remove","ui_event_bus","destroy","renderer_views","tool_views","canvas_view","render","el","appendChild","initialize","state_changed","lod_started","visuals","_initial_state_info","selection","dimensions","visibility_callbacks","state","history","index","canvas","use_hidpi","hidpi","output_backend","frame","x_scale","y_scale","x_range","y_range","extra_x_ranges","extra_y_ranges","repaint","title_location","title","_title","text","toolbar_location","toolbar","_toolbar","lazy_initialize","parent","events_el","build_renderer_views","build_tool_views","update_dataranges","debug","_width_policy","frame_width","_height_policy","frame_height","_update_layout","layout","set_sizing","box_sizing","assign","above","below","get_side","side","push","panels","push_toolbar","toolbar_sticky","panel","set_layout","view","id","set_layouts","horizontal","layouts","items","map","subpanel","item","dim","absolute","min_border_left","min_border_top","min_border_right","min_border_bottom","children","axis_views","views","child_view","set_cursor","cursor","style","set_toolbar_visibility","visible","callback","prepare_webgl","ratio","frame_box","webgl","bbox","pixel_ratio","gl","enable","SCISSOR_TEST","sx","sy","w","h","xview","yview","vx","compute","vy","scissor","BLEND","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_ALPHA","ONE","clear_webgl","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","blit_webgl","ctx","restore","drawImage","save","scale","translate","bounds","log_bounds","calculate_log_bounds","r","x_ranges","concat","y_ranges","scale_hint","bds","glyph","log_bds","follow_enabled","has_bounds","match_aspect","aspect_scale","xr","bounds_to_use","update","follow","yr","warn","range_update_timestamp","Date","now","map_to_screen","x","y","x_name","y_name","push_state","type","new_info","prev_info","info","slice","emit","can_undo","can_redo","undo","_do_state_change","redo","range","update_range","update_selection","get_selection","renderer","renderers","selected","data_source","ds","selection_manager","_update_ranges_together","range_info_iter","weight","rng","range_info","min","_get_weight_to_constrain_interval","start","end","_update_ranges_individually","is_panning","is_scrolling","maintain_focus","hit_bound","new_interval","abs","is_reversed","have_updated_interactively","setv","min_interval","max_interval","max_interval2","old_interval","name","xrs","yrs","_invalidate_layout","needs_layout","side_panels","has_size_changed","root","compute_layout","get_renderer_views","computed_renderers","tool","tools","overlay","synthetic_renderers","tool_models","new_tool_views","tool_view","register_tool","connect_signals","connect","change","properties","on_change","set_initial_range","good_vals","has_finished","after_layout","inner_width","round","_width","value","inner_height","_height","outer_width","outer_height","no_change","equals","prepare_canvas","inner_bbox","paint","trace","document","interactive_duration","lod_interval","setTimeout","lod_timeout","interactive_stop","v","set_data_timestamp","_left","_top","_map_hook","_paint_empty","outline_line","doit","set_value","x0","y0","strokeRect","_paint_levels","levels","clip_region","global_clip","level","renderer_view","needs_clip","beginPath","rect","clip","has_webgl","_ctx","_frame_box","cx","cy","cw","ch","fx","fy","fw","fh","clearRect","border_fill","fillRect","background_fill","serializable_state","_a","filter"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { CartesianFrame } from \"../canvas/cartesian_frame\";\nimport { Canvas } from \"../canvas/canvas\";\nimport { DataRange1d } from \"../ranges/data_range1d\";\nimport { GlyphRenderer, GlyphRendererView } from \"../renderers/glyph_renderer\";\nimport { LayoutDOMView } from \"../layouts/layout_dom\";\nimport { Title } from \"../annotations/title\";\nimport { AxisView } from \"../axes/axis\";\nimport { ToolbarPanel } from \"../annotations/toolbar_panel\";\nimport { Reset } from \"../../core/bokeh_events\";\nimport { Signal0 } from \"../../core/signaling\";\nimport { build_view, build_views, remove_views } from \"../../core/build_views\";\nimport { UIEvents } from \"../../core/ui_events\";\nimport { Visuals } from \"../../core/visuals\";\nimport { logger } from \"../../core/logging\";\nimport { throttle } from \"../../core/util/throttle\";\nimport { isArray, isStrictNaN } from \"../../core/util/types\";\nimport { copy, reversed } from \"../../core/util/array\";\nimport { values } from \"../../core/util/object\";\nimport { Sizeable, Layoutable } from \"../../core/layout\";\nimport { HStack, VStack } from \"../../core/layout/alignments\";\nimport { SidePanel } from \"../../core/layout/side_panel\";\nimport { Row, Column } from \"../../core/layout/grid\";\nimport { BBox } from \"../../core/util/bbox\";\nexport class PlotLayout extends Layoutable {\n    constructor() {\n        super(...arguments);\n        this.min_border = { left: 0, top: 0, right: 0, bottom: 0 };\n    }\n    _measure(viewport) {\n        viewport = new Sizeable(viewport).bounded_to(this.sizing.size);\n        const left_hint = this.left_panel.measure({ width: 0, height: viewport.height });\n        const left = Math.max(left_hint.width, this.min_border.left);\n        const right_hint = this.right_panel.measure({ width: 0, height: viewport.height });\n        const right = Math.max(right_hint.width, this.min_border.right);\n        const top_hint = this.top_panel.measure({ width: viewport.width, height: 0 });\n        const top = Math.max(top_hint.height, this.min_border.top);\n        const bottom_hint = this.bottom_panel.measure({ width: viewport.width, height: 0 });\n        const bottom = Math.max(bottom_hint.height, this.min_border.bottom);\n        const center_viewport = new Sizeable(viewport).shrink_by({ left, right, top, bottom });\n        const center = this.center_panel.measure(center_viewport);\n        const width = left + center.width + right;\n        const height = top + center.height + bottom;\n        const align = (() => {\n            const { width_policy, height_policy } = this.center_panel.sizing;\n            return width_policy != \"fixed\" && height_policy != \"fixed\";\n        })();\n        return { width, height, inner: { left, right, top, bottom }, align };\n    }\n    _set_geometry(outer, inner) {\n        super._set_geometry(outer, inner);\n        this.center_panel.set_geometry(inner);\n        const left_hint = this.left_panel.measure({ width: 0, height: outer.height });\n        const right_hint = this.right_panel.measure({ width: 0, height: outer.height });\n        const top_hint = this.top_panel.measure({ width: outer.width, height: 0 });\n        const bottom_hint = this.bottom_panel.measure({ width: outer.width, height: 0 });\n        const { left, top, right, bottom } = inner;\n        this.top_panel.set_geometry(new BBox({ left, right, bottom: top, height: top_hint.height }));\n        this.bottom_panel.set_geometry(new BBox({ left, right, top: bottom, height: bottom_hint.height }));\n        this.left_panel.set_geometry(new BBox({ top, bottom, right: left, width: left_hint.width }));\n        this.right_panel.set_geometry(new BBox({ top, bottom, left: right, width: right_hint.width }));\n    }\n}\nPlotLayout.__name__ = \"PlotLayout\";\nexport class PlotView extends LayoutDOMView {\n    constructor() {\n        super(...arguments);\n        this._outer_bbox = new BBox();\n        this._inner_bbox = new BBox();\n        this._needs_paint = true;\n        this._needs_layout = false;\n    }\n    get is_paused() {\n        return this._is_paused != null && this._is_paused !== 0;\n    }\n    get child_models() {\n        return [];\n    }\n    pause() {\n        if (this._is_paused == null)\n            this._is_paused = 1;\n        else\n            this._is_paused += 1;\n    }\n    unpause(no_render = false) {\n        if (this._is_paused == null)\n            throw new Error(\"wasn't paused\");\n        this._is_paused -= 1;\n        if (this._is_paused == 0 && !no_render)\n            this.request_paint();\n    }\n    // TODO: this needs to be removed\n    request_render() {\n        this.request_paint();\n    }\n    request_paint() {\n        if (!this.is_paused) {\n            const promise = this.throttled_paint();\n            this._ready = this._ready.then(() => promise);\n        }\n    }\n    request_layout() {\n        this._needs_layout = true;\n        this.request_paint();\n    }\n    reset() {\n        if (this.model.reset_policy == \"standard\") {\n            this.clear_state();\n            this.reset_range();\n            this.reset_selection();\n        }\n        this.model.trigger_event(new Reset());\n    }\n    remove() {\n        this.ui_event_bus.destroy();\n        remove_views(this.renderer_views);\n        remove_views(this.tool_views);\n        this.canvas_view.remove();\n        super.remove();\n    }\n    render() {\n        super.render();\n        this.el.appendChild(this.canvas_view.el);\n        this.canvas_view.render();\n    }\n    initialize() {\n        this.pause();\n        super.initialize();\n        this.state_changed = new Signal0(this, \"state_changed\");\n        this.lod_started = false;\n        this.visuals = new Visuals(this.model); // XXX\n        this._initial_state_info = {\n            selection: {},\n            dimensions: { width: 0, height: 0 },\n        };\n        this.visibility_callbacks = [];\n        this.state = { history: [], index: -1 };\n        this.canvas = new Canvas({\n            use_hidpi: this.model.hidpi,\n            output_backend: this.model.output_backend,\n        });\n        this.frame = new CartesianFrame(this.model.x_scale, this.model.y_scale, this.model.x_range, this.model.y_range, this.model.extra_x_ranges, this.model.extra_y_ranges);\n        this.throttled_paint = throttle(() => this.repaint(), 1000 / 60);\n        const { title_location, title } = this.model;\n        if (title_location != null && title != null) {\n            this._title = title instanceof Title ? title : new Title({ text: title });\n        }\n        const { toolbar_location, toolbar } = this.model;\n        if (toolbar_location != null && toolbar != null) {\n            this._toolbar = new ToolbarPanel({ toolbar });\n            toolbar.toolbar_location = toolbar_location;\n        }\n        this.renderer_views = {};\n        this.tool_views = {};\n    }\n    async lazy_initialize() {\n        this.canvas_view = await build_view(this.canvas, { parent: this });\n        this.ui_event_bus = new UIEvents(this, this.model.toolbar, this.canvas_view.events_el);\n        await this.build_renderer_views();\n        await this.build_tool_views();\n        this.update_dataranges();\n        this.unpause(true);\n        logger.debug(\"PlotView initialized\");\n    }\n    _width_policy() {\n        return this.model.frame_width == null ? super._width_policy() : \"min\";\n    }\n    _height_policy() {\n        return this.model.frame_height == null ? super._height_policy() : \"min\";\n    }\n    _update_layout() {\n        this.layout = new PlotLayout();\n        this.layout.set_sizing(this.box_sizing());\n        const { frame_width, frame_height } = this.model;\n        this.layout.center_panel = this.frame;\n        this.layout.center_panel.set_sizing(Object.assign(Object.assign({}, (frame_width != null ? { width_policy: \"fixed\", width: frame_width } : { width_policy: \"fit\" })), (frame_height != null ? { height_policy: \"fixed\", height: frame_height } : { height_policy: \"fit\" })));\n        const above = copy(this.model.above);\n        const below = copy(this.model.below);\n        const left = copy(this.model.left);\n        const right = copy(this.model.right);\n        const get_side = (side) => {\n            switch (side) {\n                case \"above\": return above;\n                case \"below\": return below;\n                case \"left\": return left;\n                case \"right\": return right;\n            }\n        };\n        const { title_location, title } = this.model;\n        if (title_location != null && title != null) {\n            get_side(title_location).push(this._title);\n        }\n        const { toolbar_location, toolbar } = this.model;\n        if (toolbar_location != null && toolbar != null) {\n            const panels = get_side(toolbar_location);\n            let push_toolbar = true;\n            if (this.model.toolbar_sticky) {\n                for (let i = 0; i < panels.length; i++) {\n                    const panel = panels[i];\n                    if (panel instanceof Title) {\n                        if (toolbar_location == \"above\" || toolbar_location == \"below\")\n                            panels[i] = [panel, this._toolbar];\n                        else\n                            panels[i] = [this._toolbar, panel];\n                        push_toolbar = false;\n                        break;\n                    }\n                }\n            }\n            if (push_toolbar)\n                panels.push(this._toolbar);\n        }\n        const set_layout = (side, model) => {\n            const view = this.renderer_views[model.id];\n            return view.layout = new SidePanel(side, view);\n        };\n        const set_layouts = (side, panels) => {\n            const horizontal = side == \"above\" || side == \"below\";\n            const layouts = [];\n            for (const panel of panels) {\n                if (isArray(panel)) {\n                    const items = panel.map((subpanel) => {\n                        const item = set_layout(side, subpanel);\n                        if (subpanel instanceof ToolbarPanel) {\n                            const dim = horizontal ? \"width_policy\" : \"height_policy\";\n                            item.set_sizing(Object.assign(Object.assign({}, item.sizing), { [dim]: \"min\" }));\n                        }\n                        return item;\n                    });\n                    let layout;\n                    if (horizontal) {\n                        layout = new Row(items);\n                        layout.set_sizing({ width_policy: \"max\", height_policy: \"min\" });\n                    }\n                    else {\n                        layout = new Column(items);\n                        layout.set_sizing({ width_policy: \"min\", height_policy: \"max\" });\n                    }\n                    layout.absolute = true;\n                    layouts.push(layout);\n                }\n                else\n                    layouts.push(set_layout(side, panel));\n            }\n            return layouts;\n        };\n        const min_border = this.model.min_border != null ? this.model.min_border : 0;\n        this.layout.min_border = {\n            left: this.model.min_border_left != null ? this.model.min_border_left : min_border,\n            top: this.model.min_border_top != null ? this.model.min_border_top : min_border,\n            right: this.model.min_border_right != null ? this.model.min_border_right : min_border,\n            bottom: this.model.min_border_bottom != null ? this.model.min_border_bottom : min_border,\n        };\n        const top_panel = new VStack();\n        const bottom_panel = new VStack();\n        const left_panel = new HStack();\n        const right_panel = new HStack();\n        top_panel.children = reversed(set_layouts(\"above\", above));\n        bottom_panel.children = set_layouts(\"below\", below);\n        left_panel.children = reversed(set_layouts(\"left\", left));\n        right_panel.children = set_layouts(\"right\", right);\n        top_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_border.top*/ });\n        bottom_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_width.bottom*/ });\n        left_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.left*/ });\n        right_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.right*/ });\n        this.layout.top_panel = top_panel;\n        this.layout.bottom_panel = bottom_panel;\n        this.layout.left_panel = left_panel;\n        this.layout.right_panel = right_panel;\n    }\n    get axis_views() {\n        const views = [];\n        for (const id in this.renderer_views) {\n            const child_view = this.renderer_views[id];\n            if (child_view instanceof AxisView)\n                views.push(child_view);\n        }\n        return views;\n    }\n    set_cursor(cursor = \"default\") {\n        this.canvas_view.el.style.cursor = cursor;\n    }\n    set_toolbar_visibility(visible) {\n        for (const callback of this.visibility_callbacks)\n            callback(visible);\n    }\n    prepare_webgl(ratio, frame_box) {\n        // Prepare WebGL for a drawing pass\n        const { webgl } = this.canvas_view;\n        if (webgl != null) {\n            // Sync canvas size\n            const { width, height } = this.canvas_view.bbox;\n            const { pixel_ratio } = this.canvas_view.model;\n            webgl.canvas.width = pixel_ratio * width;\n            webgl.canvas.height = pixel_ratio * height;\n            const { gl } = webgl;\n            // Clipping\n            gl.enable(gl.SCISSOR_TEST);\n            const [sx, sy, w, h] = frame_box;\n            const { xview, yview } = this.canvas_view.bbox;\n            const vx = xview.compute(sx);\n            const vy = yview.compute(sy + h);\n            gl.scissor(ratio * vx, ratio * vy, ratio * w, ratio * h); // lower left corner, width, height\n            // Setup blending\n            gl.enable(gl.BLEND);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE); // premultipliedAlpha == true\n        }\n    }\n    clear_webgl() {\n        const { webgl } = this.canvas_view;\n        if (webgl != null) {\n            // Prepare GL for drawing\n            const { gl, canvas } = webgl;\n            gl.viewport(0, 0, canvas.width, canvas.height);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\n        }\n    }\n    blit_webgl() {\n        // This should be called when the ctx has no state except the HIDPI transform\n        const { ctx, webgl } = this.canvas_view;\n        if (webgl != null) {\n            // Blit gl canvas into the 2D canvas. To do 1-on-1 blitting, we need\n            // to remove the hidpi transform, then blit, then restore.\n            // ctx.globalCompositeOperation = \"source-over\"  -> OK; is the default\n            logger.debug('drawing with WebGL');\n            ctx.restore();\n            ctx.drawImage(webgl.canvas, 0, 0);\n            // Set back hidpi transform\n            ctx.save();\n            if (this.model.hidpi) {\n                const ratio = this.canvas.pixel_ratio;\n                ctx.scale(ratio, ratio);\n                ctx.translate(0.5, 0.5);\n            }\n        }\n    }\n    update_dataranges() {\n        // Update any DataRange1ds here\n        const bounds = {};\n        const log_bounds = {};\n        let calculate_log_bounds = false;\n        for (const r of values(this.frame.x_ranges).concat(values(this.frame.y_ranges))) {\n            if (r instanceof DataRange1d) {\n                if (r.scale_hint == \"log\")\n                    calculate_log_bounds = true;\n            }\n        }\n        for (const id in this.renderer_views) {\n            const view = this.renderer_views[id];\n            if (view instanceof GlyphRendererView) {\n                const bds = view.glyph.bounds();\n                if (bds != null)\n                    bounds[id] = bds;\n                if (calculate_log_bounds) {\n                    const log_bds = view.glyph.log_bounds();\n                    if (log_bds != null)\n                        log_bounds[id] = log_bds;\n                }\n            }\n        }\n        let follow_enabled = false;\n        let has_bounds = false;\n        const { width, height } = this.frame.bbox;\n        let r;\n        if (this.model.match_aspect !== false && width != 0 && height != 0)\n            r = (1 / this.model.aspect_scale) * (width / height);\n        for (const xr of values(this.frame.x_ranges)) {\n            if (xr instanceof DataRange1d) {\n                const bounds_to_use = xr.scale_hint == \"log\" ? log_bounds : bounds;\n                xr.update(bounds_to_use, 0, this.model.id, r);\n                if (xr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (xr.bounds != null)\n                has_bounds = true;\n        }\n        for (const yr of values(this.frame.y_ranges)) {\n            if (yr instanceof DataRange1d) {\n                const bounds_to_use = yr.scale_hint == \"log\" ? log_bounds : bounds;\n                yr.update(bounds_to_use, 1, this.model.id, r);\n                if (yr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (yr.bounds != null)\n                has_bounds = true;\n        }\n        if (follow_enabled && has_bounds) {\n            logger.warn('Follow enabled so bounds are unset.');\n            for (const xr of values(this.frame.x_ranges)) {\n                xr.bounds = null;\n            }\n            for (const yr of values(this.frame.y_ranges)) {\n                yr.bounds = null;\n            }\n        }\n        this.range_update_timestamp = Date.now();\n    }\n    map_to_screen(x, y, x_name = \"default\", y_name = \"default\") {\n        return this.frame.map_to_screen(x, y, x_name, y_name);\n    }\n    push_state(type, new_info) {\n        const { history, index } = this.state;\n        const prev_info = history[index] != null ? history[index].info : {};\n        const info = Object.assign(Object.assign(Object.assign({}, this._initial_state_info), prev_info), new_info);\n        this.state.history = this.state.history.slice(0, this.state.index + 1);\n        this.state.history.push({ type, info });\n        this.state.index = this.state.history.length - 1;\n        this.state_changed.emit();\n    }\n    clear_state() {\n        this.state = { history: [], index: -1 };\n        this.state_changed.emit();\n    }\n    can_undo() {\n        return this.state.index >= 0;\n    }\n    can_redo() {\n        return this.state.index < this.state.history.length - 1;\n    }\n    undo() {\n        if (this.can_undo()) {\n            this.state.index -= 1;\n            this._do_state_change(this.state.index);\n            this.state_changed.emit();\n        }\n    }\n    redo() {\n        if (this.can_redo()) {\n            this.state.index += 1;\n            this._do_state_change(this.state.index);\n            this.state_changed.emit();\n        }\n    }\n    _do_state_change(index) {\n        const info = this.state.history[index] != null ? this.state.history[index].info : this._initial_state_info;\n        if (info.range != null)\n            this.update_range(info.range);\n        if (info.selection != null)\n            this.update_selection(info.selection);\n    }\n    get_selection() {\n        const selection = {};\n        for (const renderer of this.model.renderers) {\n            if (renderer instanceof GlyphRenderer) {\n                const { selected } = renderer.data_source;\n                selection[renderer.id] = selected;\n            }\n        }\n        return selection;\n    }\n    update_selection(selection) {\n        for (const renderer of this.model.renderers) {\n            if (!(renderer instanceof GlyphRenderer))\n                continue;\n            const ds = renderer.data_source;\n            if (selection != null) {\n                if (selection[renderer.id] != null)\n                    ds.selected.update(selection[renderer.id], true, false);\n            }\n            else\n                ds.selection_manager.clear();\n        }\n    }\n    reset_selection() {\n        this.update_selection(null);\n    }\n    _update_ranges_together(range_info_iter) {\n        // Get weight needed to scale the diff of the range to honor interval limits\n        let weight = 1.0;\n        for (const [rng, range_info] of range_info_iter) {\n            weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\n        }\n        // Apply shared weight to all ranges\n        if (weight < 1) {\n            for (const [rng, range_info] of range_info_iter) {\n                range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n                range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n            }\n        }\n    }\n    _update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus) {\n        let hit_bound = false;\n        for (const [rng, range_info] of range_info_iter) {\n            // Limit range interval first. Note that for scroll events,\n            // the interval has already been limited for all ranges simultaneously\n            if (!is_scrolling) {\n                const weight = this._get_weight_to_constrain_interval(rng, range_info);\n                if (weight < 1) {\n                    range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n                    range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n                }\n            }\n            // Prevent range from going outside limits\n            // Also ensure that range keeps the same delta when panning/scrolling\n            if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\n                const [min, max] = rng.bounds;\n                const new_interval = Math.abs(range_info.end - range_info.start);\n                if (rng.is_reversed) {\n                    if (min != null) {\n                        if (min >= range_info.end) {\n                            hit_bound = true;\n                            range_info.end = min;\n                            if (is_panning || is_scrolling) {\n                                range_info.start = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info.start) {\n                            hit_bound = true;\n                            range_info.start = max;\n                            if (is_panning || is_scrolling) {\n                                range_info.end = max - new_interval;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (min != null) {\n                        if (min >= range_info.start) {\n                            hit_bound = true;\n                            range_info.start = min;\n                            if (is_panning || is_scrolling) {\n                                range_info.end = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info.end) {\n                            hit_bound = true;\n                            range_info.end = max;\n                            if (is_panning || is_scrolling) {\n                                range_info.start = max - new_interval;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Cancel the event when hitting a bound while scrolling. This ensures that\n        // the scroll-zoom tool maintains its focus position. Setting `maintain_focus`\n        // to false results in a more \"gliding\" behavior, allowing one to\n        // zoom out more smoothly, at the cost of losing the focus position.\n        if (is_scrolling && hit_bound && maintain_focus)\n            return;\n        for (const [rng, range_info] of range_info_iter) {\n            rng.have_updated_interactively = true;\n            if (rng.start != range_info.start || rng.end != range_info.end)\n                rng.setv(range_info);\n        }\n    }\n    _get_weight_to_constrain_interval(rng, range_info) {\n        // Get the weight by which a range-update can be applied\n        // to still honor the interval limits (including the implicit\n        // max interval imposed by the bounds)\n        const { min_interval } = rng;\n        let { max_interval } = rng;\n        // Express bounds as a max_interval. By doing this, the application of\n        // bounds and interval limits can be applied independent from each-other.\n        if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\n            const [min, max] = rng.bounds;\n            if (min != null && max != null) {\n                const max_interval2 = Math.abs(max - min);\n                max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\n            }\n        }\n        let weight = 1.0;\n        if (min_interval != null || max_interval != null) {\n            const old_interval = Math.abs(rng.end - rng.start);\n            const new_interval = Math.abs(range_info.end - range_info.start);\n            if (min_interval > 0 && new_interval < min_interval) {\n                weight = (old_interval - min_interval) / (old_interval - new_interval);\n            }\n            if (max_interval > 0 && new_interval > max_interval) {\n                weight = (max_interval - old_interval) / (new_interval - old_interval);\n            }\n            weight = Math.max(0.0, Math.min(1.0, weight));\n        }\n        return weight;\n    }\n    update_range(range_info, is_panning = false, is_scrolling = false, maintain_focus = true) {\n        this.pause();\n        const { x_ranges, y_ranges } = this.frame;\n        if (range_info == null) {\n            for (const name in x_ranges) {\n                const rng = x_ranges[name];\n                rng.reset();\n            }\n            for (const name in y_ranges) {\n                const rng = y_ranges[name];\n                rng.reset();\n            }\n            this.update_dataranges();\n        }\n        else {\n            const range_info_iter = [];\n            for (const name in x_ranges) {\n                const rng = x_ranges[name];\n                range_info_iter.push([rng, range_info.xrs[name]]);\n            }\n            for (const name in y_ranges) {\n                const rng = y_ranges[name];\n                range_info_iter.push([rng, range_info.yrs[name]]);\n            }\n            if (is_scrolling) {\n                this._update_ranges_together(range_info_iter); // apply interval bounds while keeping aspect\n            }\n            this._update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus);\n        }\n        this.unpause();\n    }\n    reset_range() {\n        this.update_range(null);\n    }\n    _invalidate_layout() {\n        const needs_layout = () => {\n            for (const panel of this.model.side_panels) {\n                const view = this.renderer_views[panel.id];\n                if (view.layout.has_size_changed())\n                    return true;\n            }\n            return false;\n        };\n        if (needs_layout())\n            this.root.compute_layout();\n    }\n    get_renderer_views() {\n        return this.computed_renderers.map((r) => this.renderer_views[r.id]);\n    }\n    async build_renderer_views() {\n        this.computed_renderers = [];\n        const { above, below, left, right, center, renderers } = this.model;\n        this.computed_renderers.push(...above, ...below, ...left, ...right, ...center, ...renderers);\n        if (this._title != null)\n            this.computed_renderers.push(this._title);\n        if (this._toolbar != null)\n            this.computed_renderers.push(this._toolbar);\n        for (const tool of this.model.toolbar.tools) {\n            if (tool.overlay != null)\n                this.computed_renderers.push(tool.overlay);\n            this.computed_renderers.push(...tool.synthetic_renderers);\n        }\n        await build_views(this.renderer_views, this.computed_renderers, { parent: this });\n    }\n    async build_tool_views() {\n        const tool_models = this.model.toolbar.tools;\n        const new_tool_views = await build_views(this.tool_views, tool_models, { parent: this });\n        new_tool_views.map((tool_view) => this.ui_event_bus.register_tool(tool_view));\n    }\n    connect_signals() {\n        super.connect_signals();\n        const { x_ranges, y_ranges } = this.frame;\n        for (const name in x_ranges) {\n            const rng = x_ranges[name];\n            this.connect(rng.change, () => { this._needs_layout = true; this.request_paint(); });\n        }\n        for (const name in y_ranges) {\n            const rng = y_ranges[name];\n            this.connect(rng.change, () => { this._needs_layout = true; this.request_paint(); });\n        }\n        const { above, below, left, right, center, renderers } = this.model.properties;\n        this.on_change([above, below, left, right, center, renderers], async () => await this.build_renderer_views());\n        this.connect(this.model.toolbar.properties.tools.change, async () => {\n            await this.build_renderer_views();\n            await this.build_tool_views();\n        });\n        this.connect(this.model.change, () => this.request_paint());\n        this.connect(this.model.reset, () => this.reset());\n    }\n    set_initial_range() {\n        // check for good values for ranges before setting initial range\n        let good_vals = true;\n        const { x_ranges, y_ranges } = this.frame;\n        const xrs = {};\n        const yrs = {};\n        for (const name in x_ranges) {\n            const { start, end } = x_ranges[name];\n            if (start == null || end == null || isStrictNaN(start + end)) {\n                good_vals = false;\n                break;\n            }\n            xrs[name] = { start, end };\n        }\n        if (good_vals) {\n            for (const name in y_ranges) {\n                const { start, end } = y_ranges[name];\n                if (start == null || end == null || isStrictNaN(start + end)) {\n                    good_vals = false;\n                    break;\n                }\n                yrs[name] = { start, end };\n            }\n        }\n        if (good_vals) {\n            this._initial_state_info.range = { xrs, yrs };\n            logger.debug(\"initial ranges set\");\n        }\n        else\n            logger.warn('could not set initial ranges');\n    }\n    has_finished() {\n        if (!super.has_finished())\n            return false;\n        for (const id in this.renderer_views) {\n            const view = this.renderer_views[id];\n            if (!view.has_finished())\n                return false;\n        }\n        return true;\n    }\n    after_layout() {\n        super.after_layout();\n        this._needs_layout = false;\n        this.model.setv({\n            inner_width: Math.round(this.frame._width.value),\n            inner_height: Math.round(this.frame._height.value),\n            outer_width: Math.round(this.layout._width.value),\n            outer_height: Math.round(this.layout._height.value),\n        }, { no_change: true });\n        if (this.model.match_aspect !== false) {\n            this.pause();\n            this.update_dataranges();\n            this.unpause(true);\n        }\n        if (!this._outer_bbox.equals(this.layout.bbox)) {\n            const { width, height } = this.layout.bbox;\n            this.canvas_view.prepare_canvas(width, height);\n            this._outer_bbox = this.layout.bbox;\n            this._needs_paint = true;\n        }\n        if (!this._inner_bbox.equals(this.frame.inner_bbox)) {\n            this._inner_bbox = this.layout.inner_bbox;\n            this._needs_paint = true;\n        }\n        if (this._needs_paint) {\n            // XXX: can't be this.request_paint(), because it would trigger back-and-forth\n            // layout recomputing feedback loop between plots. Plots are also much more\n            // responsive this way, especially in interactive mode.\n            this._needs_paint = false;\n            this.paint();\n        }\n    }\n    repaint() {\n        if (this._needs_layout)\n            this._invalidate_layout();\n        this.paint();\n    }\n    paint() {\n        if (this.is_paused)\n            return;\n        logger.trace(`PlotView.paint() for ${this.model.id}`);\n        const { document } = this.model;\n        if (document != null) {\n            const interactive_duration = document.interactive_duration();\n            if (interactive_duration >= 0 && interactive_duration < this.model.lod_interval) {\n                setTimeout(() => {\n                    if (document.interactive_duration() > this.model.lod_timeout) {\n                        document.interactive_stop(this.model);\n                    }\n                    this.request_paint();\n                }, this.model.lod_timeout);\n            }\n            else\n                document.interactive_stop(this.model);\n        }\n        for (const id in this.renderer_views) {\n            const v = this.renderer_views[id];\n            if (this.range_update_timestamp == null ||\n                (v instanceof GlyphRendererView && v.set_data_timestamp > this.range_update_timestamp)) {\n                this.update_dataranges();\n                break;\n            }\n        }\n        const { ctx } = this.canvas_view;\n        const ratio = this.canvas.pixel_ratio;\n        // Set hidpi-transform\n        ctx.save(); // Save default state, do *after* getting ratio, cause setting canvas.width resets transforms\n        if (this.model.hidpi) {\n            ctx.scale(ratio, ratio);\n            ctx.translate(0.5, 0.5);\n        }\n        const frame_box = [\n            this.frame._left.value,\n            this.frame._top.value,\n            this.frame._width.value,\n            this.frame._height.value,\n        ];\n        this._map_hook(ctx, frame_box);\n        this._paint_empty(ctx, frame_box);\n        this.prepare_webgl(ratio, frame_box);\n        this.clear_webgl();\n        if (this.visuals.outline_line.doit) {\n            ctx.save();\n            this.visuals.outline_line.set_value(ctx);\n            let [x0, y0, w, h] = frame_box;\n            // XXX: shrink outline region by 1px to make right and bottom lines visible\n            // if they are on the edge of the canvas.\n            if (x0 + w == this.layout._width.value) {\n                w -= 1;\n            }\n            if (y0 + h == this.layout._height.value) {\n                h -= 1;\n            }\n            ctx.strokeRect(x0, y0, w, h);\n            ctx.restore();\n        }\n        this._paint_levels(ctx, ['image', 'underlay', 'glyph'], frame_box, true);\n        this._paint_levels(ctx, ['annotation'], frame_box, false);\n        this._paint_levels(ctx, ['overlay'], frame_box, false);\n        if (this._initial_state_info.range == null)\n            this.set_initial_range();\n        ctx.restore(); // Restore to default state\n    }\n    _paint_levels(ctx, levels, clip_region, global_clip) {\n        for (const level of levels) {\n            for (const renderer of this.computed_renderers) {\n                if (renderer.level != level)\n                    continue;\n                const renderer_view = this.renderer_views[renderer.id];\n                ctx.save();\n                if (global_clip || renderer_view.needs_clip) {\n                    ctx.beginPath();\n                    ctx.rect(...clip_region);\n                    ctx.clip();\n                }\n                renderer_view.render();\n                ctx.restore();\n                if (renderer_view.has_webgl) {\n                    this.blit_webgl();\n                    this.clear_webgl();\n                }\n            }\n        }\n    }\n    _map_hook(_ctx, _frame_box) { }\n    _paint_empty(ctx, frame_box) {\n        const [cx, cy, cw, ch] = [0, 0, this.layout._width.value, this.layout._height.value];\n        const [fx, fy, fw, fh] = frame_box;\n        ctx.clearRect(cx, cy, cw, ch);\n        if (this.visuals.border_fill.doit) {\n            this.visuals.border_fill.set_value(ctx);\n            ctx.fillRect(cx, cy, cw, ch);\n            ctx.clearRect(fx, fy, fw, fh);\n        }\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fillRect(fx, fy, fw, fh);\n        }\n    }\n    save(name) {\n        this.canvas_view.save(name);\n    }\n    serializable_state() {\n        const _a = super.serializable_state(), { children } = _a, state = __rest(_a, [\"children\"]);\n        const renderers = this.get_renderer_views()\n            .map((view) => view.serializable_state())\n            .filter((item) => \"bbox\" in item);\n        return Object.assign(Object.assign({}, state), { children: [...children, ...renderers] }); // XXX\n    }\n}\nPlotView.__name__ = \"PlotView\";\n//# sourceMappingURL=plot_canvas.js.map"]},"metadata":{},"sourceType":"module"}