{"ast":null,"code":"import tz from \"timezone\";\nimport { TickFormatter } from \"./tick_formatter\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { sprintf } from \"../../core/util/templating\";\nimport { zip, unzip, sort_by } from \"../../core/util/array\";\nimport { isFunction } from \"../../core/util/types\";\n\nfunction _us(t) {\n  // From double-precision unix (millisecond) timestamp get\n  // microsecond since last second. Precision seems to run\n  // out around the hundreds of nanoseconds scale, so rounding\n  // to the nearest microsecond should round to a nice\n  // microsecond / millisecond tick.\n  return Math.round(t / 1000 % 1 * 1000000);\n}\n\nfunction _array(t) {\n  return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(e => parseInt(e, 10));\n}\n\nfunction _strftime(t, format) {\n  if (isFunction(format)) {\n    return format(t);\n  } else {\n    // Python's datetime library augments the microsecond directive %f, which is not\n    // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.\n    // Use a regular expression to replace %f directive with microseconds.\n    // TODO: what should we do for negative microsecond strings?\n    const microsecond_replacement_string = sprintf(\"$1%06d\", _us(t));\n    format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\n\n    if (format.indexOf(\"%\") == -1) {\n      // timezone seems to ignore any strings without any formatting directives,\n      // and just return the time argument back instead of the string argument.\n      // But we want the string argument, in case a user supplies a format string\n      // which doesn't contain a formatting directive or is only using %f.\n      return format;\n    }\n\n    return tz(t, format);\n  }\n} // Labels of time units, from finest to coarsest.\n\n\nconst format_order = ['microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years'];\nexport class DatetimeTickFormatter extends TickFormatter {\n  constructor(attrs) {\n    super(attrs); // Whether or not to strip the leading zeros on tick labels.\n\n    this.strip_leading_zeros = true;\n  }\n\n  static init_DatetimeTickFormatter() {\n    this.define({\n      microseconds: [p.Array, ['%fus']],\n      milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\n      seconds: [p.Array, ['%Ss']],\n      minsec: [p.Array, [':%M:%S']],\n      minutes: [p.Array, [':%M', '%Mm']],\n      hourmin: [p.Array, ['%H:%M']],\n      hours: [p.Array, ['%Hh', '%H:%M']],\n      days: [p.Array, ['%m/%d', '%a%d']],\n      months: [p.Array, ['%m/%Y', '%b %Y']],\n      years: [p.Array, ['%Y']]\n    });\n  }\n\n  initialize() {\n    super.initialize(); // TODO (bev) trigger update on format change\n\n    this._update_width_formats();\n  }\n\n  _update_width_formats() {\n    const now = +tz(new Date());\n\n    const _widths = function (fmt_strings) {\n      const sizes = fmt_strings.map(fmt_string => _strftime(now, fmt_string).length);\n      const sorted = sort_by(zip(sizes, fmt_strings), ([size]) => size);\n      return unzip(sorted);\n    };\n\n    this._width_formats = {\n      microseconds: _widths(this.microseconds),\n      milliseconds: _widths(this.milliseconds),\n      seconds: _widths(this.seconds),\n      minsec: _widths(this.minsec),\n      minutes: _widths(this.minutes),\n      hourmin: _widths(this.hourmin),\n      hours: _widths(this.hours),\n      days: _widths(this.days),\n      months: _widths(this.months),\n      years: _widths(this.years)\n    };\n  } // FIXME There is some unfortunate flicker when panning/zooming near the\n  // span boundaries.\n  // FIXME Rounding is weird at the 20-us scale and below.\n\n\n  _get_resolution_str(resolution_secs, span_secs) {\n    // Our resolution boundaries should not be round numbers, because we want\n    // them to fall between the possible tick intervals (which *are* round\n    // numbers, as we've worked hard to ensure).  Consequently, we adjust the\n    // resolution upwards a small amount (less than any possible step in\n    // scales) to make the effective boundaries slightly lower.\n    const adjusted_secs = resolution_secs * 1.1;\n\n    switch (false) {\n      case !(adjusted_secs < 1e-3):\n        return \"microseconds\";\n\n      case !(adjusted_secs < 1.0):\n        return \"milliseconds\";\n\n      case !(adjusted_secs < 60):\n        return span_secs >= 60 ? \"minsec\" : \"seconds\";\n\n      case !(adjusted_secs < 3600):\n        return span_secs >= 3600 ? \"hourmin\" : \"minutes\";\n\n      case !(adjusted_secs < 24 * 3600):\n        return \"hours\";\n\n      case !(adjusted_secs < 31 * 24 * 3600):\n        return \"days\";\n\n      case !(adjusted_secs < 365 * 24 * 3600):\n        return \"months\";\n\n      default:\n        return \"years\";\n    }\n  }\n\n  doFormat(ticks, _opts) {\n    // In order to pick the right set of labels, we need to determine\n    // the resolution of the ticks.  We can do this using a ticker if\n    // it's provided, or by computing the resolution from the actual\n    // ticks we've been given.\n    if (ticks.length == 0) return [];\n    const span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\n    const r = span / (ticks.length - 1);\n\n    const resol = this._get_resolution_str(r, span);\n\n    const [, [format]] = this._width_formats[resol]; // Apply the format to the tick values\n\n    const labels = [];\n    const resol_ndx = format_order.indexOf(resol); // This dictionary maps the name of a time resolution (in @format_order)\n    // to its index in a time.localtime() timetuple.  The default is to map\n    // everything to index 0, which is year.  This is not ideal; it might cause\n    // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly\n    // promoted at certain tick resolutions.\n\n    const time_tuple_ndx_for_resol = {};\n\n    for (const fmt of format_order) {\n      time_tuple_ndx_for_resol[fmt] = 0;\n    }\n\n    time_tuple_ndx_for_resol.seconds = 5;\n    time_tuple_ndx_for_resol.minsec = 4;\n    time_tuple_ndx_for_resol.minutes = 4;\n    time_tuple_ndx_for_resol.hourmin = 3;\n    time_tuple_ndx_for_resol.hours = 3; // As we format each tick, check to see if we are at a boundary of the\n    // next higher unit of time.  If so, replace the current format with one\n    // from that resolution.  This is not the best heuristic in the world,\n    // but it works!  There is some trickiness here due to having to deal\n    // with hybrid formats in a reasonable manner.\n\n    for (const t of ticks) {\n      let s, tm;\n\n      try {\n        tm = _array(t);\n        s = _strftime(t, format);\n      } catch (error) {\n        logger.warn(`unable to format tick for timestamp value ${t}`);\n        logger.warn(` - ${error}`);\n        labels.push(\"ERR\");\n        continue;\n      }\n\n      let hybrid_handled = false;\n      let next_ndx = resol_ndx; // The way to check that we are at the boundary of the next unit of\n      // time is by checking that we have 0 units of the resolution, i.e.\n      // we are at zero minutes, so display hours, or we are at zero seconds,\n      // so display minutes (and if that is zero as well, then display hours).\n\n      while (tm[time_tuple_ndx_for_resol[format_order[next_ndx]]] == 0) {\n        let next_format;\n        next_ndx += 1;\n        if (next_ndx == format_order.length) break;\n\n        if ((resol == \"minsec\" || resol == \"hourmin\") && !hybrid_handled) {\n          if (resol == \"minsec\" && tm[4] == 0 && tm[5] != 0 || resol == \"hourmin\" && tm[3] == 0 && tm[4] != 0) {\n            next_format = this._width_formats[format_order[resol_ndx - 1]][1][0];\n            s = _strftime(t, next_format);\n            break;\n          } else {\n            hybrid_handled = true;\n          }\n        }\n\n        next_format = this._width_formats[format_order[next_ndx]][1][0];\n        s = _strftime(t, next_format);\n      } // TODO: should expose this in api. %H, %d, etc use leading zeros and\n      // users might prefer to see them lined up correctly.\n\n\n      if (this.strip_leading_zeros) {\n        let ss = s.replace(/^0+/g, \"\");\n\n        if (ss != s && isNaN(parseInt(ss))) {\n          // If the string can now be parsed as starting with an integer, then\n          // leave all zeros stripped, otherwise start with a zero. Hence:\n          // A label such as '000ms' should leave one zero.\n          // A label such as '001ms' or '0-1ms' should not leave a leading zero.\n          ss = `0${ss}`;\n        }\n\n        labels.push(ss);\n      } else labels.push(s);\n    }\n\n    return labels;\n  }\n\n}\nDatetimeTickFormatter.__name__ = \"DatetimeTickFormatter\";\nDatetimeTickFormatter.init_DatetimeTickFormatter();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/datetime_tick_formatter.js"],"names":["tz","TickFormatter","logger","p","sprintf","zip","unzip","sort_by","isFunction","_us","t","Math","round","_array","split","map","e","parseInt","_strftime","format","microsecond_replacement_string","replace","indexOf","format_order","DatetimeTickFormatter","constructor","attrs","strip_leading_zeros","init_DatetimeTickFormatter","define","microseconds","Array","milliseconds","seconds","minsec","minutes","hourmin","hours","days","months","years","initialize","_update_width_formats","now","Date","_widths","fmt_strings","sizes","fmt_string","length","sorted","size","_width_formats","_get_resolution_str","resolution_secs","span_secs","adjusted_secs","doFormat","ticks","_opts","span","abs","r","resol","labels","resol_ndx","time_tuple_ndx_for_resol","fmt","s","tm","error","warn","push","hybrid_handled","next_ndx","next_format","ss","isNaN","__name__"],"mappings":"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","sourcesContent":["import tz from \"timezone\";\nimport { TickFormatter } from \"./tick_formatter\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { sprintf } from \"../../core/util/templating\";\nimport { zip, unzip, sort_by } from \"../../core/util/array\";\nimport { isFunction } from \"../../core/util/types\";\nfunction _us(t) {\n    // From double-precision unix (millisecond) timestamp get\n    // microsecond since last second. Precision seems to run\n    // out around the hundreds of nanoseconds scale, so rounding\n    // to the nearest microsecond should round to a nice\n    // microsecond / millisecond tick.\n    return Math.round(((t / 1000) % 1) * 1000000);\n}\nfunction _array(t) {\n    return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(e => parseInt(e, 10));\n}\nfunction _strftime(t, format) {\n    if (isFunction(format)) {\n        return format(t);\n    }\n    else {\n        // Python's datetime library augments the microsecond directive %f, which is not\n        // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.\n        // Use a regular expression to replace %f directive with microseconds.\n        // TODO: what should we do for negative microsecond strings?\n        const microsecond_replacement_string = sprintf(\"$1%06d\", _us(t));\n        format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\n        if (format.indexOf(\"%\") == -1) {\n            // timezone seems to ignore any strings without any formatting directives,\n            // and just return the time argument back instead of the string argument.\n            // But we want the string argument, in case a user supplies a format string\n            // which doesn't contain a formatting directive or is only using %f.\n            return format;\n        }\n        return tz(t, format);\n    }\n}\n// Labels of time units, from finest to coarsest.\nconst format_order = [\n    'microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years',\n];\nexport class DatetimeTickFormatter extends TickFormatter {\n    constructor(attrs) {\n        super(attrs);\n        // Whether or not to strip the leading zeros on tick labels.\n        this.strip_leading_zeros = true;\n    }\n    static init_DatetimeTickFormatter() {\n        this.define({\n            microseconds: [p.Array, ['%fus']],\n            milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\n            seconds: [p.Array, ['%Ss']],\n            minsec: [p.Array, [':%M:%S']],\n            minutes: [p.Array, [':%M', '%Mm']],\n            hourmin: [p.Array, ['%H:%M']],\n            hours: [p.Array, ['%Hh', '%H:%M']],\n            days: [p.Array, ['%m/%d', '%a%d']],\n            months: [p.Array, ['%m/%Y', '%b %Y']],\n            years: [p.Array, ['%Y']],\n        });\n    }\n    initialize() {\n        super.initialize();\n        // TODO (bev) trigger update on format change\n        this._update_width_formats();\n    }\n    _update_width_formats() {\n        const now = +tz(new Date());\n        const _widths = function (fmt_strings) {\n            const sizes = fmt_strings.map((fmt_string) => _strftime(now, fmt_string).length);\n            const sorted = sort_by(zip(sizes, fmt_strings), ([size]) => size);\n            return unzip(sorted);\n        };\n        this._width_formats = {\n            microseconds: _widths(this.microseconds),\n            milliseconds: _widths(this.milliseconds),\n            seconds: _widths(this.seconds),\n            minsec: _widths(this.minsec),\n            minutes: _widths(this.minutes),\n            hourmin: _widths(this.hourmin),\n            hours: _widths(this.hours),\n            days: _widths(this.days),\n            months: _widths(this.months),\n            years: _widths(this.years),\n        };\n    }\n    // FIXME There is some unfortunate flicker when panning/zooming near the\n    // span boundaries.\n    // FIXME Rounding is weird at the 20-us scale and below.\n    _get_resolution_str(resolution_secs, span_secs) {\n        // Our resolution boundaries should not be round numbers, because we want\n        // them to fall between the possible tick intervals (which *are* round\n        // numbers, as we've worked hard to ensure).  Consequently, we adjust the\n        // resolution upwards a small amount (less than any possible step in\n        // scales) to make the effective boundaries slightly lower.\n        const adjusted_secs = resolution_secs * 1.1;\n        switch (false) {\n            case !(adjusted_secs < 1e-3): return \"microseconds\";\n            case !(adjusted_secs < 1.0): return \"milliseconds\";\n            case !(adjusted_secs < 60): return span_secs >= 60 ? \"minsec\" : \"seconds\";\n            case !(adjusted_secs < 3600): return span_secs >= 3600 ? \"hourmin\" : \"minutes\";\n            case !(adjusted_secs < (24 * 3600)): return \"hours\";\n            case !(adjusted_secs < (31 * 24 * 3600)): return \"days\";\n            case !(adjusted_secs < (365 * 24 * 3600)): return \"months\";\n            default: return \"years\";\n        }\n    }\n    doFormat(ticks, _opts) {\n        // In order to pick the right set of labels, we need to determine\n        // the resolution of the ticks.  We can do this using a ticker if\n        // it's provided, or by computing the resolution from the actual\n        // ticks we've been given.\n        if (ticks.length == 0)\n            return [];\n        const span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\n        const r = span / (ticks.length - 1);\n        const resol = this._get_resolution_str(r, span);\n        const [, [format]] = this._width_formats[resol];\n        // Apply the format to the tick values\n        const labels = [];\n        const resol_ndx = format_order.indexOf(resol);\n        // This dictionary maps the name of a time resolution (in @format_order)\n        // to its index in a time.localtime() timetuple.  The default is to map\n        // everything to index 0, which is year.  This is not ideal; it might cause\n        // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly\n        // promoted at certain tick resolutions.\n        const time_tuple_ndx_for_resol = {};\n        for (const fmt of format_order) {\n            time_tuple_ndx_for_resol[fmt] = 0;\n        }\n        time_tuple_ndx_for_resol.seconds = 5;\n        time_tuple_ndx_for_resol.minsec = 4;\n        time_tuple_ndx_for_resol.minutes = 4;\n        time_tuple_ndx_for_resol.hourmin = 3;\n        time_tuple_ndx_for_resol.hours = 3;\n        // As we format each tick, check to see if we are at a boundary of the\n        // next higher unit of time.  If so, replace the current format with one\n        // from that resolution.  This is not the best heuristic in the world,\n        // but it works!  There is some trickiness here due to having to deal\n        // with hybrid formats in a reasonable manner.\n        for (const t of ticks) {\n            let s, tm;\n            try {\n                tm = _array(t);\n                s = _strftime(t, format);\n            }\n            catch (error) {\n                logger.warn(`unable to format tick for timestamp value ${t}`);\n                logger.warn(` - ${error}`);\n                labels.push(\"ERR\");\n                continue;\n            }\n            let hybrid_handled = false;\n            let next_ndx = resol_ndx;\n            // The way to check that we are at the boundary of the next unit of\n            // time is by checking that we have 0 units of the resolution, i.e.\n            // we are at zero minutes, so display hours, or we are at zero seconds,\n            // so display minutes (and if that is zero as well, then display hours).\n            while (tm[time_tuple_ndx_for_resol[format_order[next_ndx]]] == 0) {\n                let next_format;\n                next_ndx += 1;\n                if (next_ndx == format_order.length)\n                    break;\n                if ((resol == \"minsec\" || resol == \"hourmin\") && !hybrid_handled) {\n                    if ((resol == \"minsec\" && tm[4] == 0 && tm[5] != 0) || (resol == \"hourmin\" && tm[3] == 0 && tm[4] != 0)) {\n                        next_format = this._width_formats[format_order[resol_ndx - 1]][1][0];\n                        s = _strftime(t, next_format);\n                        break;\n                    }\n                    else {\n                        hybrid_handled = true;\n                    }\n                }\n                next_format = this._width_formats[format_order[next_ndx]][1][0];\n                s = _strftime(t, next_format);\n            }\n            // TODO: should expose this in api. %H, %d, etc use leading zeros and\n            // users might prefer to see them lined up correctly.\n            if (this.strip_leading_zeros) {\n                let ss = s.replace(/^0+/g, \"\");\n                if (ss != s && isNaN(parseInt(ss))) {\n                    // If the string can now be parsed as starting with an integer, then\n                    // leave all zeros stripped, otherwise start with a zero. Hence:\n                    // A label such as '000ms' should leave one zero.\n                    // A label such as '001ms' or '0-1ms' should not leave a leading zero.\n                    ss = `0${ss}`;\n                }\n                labels.push(ss);\n            }\n            else\n                labels.push(s);\n        }\n        return labels;\n    }\n}\nDatetimeTickFormatter.__name__ = \"DatetimeTickFormatter\";\nDatetimeTickFormatter.init_DatetimeTickFormatter();\n//# sourceMappingURL=datetime_tick_formatter.js.map"]},"metadata":{},"sourceType":"module"}