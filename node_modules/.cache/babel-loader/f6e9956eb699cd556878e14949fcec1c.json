{"ast":null,"code":"import * as hittest from \"../../core/hittest\";\nexport function generic_line_legend(visuals, ctx, {\n  x0,\n  x1,\n  y0,\n  y1\n}, index) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.moveTo(x0, (y0 + y1) / 2);\n  ctx.lineTo(x1, (y0 + y1) / 2);\n\n  if (visuals.line.doit) {\n    visuals.line.set_vectorize(ctx, index);\n    ctx.stroke();\n  }\n\n  ctx.restore();\n}\nexport function generic_area_legend(visuals, ctx, {\n  x0,\n  x1,\n  y0,\n  y1\n}, index) {\n  const w = Math.abs(x1 - x0);\n  const dw = w * 0.1;\n  const h = Math.abs(y1 - y0);\n  const dh = h * 0.1;\n  const sx0 = x0 + dw;\n  const sx1 = x1 - dw;\n  const sy0 = y0 + dh;\n  const sy1 = y1 - dh;\n\n  if (visuals.fill.doit) {\n    visuals.fill.set_vectorize(ctx, index);\n    ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n  }\n\n  if (visuals.hatch != null && visuals.hatch.doit) {\n    visuals.hatch.set_vectorize(ctx, index);\n    ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n  }\n\n  if (visuals.line && visuals.line.doit) {\n    ctx.beginPath();\n    ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n    visuals.line.set_vectorize(ctx, index);\n    ctx.stroke();\n  }\n}\nexport function line_interpolation(renderer, geometry, x2, y2, x3, y3) {\n  const {\n    sx,\n    sy\n  } = geometry;\n  let x0, x1;\n  let y0, y1;\n\n  if (geometry.type == 'point') {\n    // The +/- adjustments here are to dilate the hit point into a virtual \"segment\" to use below\n    [y0, y1] = renderer.yscale.r_invert(sy - 1, sy + 1);\n    [x0, x1] = renderer.xscale.r_invert(sx - 1, sx + 1);\n  } else {\n    // The +/- adjustments here are to handle cases such as purely horizontal or vertical lines\n    if (geometry.direction == 'v') {\n      [y0, y1] = renderer.yscale.r_invert(sy, sy);\n      [x0, x1] = [Math.min(x2 - 1, x3 - 1), Math.max(x2 + 1, x3 + 1)];\n    } else {\n      [x0, x1] = renderer.xscale.r_invert(sx, sx);\n      [y0, y1] = [Math.min(y2 - 1, y3 - 1), Math.max(y2 + 1, y3 + 1)];\n    }\n  }\n\n  const {\n    x,\n    y\n  } = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n  return [x, y]; // XXX: null is not handled at use sites\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/utils.js"],"names":["hittest","generic_line_legend","visuals","ctx","x0","x1","y0","y1","index","save","beginPath","moveTo","lineTo","line","doit","set_vectorize","stroke","restore","generic_area_legend","w","Math","abs","dw","h","dh","sx0","sx1","sy0","sy1","fill","fillRect","hatch","rect","line_interpolation","renderer","geometry","x2","y2","x3","y3","sx","sy","type","yscale","r_invert","xscale","direction","min","max","x","y","check_2_segments_intersect"],"mappings":"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","sourcesContent":["import * as hittest from \"../../core/hittest\";\nexport function generic_line_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(x0, (y0 + y1) / 2);\n    ctx.lineTo(x1, (y0 + y1) / 2);\n    if (visuals.line.doit) {\n        visuals.line.set_vectorize(ctx, index);\n        ctx.stroke();\n    }\n    ctx.restore();\n}\nexport function generic_area_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\n    const w = Math.abs(x1 - x0);\n    const dw = w * 0.1;\n    const h = Math.abs(y1 - y0);\n    const dh = h * 0.1;\n    const sx0 = x0 + dw;\n    const sx1 = x1 - dw;\n    const sy0 = y0 + dh;\n    const sy1 = y1 - dh;\n    if (visuals.fill.doit) {\n        visuals.fill.set_vectorize(ctx, index);\n        ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n    }\n    if (visuals.hatch != null && visuals.hatch.doit) {\n        visuals.hatch.set_vectorize(ctx, index);\n        ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n    }\n    if (visuals.line && visuals.line.doit) {\n        ctx.beginPath();\n        ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n        visuals.line.set_vectorize(ctx, index);\n        ctx.stroke();\n    }\n}\nexport function line_interpolation(renderer, geometry, x2, y2, x3, y3) {\n    const { sx, sy } = geometry;\n    let x0, x1;\n    let y0, y1;\n    if (geometry.type == 'point') {\n        // The +/- adjustments here are to dilate the hit point into a virtual \"segment\" to use below\n        [y0, y1] = renderer.yscale.r_invert(sy - 1, sy + 1);\n        [x0, x1] = renderer.xscale.r_invert(sx - 1, sx + 1);\n    }\n    else {\n        // The +/- adjustments here are to handle cases such as purely horizontal or vertical lines\n        if (geometry.direction == 'v') {\n            [y0, y1] = renderer.yscale.r_invert(sy, sy);\n            [x0, x1] = [Math.min(x2 - 1, x3 - 1), Math.max(x2 + 1, x3 + 1)];\n        }\n        else {\n            [x0, x1] = renderer.xscale.r_invert(sx, sx);\n            [y0, y1] = [Math.min(y2 - 1, y3 - 1), Math.max(y2 + 1, y3 + 1)];\n        }\n    }\n    const { x, y } = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n    return [x, y]; // XXX: null is not handled at use sites\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}