{"ast":null,"code":"import { Glyph, GlyphView } from \"./glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { generic_area_legend } from \"./utils\";\nexport class HexTileView extends GlyphView {\n  scenterx(i) {\n    return this.sx[i];\n  }\n\n  scentery(i) {\n    return this.sy[i];\n  }\n\n  _set_data() {\n    const n = this._q.length;\n    const size = this.model.size;\n    const aspect_scale = this.model.aspect_scale;\n    this._x = new Float64Array(n);\n    this._y = new Float64Array(n);\n\n    if (this.model.orientation == \"pointytop\") {\n      for (let i = 0; i < n; i++) {\n        this._x[i] = size * Math.sqrt(3) * (this._q[i] + this._r[i] / 2) / aspect_scale;\n        this._y[i] = -size * 3 / 2 * this._r[i];\n      }\n    } else {\n      for (let i = 0; i < n; i++) {\n        this._x[i] = size * 3 / 2 * this._q[i];\n        this._y[i] = -size * Math.sqrt(3) * (this._r[i] + this._q[i] / 2) * aspect_scale;\n      }\n    }\n  }\n\n  _index_data() {\n    let ysize = this.model.size;\n    let xsize = Math.sqrt(3) * ysize / 2;\n\n    if (this.model.orientation == \"flattop\") {\n      [xsize, ysize] = [ysize, xsize];\n      ysize *= this.model.aspect_scale;\n    } else xsize /= this.model.aspect_scale;\n\n    const points = [];\n\n    for (let i = 0; i < this._x.length; i++) {\n      const x = this._x[i];\n      const y = this._y[i];\n      if (isNaN(x + y) || !isFinite(x + y)) continue;\n      points.push({\n        x0: x - xsize,\n        y0: y - ysize,\n        x1: x + xsize,\n        y1: y + ysize,\n        i\n      });\n    }\n\n    return new SpatialIndex(points);\n  } // overriding map_data instead of _map_data because the default automatic mappings\n  // for other glyphs (with cartesian coordinates) is not useful\n\n\n  map_data() {\n    [this.sx, this.sy] = this.map_to_screen(this._x, this._y);\n    [this.svx, this.svy] = this._get_unscaled_vertices();\n  }\n\n  _get_unscaled_vertices() {\n    const size = this.model.size;\n    const aspect_scale = this.model.aspect_scale;\n\n    if (this.model.orientation == \"pointytop\") {\n      const rscale = this.renderer.yscale;\n      const hscale = this.renderer.xscale;\n      const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n\n      const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) / aspect_scale; // assumes linear scale\n\n      const r2 = r / 2.0;\n      const svx = [0, -h, -h, 0, h, h];\n      const svy = [r, r2, -r2, -r, -r2, r2];\n      return [svx, svy];\n    } else {\n      const rscale = this.renderer.xscale;\n      const hscale = this.renderer.yscale;\n      const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n\n      const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) * aspect_scale; // assumes linear scale\n\n      const r2 = r / 2.0;\n      const svx = [r, r2, -r2, -r, -r2, r2];\n      const svy = [0, -h, -h, 0, h, h];\n      return [svx, svy];\n    }\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    svx,\n    svy,\n    _scale\n  }) {\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + _scale[i])) continue;\n      ctx.translate(sx[i], sy[i]);\n      ctx.beginPath();\n\n      for (let j = 0; j < 6; j++) {\n        ctx.lineTo(svx[j] * _scale[i], svy[j] * _scale[i]);\n      }\n\n      ctx.closePath();\n      ctx.translate(-sx[i], -sy[i]);\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n        ctx.fill();\n      }\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy);\n    const candidates = this.index.indices({\n      x0: x,\n      y0: y,\n      x1: x,\n      y1: y\n    });\n    const hits = [];\n\n    for (const i of candidates) {\n      if (hittest.point_in_poly(sx - this.sx[i], sy - this.sy[i], this.svx, this.svy)) {\n        hits.push(i);\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_span(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    let hits;\n\n    if (geometry.direction == 'v') {\n      const y = this.renderer.yscale.invert(sy);\n      const hr = this.renderer.plot_view.frame.bbox.h_range;\n      const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n      hits = this.index.indices({\n        x0,\n        y0: y,\n        x1,\n        y1: y\n      });\n    } else {\n      const x = this.renderer.xscale.invert(sx);\n      const vr = this.renderer.plot_view.frame.bbox.v_range;\n      const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n      hits = this.index.indices({\n        x0: x,\n        y0,\n        x1: x,\n        y1\n      });\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_rect(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    return result;\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_area_legend(this.visuals, ctx, bbox, index);\n  }\n\n}\nHexTileView.__name__ = \"HexTileView\";\nexport class HexTile extends Glyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_HexTile() {\n    this.prototype.default_view = HexTileView;\n    this.coords([['r', 'q']]);\n    this.mixins(['line', 'fill']);\n    this.define({\n      size: [p.Number, 1.0],\n      aspect_scale: [p.Number, 1.0],\n      scale: [p.NumberSpec, 1.0],\n      orientation: [p.HexTileOrientation, \"pointytop\"]\n    });\n    this.override({\n      line_color: null\n    });\n  }\n\n}\nHexTile.__name__ = \"HexTile\";\nHexTile.init_HexTile();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/hex_tile.js"],"names":["Glyph","GlyphView","hittest","p","SpatialIndex","generic_area_legend","HexTileView","scenterx","i","sx","scentery","sy","_set_data","n","_q","length","size","model","aspect_scale","_x","Float64Array","_y","orientation","Math","sqrt","_r","_index_data","ysize","xsize","points","x","y","isNaN","isFinite","push","x0","y0","x1","y1","map_data","map_to_screen","svx","svy","_get_unscaled_vertices","rscale","renderer","yscale","hscale","xscale","r","abs","compute","h","r2","_render","ctx","indices","_scale","translate","beginPath","j","lineTo","closePath","visuals","fill","doit","set_vectorize","line","stroke","_hit_point","geometry","invert","candidates","index","hits","point_in_poly","result","create_empty_hit_test_result","_hit_span","direction","hr","plot_view","frame","bbox","h_range","r_invert","start","end","vr","v_range","_hit_rect","sx0","sx1","sy0","sy1","draw_legend_for_index","__name__","HexTile","constructor","attrs","init_HexTile","prototype","default_view","coords","mixins","define","Number","scale","NumberSpec","HexTileOrientation","override","line_color"],"mappings":"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","sourcesContent":["import { Glyph, GlyphView } from \"./glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { generic_area_legend } from \"./utils\";\nexport class HexTileView extends GlyphView {\n    scenterx(i) { return this.sx[i]; }\n    scentery(i) { return this.sy[i]; }\n    _set_data() {\n        const n = this._q.length;\n        const size = this.model.size;\n        const aspect_scale = this.model.aspect_scale;\n        this._x = new Float64Array(n);\n        this._y = new Float64Array(n);\n        if (this.model.orientation == \"pointytop\") {\n            for (let i = 0; i < n; i++) {\n                this._x[i] = size * Math.sqrt(3) * (this._q[i] + this._r[i] / 2) / aspect_scale;\n                this._y[i] = -size * 3 / 2 * this._r[i];\n            }\n        }\n        else {\n            for (let i = 0; i < n; i++) {\n                this._x[i] = size * 3 / 2 * this._q[i];\n                this._y[i] = -size * Math.sqrt(3) * (this._r[i] + this._q[i] / 2) * aspect_scale;\n            }\n        }\n    }\n    _index_data() {\n        let ysize = this.model.size;\n        let xsize = Math.sqrt(3) * ysize / 2;\n        if (this.model.orientation == \"flattop\") {\n            [xsize, ysize] = [ysize, xsize];\n            ysize *= this.model.aspect_scale;\n        }\n        else\n            xsize /= this.model.aspect_scale;\n        const points = [];\n        for (let i = 0; i < this._x.length; i++) {\n            const x = this._x[i];\n            const y = this._y[i];\n            if (isNaN(x + y) || !isFinite(x + y))\n                continue;\n            points.push({ x0: x - xsize, y0: y - ysize, x1: x + xsize, y1: y + ysize, i });\n        }\n        return new SpatialIndex(points);\n    }\n    // overriding map_data instead of _map_data because the default automatic mappings\n    // for other glyphs (with cartesian coordinates) is not useful\n    map_data() {\n        [this.sx, this.sy] = this.map_to_screen(this._x, this._y);\n        [this.svx, this.svy] = this._get_unscaled_vertices();\n    }\n    _get_unscaled_vertices() {\n        const size = this.model.size;\n        const aspect_scale = this.model.aspect_scale;\n        if (this.model.orientation == \"pointytop\") {\n            const rscale = this.renderer.yscale;\n            const hscale = this.renderer.xscale;\n            const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n            const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) / aspect_scale; // assumes linear scale\n            const r2 = r / 2.0;\n            const svx = [0, -h, -h, 0, h, h];\n            const svy = [r, r2, -r2, -r, -r2, r2];\n            return [svx, svy];\n        }\n        else {\n            const rscale = this.renderer.xscale;\n            const hscale = this.renderer.yscale;\n            const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n            const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) * aspect_scale; // assumes linear scale\n            const r2 = r / 2.0;\n            const svx = [r, r2, -r2, -r, -r2, r2];\n            const svy = [0, -h, -h, 0, h, h];\n            return [svx, svy];\n        }\n    }\n    _render(ctx, indices, { sx, sy, svx, svy, _scale }) {\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + _scale[i]))\n                continue;\n            ctx.translate(sx[i], sy[i]);\n            ctx.beginPath();\n            for (let j = 0; j < 6; j++) {\n                ctx.lineTo(svx[j] * _scale[i], svy[j] * _scale[i]);\n            }\n            ctx.closePath();\n            ctx.translate(-sx[i], -sy[i]);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n        const hits = [];\n        for (const i of candidates) {\n            if (hittest.point_in_poly(sx - this.sx[i], sy - this.sy[i], this.svx, this.svy)) {\n                hits.push(i);\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _hit_span(geometry) {\n        const { sx, sy } = geometry;\n        let hits;\n        if (geometry.direction == 'v') {\n            const y = this.renderer.yscale.invert(sy);\n            const hr = this.renderer.plot_view.frame.bbox.h_range;\n            const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n            hits = this.index.indices({ x0, y0: y, x1, y1: y });\n        }\n        else {\n            const x = this.renderer.xscale.invert(sx);\n            const vr = this.renderer.plot_view.frame.bbox.v_range;\n            const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n            hits = this.index.indices({ x0: x, y0, x1: x, y1 });\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _hit_rect(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = this.index.indices({ x0, x1, y0, y1 });\n        return result;\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_area_legend(this.visuals, ctx, bbox, index);\n    }\n}\nHexTileView.__name__ = \"HexTileView\";\nexport class HexTile extends Glyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_HexTile() {\n        this.prototype.default_view = HexTileView;\n        this.coords([['r', 'q']]);\n        this.mixins(['line', 'fill']);\n        this.define({\n            size: [p.Number, 1.0],\n            aspect_scale: [p.Number, 1.0],\n            scale: [p.NumberSpec, 1.0],\n            orientation: [p.HexTileOrientation, \"pointytop\"],\n        });\n        this.override({ line_color: null });\n    }\n}\nHexTile.__name__ = \"HexTile\";\nHexTile.init_HexTile();\n//# sourceMappingURL=hex_tile.js.map"]},"metadata":{},"sourceType":"module"}