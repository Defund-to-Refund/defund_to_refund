{"ast":null,"code":"import FlatQueue from 'flatqueue';\nconst ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\nconst VERSION = 3; // serialized format version\n\nexport default class Flatbush {\n  static from(data) {\n    if (!(data instanceof ArrayBuffer)) {\n      throw new Error('Data must be an instance of ArrayBuffer.');\n    }\n\n    const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n\n    if (magic !== 0xfb) {\n      throw new Error('Data does not appear to be in a Flatbush format.');\n    }\n\n    if (versionAndType >> 4 !== VERSION) {\n      throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);\n    }\n\n    const [nodeSize] = new Uint16Array(data, 2, 1);\n    const [numItems] = new Uint32Array(data, 4, 1);\n    return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);\n  }\n\n  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {\n    if (numItems === undefined) throw new Error('Missing required argument: numItems.');\n    if (isNaN(numItems) || numItems <= 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n    this.numItems = +numItems;\n    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535); // calculate the total number of nodes in the R-tree to allocate space for\n    // and the index of each tree level (used in search later)\n\n    let n = numItems;\n    let numNodes = n;\n    this._levelBounds = [n * 4];\n\n    do {\n      n = Math.ceil(n / this.nodeSize);\n      numNodes += n;\n\n      this._levelBounds.push(numNodes * 4);\n    } while (n !== 1);\n\n    this.ArrayType = ArrayType || Float64Array;\n    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n    const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n\n    if (arrayTypeIndex < 0) {\n      throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n    }\n\n    if (data && data instanceof ArrayBuffer) {\n      this.data = data;\n      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n      this._pos = numNodes * 4;\n      this.minX = this._boxes[this._pos - 4];\n      this.minY = this._boxes[this._pos - 3];\n      this.maxX = this._boxes[this._pos - 2];\n      this.maxY = this._boxes[this._pos - 1];\n    } else {\n      this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n      this._pos = 0;\n      this.minX = Infinity;\n      this.minY = Infinity;\n      this.maxX = -Infinity;\n      this.maxY = -Infinity;\n      new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n      new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n      new Uint32Array(this.data, 4, 1)[0] = numItems;\n    } // a priority queue for k-nearest-neighbors queries\n\n\n    this._queue = new FlatQueue();\n  }\n\n  add(minX, minY, maxX, maxY) {\n    const index = this._pos >> 2;\n    this._indices[index] = index;\n    this._boxes[this._pos++] = minX;\n    this._boxes[this._pos++] = minY;\n    this._boxes[this._pos++] = maxX;\n    this._boxes[this._pos++] = maxY;\n    if (minX < this.minX) this.minX = minX;\n    if (minY < this.minY) this.minY = minY;\n    if (maxX > this.maxX) this.maxX = maxX;\n    if (maxY > this.maxY) this.maxY = maxY;\n    return index;\n  }\n\n  finish() {\n    if (this._pos >> 2 !== this.numItems) {\n      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n    }\n\n    if (this.numItems <= this.nodeSize) {\n      // only one node, skip sorting and just fill the root box\n      this._boxes[this._pos++] = this.minX;\n      this._boxes[this._pos++] = this.minY;\n      this._boxes[this._pos++] = this.maxX;\n      this._boxes[this._pos++] = this.maxY;\n      return;\n    }\n\n    const width = this.maxX - this.minX;\n    const height = this.maxY - this.minY;\n    const hilbertValues = new Uint32Array(this.numItems);\n    const hilbertMax = (1 << 16) - 1; // map item centers into Hilbert coordinate space and calculate Hilbert values\n\n    for (let i = 0; i < this.numItems; i++) {\n      let pos = 4 * i;\n      const minX = this._boxes[pos++];\n      const minY = this._boxes[pos++];\n      const maxX = this._boxes[pos++];\n      const maxY = this._boxes[pos++];\n      const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n      const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n      hilbertValues[i] = hilbert(x, y);\n    } // sort items by their Hilbert value (for packing later)\n\n\n    sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize); // generate nodes at each tree level, bottom-up\n\n    for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n      const end = this._levelBounds[i]; // generate a parent node for each block of consecutive <nodeSize> nodes\n\n      while (pos < end) {\n        const nodeIndex = pos; // calculate bbox for the new node\n\n        let nodeMinX = Infinity;\n        let nodeMinY = Infinity;\n        let nodeMaxX = -Infinity;\n        let nodeMaxY = -Infinity;\n\n        for (let i = 0; i < this.nodeSize && pos < end; i++) {\n          nodeMinX = Math.min(nodeMinX, this._boxes[pos++]);\n          nodeMinY = Math.min(nodeMinY, this._boxes[pos++]);\n          nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]);\n          nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);\n        } // add the new node to the tree data\n\n\n        this._indices[this._pos >> 2] = nodeIndex;\n        this._boxes[this._pos++] = nodeMinX;\n        this._boxes[this._pos++] = nodeMinY;\n        this._boxes[this._pos++] = nodeMaxX;\n        this._boxes[this._pos++] = nodeMaxY;\n      }\n    }\n  }\n\n  search(minX, minY, maxX, maxY, filterFn) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    let nodeIndex = this._boxes.length - 4;\n    const queue = [];\n    const results = [];\n\n    while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds)); // search through child nodes\n\n      for (let pos = nodeIndex; pos < end; pos += 4) {\n        const index = this._indices[pos >> 2] | 0; // check if node bbox intersects with query bbox\n\n        if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX\n\n        if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY\n\n        if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX\n\n        if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY\n\n        if (nodeIndex < this.numItems * 4) {\n          if (filterFn === undefined || filterFn(index)) {\n            results.push(index); // leaf item\n          }\n        } else {\n          queue.push(index); // node; add it to the search queue\n        }\n      }\n\n      nodeIndex = queue.pop();\n    }\n\n    return results;\n  }\n\n  neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    let nodeIndex = this._boxes.length - 4;\n    const q = this._queue;\n    const results = [];\n    const maxDistSquared = maxDistance * maxDistance;\n\n    while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds)); // add child nodes to the queue\n\n      for (let pos = nodeIndex; pos < end; pos += 4) {\n        const index = this._indices[pos >> 2] | 0;\n        const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\n        const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\n        const dist = dx * dx + dy * dy;\n\n        if (nodeIndex < this.numItems * 4) {\n          // leaf node\n          if (filterFn === undefined || filterFn(index)) {\n            // put a negative index if it's an item rather than a node, to recognize later\n            q.push(-index - 1, dist);\n          }\n        } else {\n          q.push(index, dist);\n        }\n      } // pop items from the queue\n\n\n      while (q.length && q.peek() < 0) {\n        const dist = q.peekValue();\n\n        if (dist > maxDistSquared) {\n          q.clear();\n          return results;\n        }\n\n        results.push(-q.pop() - 1);\n\n        if (results.length === maxResults) {\n          q.clear();\n          return results;\n        }\n      }\n\n      nodeIndex = q.pop();\n    }\n\n    q.clear();\n    return results;\n  }\n\n}\n\nfunction axisDist(k, min, max) {\n  return k < min ? min - k : k <= max ? 0 : k - max;\n} // binary search for the first value in the array bigger than the given\n\n\nfunction upperBound(value, arr) {\n  let i = 0;\n  let j = arr.length - 1;\n\n  while (i < j) {\n    const m = i + j >> 1;\n\n    if (arr[m] > value) {\n      j = m;\n    } else {\n      i = m + 1;\n    }\n  }\n\n  return arr[i];\n} // custom quicksort that partially sorts bbox data alongside the hilbert values\n\n\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n  if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;\n  const pivot = values[left + right >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (values[i] < pivot);\n\n    do j--; while (values[j] > pivot);\n\n    if (i >= j) break;\n    swap(values, boxes, indices, i, j);\n  }\n\n  sort(values, boxes, indices, left, j, nodeSize);\n  sort(values, boxes, indices, j + 1, right, nodeSize);\n} // swap two values and two corresponding boxes\n\n\nfunction swap(values, boxes, indices, i, j) {\n  const temp = values[i];\n  values[i] = values[j];\n  values[j] = temp;\n  const k = 4 * i;\n  const m = 4 * j;\n  const a = boxes[k];\n  const b = boxes[k + 1];\n  const c = boxes[k + 2];\n  const d = boxes[k + 3];\n  boxes[k] = boxes[m];\n  boxes[k + 1] = boxes[m + 1];\n  boxes[k + 2] = boxes[m + 2];\n  boxes[k + 3] = boxes[m + 3];\n  boxes[m] = a;\n  boxes[m + 1] = b;\n  boxes[m + 2] = c;\n  boxes[m + 3] = d;\n  const e = indices[i];\n  indices[i] = indices[j];\n  indices[j] = e;\n} // Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n// Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n\n\nfunction hilbert(x, y) {\n  let a = x ^ y;\n  let b = 0xFFFF ^ a;\n  let c = 0xFFFF ^ (x | y);\n  let d = x & (y ^ 0xFFFF);\n  let A = a | b >> 1;\n  let B = a >> 1 ^ a;\n  let C = c >> 1 ^ b & d >> 1 ^ c;\n  let D = a & c >> 1 ^ d >> 1 ^ d;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 2 ^ b & b >> 2;\n  B = a & b >> 2 ^ b & (a ^ b) >> 2;\n  C ^= a & c >> 2 ^ b & d >> 2;\n  D ^= b & c >> 2 ^ (a ^ b) & d >> 2;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 4 ^ b & b >> 4;\n  B = a & b >> 4 ^ b & (a ^ b) >> 4;\n  C ^= a & c >> 4 ^ b & d >> 4;\n  D ^= b & c >> 4 ^ (a ^ b) & d >> 4;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  C ^= a & c >> 8 ^ b & d >> 8;\n  D ^= b & c >> 8 ^ (a ^ b) & d >> 8;\n  a = C ^ C >> 1;\n  b = D ^ D >> 1;\n  let i0 = x ^ y;\n  let i1 = b | 0xFFFF ^ (i0 | a);\n  i0 = (i0 | i0 << 8) & 0x00FF00FF;\n  i0 = (i0 | i0 << 4) & 0x0F0F0F0F;\n  i0 = (i0 | i0 << 2) & 0x33333333;\n  i0 = (i0 | i0 << 1) & 0x55555555;\n  i1 = (i1 | i1 << 8) & 0x00FF00FF;\n  i1 = (i1 | i1 << 4) & 0x0F0F0F0F;\n  i1 = (i1 | i1 << 2) & 0x33333333;\n  i1 = (i1 | i1 << 1) & 0x55555555;\n  return (i1 << 1 | i0) >>> 0;\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/flatbush/index.js"],"names":["FlatQueue","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","VERSION","Flatbush","from","data","ArrayBuffer","Error","magic","versionAndType","nodeSize","numItems","constructor","ArrayType","undefined","isNaN","Math","min","max","n","numNodes","_levelBounds","ceil","push","IndexArrayType","arrayTypeIndex","indexOf","nodesByteSize","BYTES_PER_ELEMENT","_boxes","_indices","_pos","minX","minY","maxX","maxY","Infinity","set","_queue","add","index","finish","width","height","hilbertValues","hilbertMax","i","pos","x","floor","y","hilbert","sort","length","end","nodeIndex","nodeMinX","nodeMinY","nodeMaxX","nodeMaxY","search","filterFn","queue","results","upperBound","pop","neighbors","maxResults","maxDistance","q","maxDistSquared","dx","axisDist","dy","dist","peek","peekValue","clear","k","value","arr","j","m","values","boxes","indices","left","right","pivot","swap","temp","a","b","c","d","e","A","B","C","D","i0","i1"],"mappings":"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","sourcesContent":["\nimport FlatQueue from 'flatqueue';\n\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\nconst VERSION = 3; // serialized format version\n\nexport default class Flatbush {\n\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xfb) {\n            throw new Error('Data does not appear to be in a Flatbush format.');\n        }\n        if (versionAndType >> 4 !== VERSION) {\n            throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);\n    }\n\n    constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {\n        if (numItems === undefined) throw new Error('Missing required argument: numItems.');\n        if (isNaN(numItems) || numItems <= 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n\n        // calculate the total number of nodes in the R-tree to allocate space for\n        // and the index of each tree level (used in search later)\n        let n = numItems;\n        let numNodes = n;\n        this._levelBounds = [n * 4];\n        do {\n            n = Math.ceil(n / this.nodeSize);\n            numNodes += n;\n            this._levelBounds.push(numNodes * 4);\n        } while (n !== 1);\n\n        this.ArrayType = ArrayType || Float64Array;\n        this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) {\n            this.data = data;\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n\n            this._pos = numNodes * 4;\n            this.minX = this._boxes[this._pos - 4];\n            this.minY = this._boxes[this._pos - 3];\n            this.maxX = this._boxes[this._pos - 2];\n            this.maxY = this._boxes[this._pos - 1];\n\n        } else {\n            this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n            this._pos = 0;\n            this.minX = Infinity;\n            this.minY = Infinity;\n            this.maxX = -Infinity;\n            this.maxY = -Infinity;\n\n            new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n\n        // a priority queue for k-nearest-neighbors queries\n        this._queue = new FlatQueue();\n    }\n\n    add(minX, minY, maxX, maxY) {\n        const index = this._pos >> 2;\n        this._indices[index] = index;\n        this._boxes[this._pos++] = minX;\n        this._boxes[this._pos++] = minY;\n        this._boxes[this._pos++] = maxX;\n        this._boxes[this._pos++] = maxY;\n\n        if (minX < this.minX) this.minX = minX;\n        if (minY < this.minY) this.minY = minY;\n        if (maxX > this.maxX) this.maxX = maxX;\n        if (maxY > this.maxY) this.maxY = maxY;\n\n        return index;\n    }\n\n    finish() {\n        if (this._pos >> 2 !== this.numItems) {\n            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n        }\n\n        if (this.numItems <= this.nodeSize) {\n            // only one node, skip sorting and just fill the root box\n            this._boxes[this._pos++] = this.minX;\n            this._boxes[this._pos++] = this.minY;\n            this._boxes[this._pos++] = this.maxX;\n            this._boxes[this._pos++] = this.maxY;\n            return;\n        }\n\n        const width = this.maxX - this.minX;\n        const height = this.maxY - this.minY;\n        const hilbertValues = new Uint32Array(this.numItems);\n        const hilbertMax = (1 << 16) - 1;\n\n        // map item centers into Hilbert coordinate space and calculate Hilbert values\n        for (let i = 0; i < this.numItems; i++) {\n            let pos = 4 * i;\n            const minX = this._boxes[pos++];\n            const minY = this._boxes[pos++];\n            const maxX = this._boxes[pos++];\n            const maxY = this._boxes[pos++];\n            const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n            const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n            hilbertValues[i] = hilbert(x, y);\n        }\n\n        // sort items by their Hilbert value (for packing later)\n        sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\n\n        // generate nodes at each tree level, bottom-up\n        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n            const end = this._levelBounds[i];\n\n            // generate a parent node for each block of consecutive <nodeSize> nodes\n            while (pos < end) {\n                const nodeIndex = pos;\n\n                // calculate bbox for the new node\n                let nodeMinX = Infinity;\n                let nodeMinY = Infinity;\n                let nodeMaxX = -Infinity;\n                let nodeMaxY = -Infinity;\n                for (let i = 0; i < this.nodeSize && pos < end; i++) {\n                    nodeMinX = Math.min(nodeMinX, this._boxes[pos++]);\n                    nodeMinY = Math.min(nodeMinY, this._boxes[pos++]);\n                    nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]);\n                    nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);\n                }\n\n                // add the new node to the tree data\n                this._indices[this._pos >> 2] = nodeIndex;\n                this._boxes[this._pos++] = nodeMinX;\n                this._boxes[this._pos++] = nodeMinY;\n                this._boxes[this._pos++] = nodeMaxX;\n                this._boxes[this._pos++] = nodeMaxY;\n            }\n        }\n    }\n\n    search(minX, minY, maxX, maxY, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        let nodeIndex = this._boxes.length - 4;\n        const queue = [];\n        const results = [];\n\n        while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // search through child nodes\n            for (let pos = nodeIndex; pos < end; pos += 4) {\n                const index = this._indices[pos >> 2] | 0;\n\n                // check if node bbox intersects with query bbox\n                if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX\n                if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY\n                if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX\n                if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY\n\n                if (nodeIndex < this.numItems * 4) {\n                    if (filterFn === undefined || filterFn(index)) {\n                        results.push(index); // leaf item\n                    }\n\n                } else {\n                    queue.push(index); // node; add it to the search queue\n                }\n            }\n\n            nodeIndex = queue.pop();\n        }\n\n        return results;\n    }\n\n    neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        let nodeIndex = this._boxes.length - 4;\n        const q = this._queue;\n        const results = [];\n        const maxDistSquared = maxDistance * maxDistance;\n\n        while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // add child nodes to the queue\n            for (let pos = nodeIndex; pos < end; pos += 4) {\n                const index = this._indices[pos >> 2] | 0;\n\n                const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\n                const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\n                const dist = dx * dx + dy * dy;\n\n                if (nodeIndex < this.numItems * 4) { // leaf node\n                    if (filterFn === undefined || filterFn(index)) {\n                        // put a negative index if it's an item rather than a node, to recognize later\n                        q.push(-index - 1, dist);\n                    }\n                } else {\n                    q.push(index, dist);\n                }\n            }\n\n            // pop items from the queue\n            while (q.length && q.peek() < 0) {\n                const dist = q.peekValue();\n                if (dist > maxDistSquared) {\n                    q.clear();\n                    return results;\n                }\n                results.push(-q.pop() - 1);\n\n                if (results.length === maxResults) {\n                    q.clear();\n                    return results;\n                }\n            }\n\n            nodeIndex = q.pop();\n        }\n\n        q.clear();\n        return results;\n    }\n}\n\nfunction axisDist(k, min, max) {\n    return k < min ? min - k : k <= max ? 0 : k - max;\n}\n\n// binary search for the first value in the array bigger than the given\nfunction upperBound(value, arr) {\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n        const m = (i + j) >> 1;\n        if (arr[m] > value) {\n            j = m;\n        } else {\n            i = m + 1;\n        }\n    }\n    return arr[i];\n}\n\n// custom quicksort that partially sorts bbox data alongside the hilbert values\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n    if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;\n\n    const pivot = values[(left + right) >> 1];\n    let i = left - 1;\n    let j = right + 1;\n\n    while (true) {\n        do i++; while (values[i] < pivot);\n        do j--; while (values[j] > pivot);\n        if (i >= j) break;\n        swap(values, boxes, indices, i, j);\n    }\n\n    sort(values, boxes, indices, left, j, nodeSize);\n    sort(values, boxes, indices, j + 1, right, nodeSize);\n}\n\n// swap two values and two corresponding boxes\nfunction swap(values, boxes, indices, i, j) {\n    const temp = values[i];\n    values[i] = values[j];\n    values[j] = temp;\n\n    const k = 4 * i;\n    const m = 4 * j;\n\n    const a = boxes[k];\n    const b = boxes[k + 1];\n    const c = boxes[k + 2];\n    const d = boxes[k + 3];\n    boxes[k] = boxes[m];\n    boxes[k + 1] = boxes[m + 1];\n    boxes[k + 2] = boxes[m + 2];\n    boxes[k + 3] = boxes[m + 3];\n    boxes[m] = a;\n    boxes[m + 1] = b;\n    boxes[m + 2] = c;\n    boxes[m + 3] = d;\n\n    const e = indices[i];\n    indices[i] = indices[j];\n    indices[j] = e;\n}\n\n// Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n// Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\nfunction hilbert(x, y) {\n    let a = x ^ y;\n    let b = 0xFFFF ^ a;\n    let c = 0xFFFF ^ (x | y);\n    let d = x & (y ^ 0xFFFF);\n\n    let A = a | (b >> 1);\n    let B = (a >> 1) ^ a;\n    let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\n    let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 2)) ^ (b & (b >> 2)));\n    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\n    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\n    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 4)) ^ (b & (b >> 4)));\n    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\n    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\n    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\n\n    a = A; b = B; c = C; d = D;\n    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\n    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\n\n    a = C ^ (C >> 1);\n    b = D ^ (D >> 1);\n\n    let i0 = x ^ y;\n    let i1 = b | (0xFFFF ^ (i0 | a));\n\n    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\n    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\n    i0 = (i0 | (i0 << 2)) & 0x33333333;\n    i0 = (i0 | (i0 << 1)) & 0x55555555;\n\n    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\n    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\n    i1 = (i1 | (i1 << 2)) & 0x33333333;\n    i1 = (i1 | (i1 << 1)) & 0x55555555;\n\n    return ((i1 << 1) | i0) >>> 0;\n}\n"]},"metadata":{},"sourceType":"module"}