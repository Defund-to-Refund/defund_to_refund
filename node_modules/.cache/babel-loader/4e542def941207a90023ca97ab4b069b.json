{"ast":null,"code":"import * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport * as bbox from \"../../core/util/bbox\";\nimport * as proj from \"../../core/util/projections\";\nimport * as visuals from \"../../core/visuals\";\nimport { View } from \"../../core/view\";\nimport { Model } from \"../../model\";\nimport { logger } from \"../../core/logging\";\nimport { map } from \"../../core/util/arrayable\";\nimport { extend } from \"../../core/util/object\";\nimport { isArray, isTypedArray } from \"../../core/util/types\";\nimport { LineView } from \"./line\";\nimport { FactorRange } from \"../ranges/factor_range\";\nexport class GlyphView extends View {\n  constructor() {\n    super(...arguments);\n    this._nohit_warned = new Set();\n  }\n\n  get renderer() {\n    return this.parent;\n  }\n\n  get has_webgl() {\n    return this.glglyph != null;\n  }\n\n  initialize() {\n    super.initialize();\n    this.visuals = new visuals.Visuals(this.model);\n  }\n\n  async lazy_initialize() {\n    await super.lazy_initialize();\n    const {\n      webgl\n    } = this.renderer.plot_view.canvas_view;\n\n    if (webgl != null) {\n      let webgl_module = null;\n\n      try {\n        webgl_module = await import(\"./webgl/index\");\n      } catch (e) {\n        // TODO: this exposes the underyling module system\n        if (e.code === 'MODULE_NOT_FOUND') logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');else throw e;\n      }\n\n      if (webgl_module != null) {\n        const Cls = webgl_module[this.model.type + 'GLGlyph'];\n        if (Cls != null) this.glglyph = new Cls(webgl.gl, this);\n      }\n    }\n  }\n\n  set_visuals(source) {\n    this.visuals.warm_cache(source);\n    if (this.glglyph != null) this.glglyph.set_visuals_changed();\n  }\n\n  render(ctx, indices, data) {\n    ctx.beginPath();\n\n    if (this.glglyph != null) {\n      if (this.glglyph.render(ctx, indices, data)) return;\n    }\n\n    this._render(ctx, indices, data);\n  }\n\n  has_finished() {\n    return true;\n  }\n\n  notify_finished() {\n    this.renderer.notify_finished();\n  }\n\n  _bounds(bounds) {\n    return bounds;\n  }\n\n  bounds() {\n    return this._bounds(this.index.bbox);\n  }\n\n  log_bounds() {\n    const bb = bbox.empty();\n    const positive_x_bbs = this.index.search(bbox.positive_x());\n\n    for (const x of positive_x_bbs) {\n      if (x.x0 < bb.x0) bb.x0 = x.x0;\n      if (x.x1 > bb.x1) bb.x1 = x.x1;\n    }\n\n    const positive_y_bbs = this.index.search(bbox.positive_y());\n\n    for (const y of positive_y_bbs) {\n      if (y.y0 < bb.y0) bb.y0 = y.y0;\n      if (y.y1 > bb.y1) bb.y1 = y.y1;\n    }\n\n    return this._bounds(bb);\n  }\n\n  get_anchor_point(anchor, i, [sx, sy]) {\n    switch (anchor) {\n      case \"center\":\n        return {\n          x: this.scenterx(i, sx, sy),\n          y: this.scentery(i, sx, sy)\n        };\n\n      default:\n        return null;\n    }\n  }\n\n  sdist(scale, pts, spans, pts_location = \"edge\", dilate = false) {\n    let pt0;\n    let pt1;\n    const n = pts.length;\n\n    if (pts_location == 'center') {\n      const halfspan = map(spans, d => d / 2);\n      pt0 = new Float64Array(n);\n\n      for (let i = 0; i < n; i++) {\n        pt0[i] = pts[i] - halfspan[i];\n      }\n\n      pt1 = new Float64Array(n);\n\n      for (let i = 0; i < n; i++) {\n        pt1[i] = pts[i] + halfspan[i];\n      }\n    } else {\n      pt0 = pts;\n      pt1 = new Float64Array(n);\n\n      for (let i = 0; i < n; i++) {\n        pt1[i] = pt0[i] + spans[i];\n      }\n    }\n\n    const spt0 = scale.v_compute(pt0);\n    const spt1 = scale.v_compute(pt1);\n    if (dilate) return map(spt0, (_, i) => Math.ceil(Math.abs(spt1[i] - spt0[i])));else return map(spt0, (_, i) => Math.abs(spt1[i] - spt0[i]));\n  }\n\n  draw_legend_for_index(_ctx, _bbox, _index) {}\n\n  hit_test(geometry) {\n    switch (geometry.type) {\n      case \"point\":\n        if (this._hit_point != null) return this._hit_point(geometry);\n        break;\n\n      case \"span\":\n        if (this._hit_span != null) return this._hit_span(geometry);\n        break;\n\n      case \"rect\":\n        if (this._hit_rect != null) return this._hit_rect(geometry);\n        break;\n\n      case \"poly\":\n        if (this._hit_poly != null) return this._hit_poly(geometry);\n        break;\n    }\n\n    if (!this._nohit_warned.has(geometry.type)) {\n      logger.debug(`'${geometry.type}' selection not available for ${this.model.type}`);\n\n      this._nohit_warned.add(geometry.type);\n    }\n\n    return null;\n  }\n\n  _hit_rect_against_index(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    return result;\n  }\n\n  set_data(source, indices, indices_to_update) {\n    let data = this.model.materialize_dataspecs(source);\n    this.visuals.set_all_indices(indices);\n\n    if (indices && !(this instanceof LineView)) {\n      const data_subset = {};\n\n      for (const k in data) {\n        const v = data[k];\n        if (k.charAt(0) === '_') data_subset[k] = indices.map(i => v[i]);else data_subset[k] = v;\n      }\n\n      data = data_subset;\n    }\n\n    const self = this;\n    extend(self, data); // TODO (bev) Should really probably delegate computing projected\n    // coordinates to glyphs, instead of centralizing here in one place.\n\n    if (this.renderer.plot_view.model.use_map) {\n      if (self._x != null) [self._x, self._y] = proj.project_xy(self._x, self._y);\n      if (self._xs != null) [self._xs, self._ys] = proj.project_xsys(self._xs, self._ys);\n      if (self._x0 != null) [self._x0, self._y0] = proj.project_xy(self._x0, self._y0);\n      if (self._x1 != null) [self._x1, self._y1] = proj.project_xy(self._x1, self._y1);\n    } // if we have any coordinates that are categorical, convert them to\n    // synthetic coords here\n\n\n    if (this.renderer.plot_view.frame.x_ranges != null) {\n      // XXXX JUST TEMP FOR TESTS TO PASS\n      const xr = this.renderer.plot_view.frame.x_ranges[this.model.x_range_name];\n      const yr = this.renderer.plot_view.frame.y_ranges[this.model.y_range_name];\n\n      for (let [xname, yname] of this.model._coords) {\n        xname = `_${xname}`;\n        yname = `_${yname}`; // TODO (bev) more robust detection of multi-glyph case\n        // hand multi glyph case\n\n        if (self._xs != null) {\n          if (xr instanceof FactorRange) {\n            self[xname] = map(self[xname], arr => xr.v_synthetic(arr));\n          }\n\n          if (yr instanceof FactorRange) {\n            self[yname] = map(self[yname], arr => yr.v_synthetic(arr));\n          }\n        } else {\n          // hand standard glyph case\n          if (xr instanceof FactorRange) {\n            self[xname] = xr.v_synthetic(self[xname]);\n          }\n\n          if (yr instanceof FactorRange) {\n            self[yname] = yr.v_synthetic(self[yname]);\n          }\n        }\n      }\n    }\n\n    if (this.glglyph != null) this.glglyph.set_data_changed(self._x.length);\n\n    this._set_data(indices_to_update); //TODO doesn't take subset indices into account\n\n\n    this.index_data();\n  }\n\n  _set_data(_indices) {}\n\n  index_data() {\n    this.index = this._index_data();\n  }\n\n  mask_data(indices) {\n    // WebGL can do the clipping much more efficiently\n    if (this.glglyph != null || this._mask_data == null) return indices;else return this._mask_data();\n  }\n\n  map_data() {\n    // TODO: if using gl, skip this (when is this called?)\n    // map all the coordinate fields\n    const self = this;\n\n    for (let [xname, yname] of this.model._coords) {\n      const sxname = `s${xname}`;\n      const syname = `s${yname}`;\n      xname = `_${xname}`;\n      yname = `_${yname}`;\n\n      if (self[xname] != null && (isArray(self[xname][0]) || isTypedArray(self[xname][0]))) {\n        const n = self[xname].length;\n        self[sxname] = new Array(n);\n        self[syname] = new Array(n);\n\n        for (let i = 0; i < n; i++) {\n          const [sx, sy] = this.map_to_screen(self[xname][i], self[yname][i]);\n          self[sxname][i] = sx;\n          self[syname][i] = sy;\n        }\n      } else [self[sxname], self[syname]] = this.map_to_screen(self[xname], self[yname]);\n    }\n\n    this._map_data();\n  } // This is where specs not included in coords are computed, e.g. radius.\n\n\n  _map_data() {}\n\n  map_to_screen(x, y) {\n    return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n  }\n\n}\nGlyphView.__name__ = \"GlyphView\";\nexport class Glyph extends Model {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Glyph() {\n    this.prototype._coords = [];\n    this.internal({\n      x_range_name: [p.String, 'default'],\n      y_range_name: [p.String, 'default']\n    });\n  }\n\n  static coords(coords) {\n    const _coords = this.prototype._coords.concat(coords);\n\n    this.prototype._coords = _coords;\n    const result = {};\n\n    for (const [x, y] of coords) {\n      result[x] = [p.CoordinateSpec];\n      result[y] = [p.CoordinateSpec];\n    }\n\n    this.define(result);\n  }\n\n}\nGlyph.__name__ = \"Glyph\";\nGlyph.init_Glyph();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/glyph.js"],"names":["hittest","p","bbox","proj","visuals","View","Model","logger","map","extend","isArray","isTypedArray","LineView","FactorRange","GlyphView","constructor","arguments","_nohit_warned","Set","renderer","parent","has_webgl","glglyph","initialize","Visuals","model","lazy_initialize","webgl","plot_view","canvas_view","webgl_module","e","code","warn","Cls","type","gl","set_visuals","source","warm_cache","set_visuals_changed","render","ctx","indices","data","beginPath","_render","has_finished","notify_finished","_bounds","bounds","index","log_bounds","bb","empty","positive_x_bbs","search","positive_x","x","x0","x1","positive_y_bbs","positive_y","y","y0","y1","get_anchor_point","anchor","i","sx","sy","scenterx","scentery","sdist","scale","pts","spans","pts_location","dilate","pt0","pt1","n","length","halfspan","d","Float64Array","spt0","v_compute","spt1","_","Math","ceil","abs","draw_legend_for_index","_ctx","_bbox","_index","hit_test","geometry","_hit_point","_hit_span","_hit_rect","_hit_poly","has","debug","add","_hit_rect_against_index","sx0","sx1","sy0","sy1","xscale","r_invert","yscale","result","create_empty_hit_test_result","set_data","indices_to_update","materialize_dataspecs","set_all_indices","data_subset","k","v","charAt","self","use_map","_x","_y","project_xy","_xs","_ys","project_xsys","_x0","_y0","_x1","_y1","frame","x_ranges","xr","x_range_name","yr","y_ranges","y_range_name","xname","yname","_coords","arr","v_synthetic","set_data_changed","_set_data","index_data","_indices","_index_data","mask_data","_mask_data","map_data","sxname","syname","Array","map_to_screen","_map_data","__name__","Glyph","attrs","init_Glyph","prototype","internal","String","coords","concat","CoordinateSpec","define"],"mappings":"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","sourcesContent":["import * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport * as bbox from \"../../core/util/bbox\";\nimport * as proj from \"../../core/util/projections\";\nimport * as visuals from \"../../core/visuals\";\nimport { View } from \"../../core/view\";\nimport { Model } from \"../../model\";\nimport { logger } from \"../../core/logging\";\nimport { map } from \"../../core/util/arrayable\";\nimport { extend } from \"../../core/util/object\";\nimport { isArray, isTypedArray } from \"../../core/util/types\";\nimport { LineView } from \"./line\";\nimport { FactorRange } from \"../ranges/factor_range\";\nexport class GlyphView extends View {\n    constructor() {\n        super(...arguments);\n        this._nohit_warned = new Set();\n    }\n    get renderer() {\n        return this.parent;\n    }\n    get has_webgl() {\n        return this.glglyph != null;\n    }\n    initialize() {\n        super.initialize();\n        this.visuals = new visuals.Visuals(this.model);\n    }\n    async lazy_initialize() {\n        await super.lazy_initialize();\n        const { webgl } = this.renderer.plot_view.canvas_view;\n        if (webgl != null) {\n            let webgl_module = null;\n            try {\n                webgl_module = await import(\"./webgl/index\");\n            }\n            catch (e) {\n                // TODO: this exposes the underyling module system\n                if (e.code === 'MODULE_NOT_FOUND')\n                    logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');\n                else\n                    throw e;\n            }\n            if (webgl_module != null) {\n                const Cls = webgl_module[this.model.type + 'GLGlyph'];\n                if (Cls != null)\n                    this.glglyph = new Cls(webgl.gl, this);\n            }\n        }\n    }\n    set_visuals(source) {\n        this.visuals.warm_cache(source);\n        if (this.glglyph != null)\n            this.glglyph.set_visuals_changed();\n    }\n    render(ctx, indices, data) {\n        ctx.beginPath();\n        if (this.glglyph != null) {\n            if (this.glglyph.render(ctx, indices, data))\n                return;\n        }\n        this._render(ctx, indices, data);\n    }\n    has_finished() {\n        return true;\n    }\n    notify_finished() {\n        this.renderer.notify_finished();\n    }\n    _bounds(bounds) {\n        return bounds;\n    }\n    bounds() {\n        return this._bounds(this.index.bbox);\n    }\n    log_bounds() {\n        const bb = bbox.empty();\n        const positive_x_bbs = this.index.search(bbox.positive_x());\n        for (const x of positive_x_bbs) {\n            if (x.x0 < bb.x0)\n                bb.x0 = x.x0;\n            if (x.x1 > bb.x1)\n                bb.x1 = x.x1;\n        }\n        const positive_y_bbs = this.index.search(bbox.positive_y());\n        for (const y of positive_y_bbs) {\n            if (y.y0 < bb.y0)\n                bb.y0 = y.y0;\n            if (y.y1 > bb.y1)\n                bb.y1 = y.y1;\n        }\n        return this._bounds(bb);\n    }\n    get_anchor_point(anchor, i, [sx, sy]) {\n        switch (anchor) {\n            case \"center\": return { x: this.scenterx(i, sx, sy), y: this.scentery(i, sx, sy) };\n            default: return null;\n        }\n    }\n    sdist(scale, pts, spans, pts_location = \"edge\", dilate = false) {\n        let pt0;\n        let pt1;\n        const n = pts.length;\n        if (pts_location == 'center') {\n            const halfspan = map(spans, (d) => d / 2);\n            pt0 = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                pt0[i] = pts[i] - halfspan[i];\n            }\n            pt1 = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                pt1[i] = pts[i] + halfspan[i];\n            }\n        }\n        else {\n            pt0 = pts;\n            pt1 = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                pt1[i] = pt0[i] + spans[i];\n            }\n        }\n        const spt0 = scale.v_compute(pt0);\n        const spt1 = scale.v_compute(pt1);\n        if (dilate)\n            return map(spt0, (_, i) => Math.ceil(Math.abs(spt1[i] - spt0[i])));\n        else\n            return map(spt0, (_, i) => Math.abs(spt1[i] - spt0[i]));\n    }\n    draw_legend_for_index(_ctx, _bbox, _index) { }\n    hit_test(geometry) {\n        switch (geometry.type) {\n            case \"point\":\n                if (this._hit_point != null)\n                    return this._hit_point(geometry);\n                break;\n            case \"span\":\n                if (this._hit_span != null)\n                    return this._hit_span(geometry);\n                break;\n            case \"rect\":\n                if (this._hit_rect != null)\n                    return this._hit_rect(geometry);\n                break;\n            case \"poly\":\n                if (this._hit_poly != null)\n                    return this._hit_poly(geometry);\n                break;\n        }\n        if (!this._nohit_warned.has(geometry.type)) {\n            logger.debug(`'${geometry.type}' selection not available for ${this.model.type}`);\n            this._nohit_warned.add(geometry.type);\n        }\n        return null;\n    }\n    _hit_rect_against_index(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = this.index.indices({ x0, x1, y0, y1 });\n        return result;\n    }\n    set_data(source, indices, indices_to_update) {\n        let data = this.model.materialize_dataspecs(source);\n        this.visuals.set_all_indices(indices);\n        if (indices && !(this instanceof LineView)) {\n            const data_subset = {};\n            for (const k in data) {\n                const v = data[k];\n                if (k.charAt(0) === '_')\n                    data_subset[k] = indices.map((i) => v[i]);\n                else\n                    data_subset[k] = v;\n            }\n            data = data_subset;\n        }\n        const self = this;\n        extend(self, data);\n        // TODO (bev) Should really probably delegate computing projected\n        // coordinates to glyphs, instead of centralizing here in one place.\n        if (this.renderer.plot_view.model.use_map) {\n            if (self._x != null)\n                [self._x, self._y] = proj.project_xy(self._x, self._y);\n            if (self._xs != null)\n                [self._xs, self._ys] = proj.project_xsys(self._xs, self._ys);\n            if (self._x0 != null)\n                [self._x0, self._y0] = proj.project_xy(self._x0, self._y0);\n            if (self._x1 != null)\n                [self._x1, self._y1] = proj.project_xy(self._x1, self._y1);\n        }\n        // if we have any coordinates that are categorical, convert them to\n        // synthetic coords here\n        if (this.renderer.plot_view.frame.x_ranges != null) { // XXXX JUST TEMP FOR TESTS TO PASS\n            const xr = this.renderer.plot_view.frame.x_ranges[this.model.x_range_name];\n            const yr = this.renderer.plot_view.frame.y_ranges[this.model.y_range_name];\n            for (let [xname, yname] of this.model._coords) {\n                xname = `_${xname}`;\n                yname = `_${yname}`;\n                // TODO (bev) more robust detection of multi-glyph case\n                // hand multi glyph case\n                if (self._xs != null) {\n                    if (xr instanceof FactorRange) {\n                        self[xname] = map(self[xname], (arr) => xr.v_synthetic(arr));\n                    }\n                    if (yr instanceof FactorRange) {\n                        self[yname] = map(self[yname], (arr) => yr.v_synthetic(arr));\n                    }\n                }\n                else {\n                    // hand standard glyph case\n                    if (xr instanceof FactorRange) {\n                        self[xname] = xr.v_synthetic(self[xname]);\n                    }\n                    if (yr instanceof FactorRange) {\n                        self[yname] = yr.v_synthetic(self[yname]);\n                    }\n                }\n            }\n        }\n        if (this.glglyph != null)\n            this.glglyph.set_data_changed(self._x.length);\n        this._set_data(indices_to_update); //TODO doesn't take subset indices into account\n        this.index_data();\n    }\n    _set_data(_indices) { }\n    index_data() {\n        this.index = this._index_data();\n    }\n    mask_data(indices) {\n        // WebGL can do the clipping much more efficiently\n        if (this.glglyph != null || this._mask_data == null)\n            return indices;\n        else\n            return this._mask_data();\n    }\n    map_data() {\n        // TODO: if using gl, skip this (when is this called?)\n        // map all the coordinate fields\n        const self = this;\n        for (let [xname, yname] of this.model._coords) {\n            const sxname = `s${xname}`;\n            const syname = `s${yname}`;\n            xname = `_${xname}`;\n            yname = `_${yname}`;\n            if (self[xname] != null && (isArray(self[xname][0]) || isTypedArray(self[xname][0]))) {\n                const n = self[xname].length;\n                self[sxname] = new Array(n);\n                self[syname] = new Array(n);\n                for (let i = 0; i < n; i++) {\n                    const [sx, sy] = this.map_to_screen(self[xname][i], self[yname][i]);\n                    self[sxname][i] = sx;\n                    self[syname][i] = sy;\n                }\n            }\n            else\n                [self[sxname], self[syname]] = this.map_to_screen(self[xname], self[yname]);\n        }\n        this._map_data();\n    }\n    // This is where specs not included in coords are computed, e.g. radius.\n    _map_data() { }\n    map_to_screen(x, y) {\n        return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    }\n}\nGlyphView.__name__ = \"GlyphView\";\nexport class Glyph extends Model {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Glyph() {\n        this.prototype._coords = [];\n        this.internal({\n            x_range_name: [p.String, 'default'],\n            y_range_name: [p.String, 'default'],\n        });\n    }\n    static coords(coords) {\n        const _coords = this.prototype._coords.concat(coords);\n        this.prototype._coords = _coords;\n        const result = {};\n        for (const [x, y] of coords) {\n            result[x] = [p.CoordinateSpec];\n            result[y] = [p.CoordinateSpec];\n        }\n        this.define(result);\n    }\n}\nGlyph.__name__ = \"Glyph\";\nGlyph.init_Glyph();\n//# sourceMappingURL=glyph.js.map"]},"metadata":{},"sourceType":"module"}