{"ast":null,"code":"import { logger } from \"../core/logging\";\nimport { Document } from \"../document\";\nimport { Message } from \"../protocol/message\";\nimport { Receiver } from \"../protocol/receiver\";\nimport { ClientSession } from \"./session\";\nexport const DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\nexport const DEFAULT_TOKEN = \"eyJzZXNzaW9uX2lkIjogImRlZmF1bHQifQ\";\nlet _connection_count = 0;\nexport function parse_token(token) {\n  let payload = token.split('.')[0];\n  const mod = payload.length % 4;\n  if (mod != 0) payload = payload + \"=\".repeat(4 - mod);\n  return JSON.parse(atob(payload.replace(/_/g, '/').replace(/-/g, '+')));\n}\nexport class ClientConnection {\n  constructor(url = DEFAULT_SERVER_WEBSOCKET_URL, token = DEFAULT_TOKEN, args_string = null) {\n    this.url = url;\n    this.token = token;\n    this.args_string = args_string;\n    this._number = _connection_count++;\n    this.socket = null;\n    this.session = null;\n    this.closed_permanently = false;\n    this._current_handler = null;\n    this._pending_replies = new Map();\n    this._pending_messages = [];\n    this._receiver = new Receiver();\n    this.id = parse_token(token).session_id.split('.')[0];\n    logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`);\n  }\n\n  async connect() {\n    if (this.closed_permanently) throw new Error(\"Cannot connect() a closed ClientConnection\");\n    if (this.socket != null) throw new Error(\"Already connected\");\n    this._current_handler = null;\n\n    this._pending_replies.clear();\n\n    this._pending_messages = [];\n\n    try {\n      let versioned_url = `${this.url}`;\n      if (this.args_string != null && this.args_string.length > 0) versioned_url += `?${this.args_string}`;\n      this.socket = new WebSocket(versioned_url, [\"bokeh\", this.token]);\n      return new Promise((resolve, reject) => {\n        // \"arraybuffer\" gives us binary data we can look at;\n        // if we just needed an opaque blob we could use \"blob\"\n        this.socket.binaryType = \"arraybuffer\";\n\n        this.socket.onopen = () => this._on_open(resolve, reject);\n\n        this.socket.onmessage = event => this._on_message(event);\n\n        this.socket.onclose = event => this._on_close(event, reject);\n\n        this.socket.onerror = () => this._on_error(reject);\n      });\n    } catch (error) {\n      logger.error(`websocket creation failed to url: ${this.url}`);\n      logger.error(` - ${error}`);\n      throw error;\n    }\n  }\n\n  close() {\n    if (!this.closed_permanently) {\n      logger.debug(`Permanently closing websocket connection ${this._number}`);\n      this.closed_permanently = true;\n      if (this.socket != null) this.socket.close(1000, `close method called on ClientConnection ${this._number}`);\n\n      this.session._connection_closed();\n    }\n  }\n\n  _schedule_reconnect(milliseconds) {\n    const retry = () => {\n      // TODO commented code below until we fix reconnection to repull\n      // the document when required. Otherwise, we get a lot of\n      // confusing errors that are causing trouble when debugging.\n\n      /*\n      if (this.closed_permanently) {\n      */\n      if (!this.closed_permanently) logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`);\n      return;\n      /*\n      } else {\n        logger.debug(`Attempting to reconnect websocket ${this._number}`)\n        this.connect()\n      }\n      */\n    };\n\n    setTimeout(retry, milliseconds);\n  }\n\n  send(message) {\n    if (this.socket == null) throw new Error(`not connected so cannot send ${message}`);\n    message.send(this.socket);\n  }\n\n  async send_with_reply(message) {\n    const reply = await new Promise((resolve, reject) => {\n      this._pending_replies.set(message.msgid(), {\n        resolve,\n        reject\n      });\n\n      this.send(message);\n    });\n    if (reply.msgtype() === \"ERROR\") throw new Error(`Error reply ${reply.content.text}`);else return reply;\n  }\n\n  async _pull_doc_json() {\n    const message = Message.create(\"PULL-DOC-REQ\", {});\n    const reply = await this.send_with_reply(message);\n    if (!(\"doc\" in reply.content)) throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\n    return reply.content.doc;\n  }\n\n  async _repull_session_doc(resolve, reject) {\n    var _a;\n\n    logger.debug(this.session ? \"Repulling session\" : \"Pulling session for first time\");\n\n    try {\n      const doc_json = await this._pull_doc_json();\n\n      if (this.session == null) {\n        if (this.closed_permanently) {\n          logger.debug(\"Got new document after connection was already closed\");\n          reject(new Error(\"The connection has been closed\"));\n        } else {\n          const document = Document.from_json(doc_json); // Constructing models changes some of their attributes, we deal with that\n          // here. This happens when models set attributes during construction\n          // or initialization.\n\n          const patch = Document._compute_patch_since_json(doc_json, document);\n\n          if (patch.events.length > 0) {\n            logger.debug(`Sending ${patch.events.length} changes from model construction back to server`);\n            const patch_message = Message.create('PATCH-DOC', {}, patch);\n            this.send(patch_message);\n          }\n\n          this.session = new ClientSession(this, document, this.id);\n\n          for (const msg of this._pending_messages) {\n            this.session.handle(msg);\n          }\n\n          this._pending_messages = [];\n          logger.debug(\"Created a new session from new pulled doc\");\n          resolve(this.session);\n        }\n      } else {\n        this.session.document.replace_with_json(doc_json);\n        logger.debug(\"Updated existing session with new pulled doc\"); // Since the session already exists, we don't need to call `resolve` again.\n      }\n    } catch (error) {\n      (_a = console.trace) === null || _a === void 0 ? void 0 : _a.call(console, error);\n      logger.error(`Failed to repull session ${error}`);\n      reject(error);\n    }\n  }\n\n  _on_open(resolve, reject) {\n    logger.info(`Websocket connection ${this._number} is now open`);\n\n    this._current_handler = message => {\n      this._awaiting_ack_handler(message, resolve, reject);\n    };\n  }\n\n  _on_message(event) {\n    if (this._current_handler == null) logger.error(\"Got a message with no current handler set\");\n\n    try {\n      this._receiver.consume(event.data);\n    } catch (e) {\n      this._close_bad_protocol(e.toString());\n    }\n\n    const msg = this._receiver.message;\n\n    if (msg != null) {\n      const problem = msg.problem();\n      if (problem != null) this._close_bad_protocol(problem);\n\n      this._current_handler(msg);\n    }\n  }\n\n  _on_close(event, reject) {\n    logger.info(`Lost websocket ${this._number} connection, ${event.code} (${event.reason})`);\n    this.socket = null;\n\n    this._pending_replies.forEach(pr => pr.reject(\"Disconnected\"));\n\n    this._pending_replies.clear();\n\n    if (!this.closed_permanently) this._schedule_reconnect(2000);\n    reject(new Error(`Lost websocket connection, ${event.code} (${event.reason})`));\n  }\n\n  _on_error(reject) {\n    logger.debug(`Websocket error on socket ${this._number}`);\n    const msg = \"Could not open websocket\";\n    logger.error(`Failed to connect to Bokeh server: ${msg}`);\n    reject(new Error(msg));\n  }\n\n  _close_bad_protocol(detail) {\n    logger.error(`Closing connection: ${detail}`);\n    if (this.socket != null) this.socket.close(1002, detail); // 1002 = protocol error\n  }\n\n  _awaiting_ack_handler(message, resolve, reject) {\n    if (message.msgtype() === \"ACK\") {\n      this._current_handler = message => this._steady_state_handler(message); // Reload any sessions\n\n\n      this._repull_session_doc(resolve, reject);\n    } else this._close_bad_protocol(\"First message was not an ACK\");\n  }\n\n  _steady_state_handler(message) {\n    const reqid = message.reqid();\n\n    const pr = this._pending_replies.get(reqid);\n\n    if (pr) {\n      this._pending_replies.delete(reqid);\n\n      pr.resolve(message);\n    } else if (this.session) {\n      this.session.handle(message);\n    } else if (message.msgtype() != 'PATCH-DOC') {\n      // This branch can be executed only before we get the document.\n      // When we get the document, all of the patches will already be incorporated.\n      // In general, it's not possible to apply patches received before the document,\n      // since they may change some models that were removed before serving the document.\n      this._pending_messages.push(message);\n    }\n  }\n\n}\nClientConnection.__name__ = \"ClientConnection\";\nexport function pull_session(url, token, args_string) {\n  const connection = new ClientConnection(url, token, args_string);\n  return connection.connect();\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/client/connection.js"],"names":["logger","Document","Message","Receiver","ClientSession","DEFAULT_SERVER_WEBSOCKET_URL","DEFAULT_TOKEN","_connection_count","parse_token","token","payload","split","mod","length","repeat","JSON","parse","atob","replace","ClientConnection","constructor","url","args_string","_number","socket","session","closed_permanently","_current_handler","_pending_replies","Map","_pending_messages","_receiver","id","session_id","debug","connect","Error","clear","versioned_url","WebSocket","Promise","resolve","reject","binaryType","onopen","_on_open","onmessage","event","_on_message","onclose","_on_close","onerror","_on_error","error","close","_connection_closed","_schedule_reconnect","milliseconds","retry","info","setTimeout","send","message","send_with_reply","reply","set","msgid","msgtype","content","text","_pull_doc_json","create","doc","_repull_session_doc","_a","doc_json","document","from_json","patch","_compute_patch_since_json","events","patch_message","msg","handle","replace_with_json","console","trace","call","_awaiting_ack_handler","consume","data","e","_close_bad_protocol","toString","problem","code","reason","forEach","pr","detail","_steady_state_handler","reqid","get","delete","push","__name__","pull_session","connection"],"mappings":"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","sourcesContent":["import { logger } from \"../core/logging\";\nimport { Document } from \"../document\";\nimport { Message } from \"../protocol/message\";\nimport { Receiver } from \"../protocol/receiver\";\nimport { ClientSession } from \"./session\";\nexport const DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\nexport const DEFAULT_TOKEN = \"eyJzZXNzaW9uX2lkIjogImRlZmF1bHQifQ\";\nlet _connection_count = 0;\nexport function parse_token(token) {\n    let payload = token.split('.')[0];\n    const mod = payload.length % 4;\n    if (mod != 0)\n        payload = payload + \"=\".repeat(4 - mod);\n    return JSON.parse(atob(payload.replace(/_/g, '/').replace(/-/g, '+')));\n}\nexport class ClientConnection {\n    constructor(url = DEFAULT_SERVER_WEBSOCKET_URL, token = DEFAULT_TOKEN, args_string = null) {\n        this.url = url;\n        this.token = token;\n        this.args_string = args_string;\n        this._number = _connection_count++;\n        this.socket = null;\n        this.session = null;\n        this.closed_permanently = false;\n        this._current_handler = null;\n        this._pending_replies = new Map();\n        this._pending_messages = [];\n        this._receiver = new Receiver();\n        this.id = parse_token(token).session_id.split('.')[0];\n        logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`);\n    }\n    async connect() {\n        if (this.closed_permanently)\n            throw new Error(\"Cannot connect() a closed ClientConnection\");\n        if (this.socket != null)\n            throw new Error(\"Already connected\");\n        this._current_handler = null;\n        this._pending_replies.clear();\n        this._pending_messages = [];\n        try {\n            let versioned_url = `${this.url}`;\n            if (this.args_string != null && this.args_string.length > 0)\n                versioned_url += `?${this.args_string}`;\n            this.socket = new WebSocket(versioned_url, [\"bokeh\", this.token]);\n            return new Promise((resolve, reject) => {\n                // \"arraybuffer\" gives us binary data we can look at;\n                // if we just needed an opaque blob we could use \"blob\"\n                this.socket.binaryType = \"arraybuffer\";\n                this.socket.onopen = () => this._on_open(resolve, reject);\n                this.socket.onmessage = (event) => this._on_message(event);\n                this.socket.onclose = (event) => this._on_close(event, reject);\n                this.socket.onerror = () => this._on_error(reject);\n            });\n        }\n        catch (error) {\n            logger.error(`websocket creation failed to url: ${this.url}`);\n            logger.error(` - ${error}`);\n            throw error;\n        }\n    }\n    close() {\n        if (!this.closed_permanently) {\n            logger.debug(`Permanently closing websocket connection ${this._number}`);\n            this.closed_permanently = true;\n            if (this.socket != null)\n                this.socket.close(1000, `close method called on ClientConnection ${this._number}`);\n            this.session._connection_closed();\n        }\n    }\n    _schedule_reconnect(milliseconds) {\n        const retry = () => {\n            // TODO commented code below until we fix reconnection to repull\n            // the document when required. Otherwise, we get a lot of\n            // confusing errors that are causing trouble when debugging.\n            /*\n            if (this.closed_permanently) {\n            */\n            if (!this.closed_permanently)\n                logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`);\n            return;\n            /*\n            } else {\n              logger.debug(`Attempting to reconnect websocket ${this._number}`)\n              this.connect()\n            }\n            */\n        };\n        setTimeout(retry, milliseconds);\n    }\n    send(message) {\n        if (this.socket == null)\n            throw new Error(`not connected so cannot send ${message}`);\n        message.send(this.socket);\n    }\n    async send_with_reply(message) {\n        const reply = await new Promise((resolve, reject) => {\n            this._pending_replies.set(message.msgid(), { resolve, reject });\n            this.send(message);\n        });\n        if (reply.msgtype() === \"ERROR\")\n            throw new Error(`Error reply ${reply.content.text}`);\n        else\n            return reply;\n    }\n    async _pull_doc_json() {\n        const message = Message.create(\"PULL-DOC-REQ\", {});\n        const reply = await this.send_with_reply(message);\n        if (!(\"doc\" in reply.content))\n            throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\n        return reply.content.doc;\n    }\n    async _repull_session_doc(resolve, reject) {\n        var _a;\n        logger.debug(this.session ? \"Repulling session\" : \"Pulling session for first time\");\n        try {\n            const doc_json = await this._pull_doc_json();\n            if (this.session == null) {\n                if (this.closed_permanently) {\n                    logger.debug(\"Got new document after connection was already closed\");\n                    reject(new Error(\"The connection has been closed\"));\n                }\n                else {\n                    const document = Document.from_json(doc_json);\n                    // Constructing models changes some of their attributes, we deal with that\n                    // here. This happens when models set attributes during construction\n                    // or initialization.\n                    const patch = Document._compute_patch_since_json(doc_json, document);\n                    if (patch.events.length > 0) {\n                        logger.debug(`Sending ${patch.events.length} changes from model construction back to server`);\n                        const patch_message = Message.create('PATCH-DOC', {}, patch);\n                        this.send(patch_message);\n                    }\n                    this.session = new ClientSession(this, document, this.id);\n                    for (const msg of this._pending_messages) {\n                        this.session.handle(msg);\n                    }\n                    this._pending_messages = [];\n                    logger.debug(\"Created a new session from new pulled doc\");\n                    resolve(this.session);\n                }\n            }\n            else {\n                this.session.document.replace_with_json(doc_json);\n                logger.debug(\"Updated existing session with new pulled doc\");\n                // Since the session already exists, we don't need to call `resolve` again.\n            }\n        }\n        catch (error) {\n            (_a = console.trace) === null || _a === void 0 ? void 0 : _a.call(console, error);\n            logger.error(`Failed to repull session ${error}`);\n            reject(error);\n        }\n    }\n    _on_open(resolve, reject) {\n        logger.info(`Websocket connection ${this._number} is now open`);\n        this._current_handler = (message) => {\n            this._awaiting_ack_handler(message, resolve, reject);\n        };\n    }\n    _on_message(event) {\n        if (this._current_handler == null)\n            logger.error(\"Got a message with no current handler set\");\n        try {\n            this._receiver.consume(event.data);\n        }\n        catch (e) {\n            this._close_bad_protocol(e.toString());\n        }\n        const msg = this._receiver.message;\n        if (msg != null) {\n            const problem = msg.problem();\n            if (problem != null)\n                this._close_bad_protocol(problem);\n            this._current_handler(msg);\n        }\n    }\n    _on_close(event, reject) {\n        logger.info(`Lost websocket ${this._number} connection, ${event.code} (${event.reason})`);\n        this.socket = null;\n        this._pending_replies.forEach((pr) => pr.reject(\"Disconnected\"));\n        this._pending_replies.clear();\n        if (!this.closed_permanently)\n            this._schedule_reconnect(2000);\n        reject(new Error(`Lost websocket connection, ${event.code} (${event.reason})`));\n    }\n    _on_error(reject) {\n        logger.debug(`Websocket error on socket ${this._number}`);\n        const msg = \"Could not open websocket\";\n        logger.error(`Failed to connect to Bokeh server: ${msg}`);\n        reject(new Error(msg));\n    }\n    _close_bad_protocol(detail) {\n        logger.error(`Closing connection: ${detail}`);\n        if (this.socket != null)\n            this.socket.close(1002, detail); // 1002 = protocol error\n    }\n    _awaiting_ack_handler(message, resolve, reject) {\n        if (message.msgtype() === \"ACK\") {\n            this._current_handler = (message) => this._steady_state_handler(message);\n            // Reload any sessions\n            this._repull_session_doc(resolve, reject);\n        }\n        else\n            this._close_bad_protocol(\"First message was not an ACK\");\n    }\n    _steady_state_handler(message) {\n        const reqid = message.reqid();\n        const pr = this._pending_replies.get(reqid);\n        if (pr) {\n            this._pending_replies.delete(reqid);\n            pr.resolve(message);\n        }\n        else if (this.session) {\n            this.session.handle(message);\n        }\n        else if (message.msgtype() != 'PATCH-DOC') {\n            // This branch can be executed only before we get the document.\n            // When we get the document, all of the patches will already be incorporated.\n            // In general, it's not possible to apply patches received before the document,\n            // since they may change some models that were removed before serving the document.\n            this._pending_messages.push(message);\n        }\n    }\n}\nClientConnection.__name__ = \"ClientConnection\";\nexport function pull_session(url, token, args_string) {\n    const connection = new ClientConnection(url, token, args_string);\n    return connection.connect();\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"module"}