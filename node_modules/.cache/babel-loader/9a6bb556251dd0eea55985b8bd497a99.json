{"ast":null,"code":"import { Models } from \"../base\";\nimport { version as js_version } from \"../version\";\nimport { logger } from \"../core/logging\";\nimport { LODStart, LODEnd } from \"../core/bokeh_events\";\nimport { HasProps } from \"../core/has_props\";\nimport { Signal0 } from \"../core/signaling\";\nimport { is_ref } from \"../core/util/refs\";\nimport { decode_column_data } from \"../core/util/serialization\";\nimport { MultiDict, Set as OurSet } from \"../core/util/data_structures\";\nimport { difference, intersection, copy, includes } from \"../core/util/array\";\nimport { values } from \"../core/util/object\";\nimport { isEqual } from \"../core/util/eq\";\nimport { isArray, isPlainObject } from \"../core/util/types\";\nimport { LayoutDOM } from \"../models/layouts/layout_dom\";\nimport { ColumnDataSource } from \"../models/sources/column_data_source\";\nimport { Model } from \"../model\";\nimport { ModelChangedEvent, RootAddedEvent, RootRemovedEvent, TitleChangedEvent, MessageSentEvent } from \"./events\";\nexport class EventManager {\n  constructor(document) {\n    this.document = document; // Dispatches events to the subscribed models\n\n    this.session = null;\n    this.subscribed_models = new Set();\n  }\n\n  send_event(bokeh_event) {\n    const event = new MessageSentEvent(this.document, \"bokeh_event\", bokeh_event.to_json());\n\n    this.document._trigger_on_change(event);\n  }\n\n  trigger(event) {\n    for (const id of this.subscribed_models) {\n      if (event.origin != null && event.origin.id !== id) continue;\n      const model = this.document._all_models[id];\n      if (model != null && model instanceof Model) model._process_event(event);\n    }\n  }\n\n}\nEventManager.__name__ = \"EventManager\";\nexport const documents = [];\nexport const DEFAULT_TITLE = \"Bokeh Application\"; // This class should match the API of the Python Document class\n// as much as possible.\n\nexport class Document {\n  constructor() {\n    documents.push(this);\n    this._init_timestamp = Date.now();\n    this._title = DEFAULT_TITLE;\n    this._roots = [];\n    this._all_models = {};\n    this._all_models_by_name = new MultiDict();\n    this._all_models_freeze_count = 0;\n    this._callbacks = [];\n    this._message_callbacks = new Map();\n    this.event_manager = new EventManager(this);\n    this.idle = new Signal0(this, \"idle\");\n    this._idle_roots = new WeakMap(); // TODO: WeakSet would be better\n\n    this._interactive_timestamp = null;\n    this._interactive_plot = null;\n  }\n\n  get layoutables() {\n    return this._roots.filter(root => root instanceof LayoutDOM);\n  }\n\n  get is_idle() {\n    for (const root of this.layoutables) {\n      if (!this._idle_roots.has(root)) return false;\n    }\n\n    return true;\n  }\n\n  notify_idle(model) {\n    this._idle_roots.set(model, true);\n\n    if (this.is_idle) {\n      logger.info(`document idle at ${Date.now() - this._init_timestamp} ms`);\n      this.idle.emit();\n    }\n  }\n\n  clear() {\n    this._push_all_models_freeze();\n\n    try {\n      while (this._roots.length > 0) {\n        this.remove_root(this._roots[0]);\n      }\n    } finally {\n      this._pop_all_models_freeze();\n    }\n  }\n\n  interactive_start(plot) {\n    if (this._interactive_plot == null) {\n      this._interactive_plot = plot;\n\n      this._interactive_plot.trigger_event(new LODStart());\n    }\n\n    this._interactive_timestamp = Date.now();\n  }\n\n  interactive_stop(plot) {\n    if (this._interactive_plot != null && this._interactive_plot.id === plot.id) {\n      this._interactive_plot.trigger_event(new LODEnd());\n    }\n\n    this._interactive_plot = null;\n    this._interactive_timestamp = null;\n  }\n\n  interactive_duration() {\n    if (this._interactive_timestamp == null) return -1;else return Date.now() - this._interactive_timestamp;\n  }\n\n  destructively_move(dest_doc) {\n    if (dest_doc === this) {\n      throw new Error(\"Attempted to overwrite a document with itself\");\n    }\n\n    dest_doc.clear(); // we have to remove ALL roots before adding any\n    // to the new doc or else models referenced from multiple\n    // roots could be in both docs at once, which isn't allowed.\n\n    const roots = copy(this._roots);\n    this.clear();\n\n    for (const root of roots) {\n      if (root.document != null) throw new Error(`Somehow we didn't detach ${root}`);\n    }\n\n    if (Object.keys(this._all_models).length !== 0) {\n      throw new Error(`this._all_models still had stuff in it: ${this._all_models}`);\n    }\n\n    for (const root of roots) {\n      dest_doc.add_root(root);\n    }\n\n    dest_doc.set_title(this._title);\n  } // TODO other fields of doc\n\n\n  _push_all_models_freeze() {\n    this._all_models_freeze_count += 1;\n  }\n\n  _pop_all_models_freeze() {\n    this._all_models_freeze_count -= 1;\n\n    if (this._all_models_freeze_count === 0) {\n      this._recompute_all_models();\n    }\n  }\n  /*protected*/\n\n\n  _invalidate_all_models() {\n    logger.debug(\"invalidating document models\"); // if freeze count is > 0, we'll recompute on unfreeze\n\n    if (this._all_models_freeze_count === 0) {\n      this._recompute_all_models();\n    }\n  }\n\n  _recompute_all_models() {\n    let new_all_models_set = new OurSet();\n\n    for (const r of this._roots) {\n      new_all_models_set = new_all_models_set.union(r.references());\n    }\n\n    const old_all_models_set = new OurSet(values(this._all_models));\n    const to_detach = old_all_models_set.diff(new_all_models_set);\n    const to_attach = new_all_models_set.diff(old_all_models_set);\n    const recomputed = {};\n\n    for (const m of new_all_models_set.values) {\n      recomputed[m.id] = m;\n    }\n\n    for (const d of to_detach.values) {\n      d.detach_document();\n      if (d instanceof Model && d.name != null) this._all_models_by_name.remove_value(d.name, d);\n    }\n\n    for (const a of to_attach.values) {\n      a.attach_document(this);\n      if (a instanceof Model && a.name != null) this._all_models_by_name.add_value(a.name, a);\n    }\n\n    this._all_models = recomputed;\n  }\n\n  roots() {\n    return this._roots;\n  }\n\n  add_root(model, setter_id) {\n    logger.debug(`Adding root: ${model}`);\n    if (includes(this._roots, model)) return;\n\n    this._push_all_models_freeze();\n\n    try {\n      this._roots.push(model);\n    } finally {\n      this._pop_all_models_freeze();\n    }\n\n    this._trigger_on_change(new RootAddedEvent(this, model, setter_id));\n  }\n\n  remove_root(model, setter_id) {\n    const i = this._roots.indexOf(model);\n\n    if (i < 0) return;\n\n    this._push_all_models_freeze();\n\n    try {\n      this._roots.splice(i, 1);\n    } finally {\n      this._pop_all_models_freeze();\n    }\n\n    this._trigger_on_change(new RootRemovedEvent(this, model, setter_id));\n  }\n\n  title() {\n    return this._title;\n  }\n\n  set_title(title, setter_id) {\n    if (title !== this._title) {\n      this._title = title;\n\n      this._trigger_on_change(new TitleChangedEvent(this, title, setter_id));\n    }\n  }\n\n  get_model_by_id(model_id) {\n    if (model_id in this._all_models) {\n      return this._all_models[model_id];\n    } else {\n      return null;\n    }\n  }\n\n  get_model_by_name(name) {\n    return this._all_models_by_name.get_one(name, `Multiple models are named '${name}'`);\n  }\n\n  on_message(msg_type, callback) {\n    const message_callbacks = this._message_callbacks.get(msg_type);\n\n    if (message_callbacks == null) this._message_callbacks.set(msg_type, new Set([callback]));else message_callbacks.add(callback);\n  }\n\n  remove_on_message(msg_type, callback) {\n    var _a;\n\n    (_a = this._message_callbacks.get(msg_type)) === null || _a === void 0 ? void 0 : _a.delete(callback);\n  }\n\n  _trigger_on_message(msg_type, msg_data) {\n    const message_callbacks = this._message_callbacks.get(msg_type);\n\n    if (message_callbacks != null) {\n      for (const cb of message_callbacks) {\n        cb(msg_data);\n      }\n    }\n  }\n\n  on_change(callback) {\n    if (!includes(this._callbacks, callback)) this._callbacks.push(callback);\n  }\n\n  remove_on_change(callback) {\n    const i = this._callbacks.indexOf(callback);\n\n    if (i >= 0) this._callbacks.splice(i, 1);\n  }\n\n  _trigger_on_change(event) {\n    for (const cb of this._callbacks) {\n      cb(event);\n    }\n  } // called by the model\n\n\n  _notify_change(model, attr, old, new_, options) {\n    if (attr === 'name') {\n      this._all_models_by_name.remove_value(old, model);\n\n      if (new_ != null) this._all_models_by_name.add_value(new_, model);\n    }\n\n    const setter_id = options != null ? options.setter_id : void 0;\n    const hint = options != null ? options.hint : void 0;\n\n    this._trigger_on_change(new ModelChangedEvent(this, model, attr, old, new_, setter_id, hint));\n  }\n\n  static _references_json(references, include_defaults = true) {\n    const references_json = [];\n\n    for (const r of references) {\n      const struct = r.struct();\n      struct.attributes = r.attributes_as_json(include_defaults); // server doesn't want id in here since it's already in ref above\n\n      delete struct.attributes.id;\n      references_json.push(struct);\n    }\n\n    return references_json;\n  }\n\n  static _instantiate_object(obj_id, obj_type, obj_attrs) {\n    const full_attrs = Object.assign(Object.assign({}, obj_attrs), {\n      id: obj_id,\n      __deferred__: true\n    });\n    const model = Models(obj_type);\n    return new model(full_attrs);\n  } // given a JSON representation of all models in a graph, return a\n  // dict of new model objects\n\n\n  static _instantiate_references_json(references_json, existing_models) {\n    // Create all instances, but without setting their props\n    const references = {};\n\n    for (const obj of references_json) {\n      const obj_id = obj.id;\n      const obj_type = obj.type;\n      const obj_attrs = obj.attributes || {};\n      let instance;\n      if (obj_id in existing_models) instance = existing_models[obj_id];else {\n        instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\n        if (obj.subtype != null) instance.set_subtype(obj.subtype);\n      }\n      references[instance.id] = instance;\n    }\n\n    return references;\n  } // if v looks like a ref, or a collection, resolve it, otherwise return it unchanged\n  // recurse into collections but not into HasProps\n\n\n  static _resolve_refs(value, old_references, new_references) {\n    function resolve_ref(v) {\n      if (is_ref(v)) {\n        if (v.id in old_references) return old_references[v.id];else if (v.id in new_references) return new_references[v.id];else throw new Error(`reference ${JSON.stringify(v)} isn't known (not in Document?)`);\n      } else if (isArray(v)) return resolve_array(v);else if (isPlainObject(v)) return resolve_dict(v);else return v;\n    }\n\n    function resolve_array(array) {\n      const results = [];\n\n      for (const v of array) {\n        results.push(resolve_ref(v));\n      }\n\n      return results;\n    }\n\n    function resolve_dict(dict) {\n      const resolved = {};\n\n      for (const k in dict) {\n        const v = dict[k];\n        resolved[k] = resolve_ref(v);\n      }\n\n      return resolved;\n    }\n\n    return resolve_ref(value);\n  } // given a JSON representation of all models in a graph and new\n  // model instances, set the properties on the models from the\n  // JSON\n\n\n  static _initialize_references_json(references_json, old_references, new_references) {\n    const to_update = {};\n\n    for (const obj of references_json) {\n      const obj_id = obj.id;\n      const obj_attrs = obj.attributes;\n      const was_new = !(obj_id in old_references);\n      const instance = !was_new ? old_references[obj_id] : new_references[obj_id]; // replace references with actual instances in obj_attrs\n\n      const resolved_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);\n\n      to_update[instance.id] = [instance, resolved_attrs, was_new];\n    }\n\n    function foreach_depth_first(items, f) {\n      const already_started = {};\n\n      function foreach_value(v) {\n        if (v instanceof HasProps) {\n          // note that we ignore instances that aren't updated (not in to_update)\n          if (!(v.id in already_started) && v.id in items) {\n            already_started[v.id] = true;\n            const [, attrs, was_new] = items[v.id];\n\n            for (const a in attrs) {\n              const e = attrs[a];\n              foreach_value(e);\n            }\n\n            f(v, attrs, was_new);\n          }\n        } else if (isArray(v)) {\n          for (const e of v) foreach_value(e);\n        } else if (isPlainObject(v)) {\n          for (const k in v) {\n            const e = v[k];\n            foreach_value(e);\n          }\n        }\n      }\n\n      for (const k in items) {\n        const [instance,,] = items[k];\n        foreach_value(instance);\n      }\n    } // this first pass removes all 'refs' replacing them with real instances\n\n\n    foreach_depth_first(to_update, function (instance, attrs, was_new) {\n      if (was_new) instance.setv(attrs, {\n        silent: true\n      });\n    }); // after removing all the refs, we can run the initialize code safely\n\n    foreach_depth_first(to_update, function (instance, _attrs, was_new) {\n      if (was_new) instance.finalize();\n    });\n  }\n\n  static _event_for_attribute_change(changed_obj, key, new_value, doc, value_refs) {\n    const changed_model = doc.get_model_by_id(changed_obj.id); // XXX!\n\n    if (!changed_model.attribute_is_serializable(key)) return null;else {\n      const event = {\n        kind: \"ModelChanged\",\n        model: {\n          id: changed_obj.id\n        },\n        attr: key,\n        new: new_value\n      };\n\n      HasProps._json_record_references(doc, new_value, value_refs, true); // true = recurse\n\n\n      return event;\n    }\n  }\n\n  static _events_to_sync_objects(from_obj, to_obj, to_doc, value_refs) {\n    const from_keys = Object.keys(from_obj.attributes); //XXX!\n\n    const to_keys = Object.keys(to_obj.attributes); //XXX!\n\n    const removed = difference(from_keys, to_keys);\n    const added = difference(to_keys, from_keys);\n    const shared = intersection(from_keys, to_keys);\n    const events = [];\n\n    for (const key of removed) {\n      // we don't really have a \"remove\" event - not sure this ever\n      // happens even. One way this could happen is if the server\n      // does include_defaults=True and we do\n      // include_defaults=false ... in that case it'd be best to\n      // just ignore this probably. Warn about it, could mean\n      // there's a bug if we don't have a key that the server sent.\n      logger.warn(`Server sent key ${key} but we don't seem to have it in our JSON`);\n    }\n\n    for (const key of added) {\n      const new_value = to_obj.attributes[key]; // XXX!\n\n      events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n    }\n\n    for (const key of shared) {\n      const old_value = from_obj.attributes[key]; // XXX!\n\n      const new_value = to_obj.attributes[key]; // XXX!\n\n      if (old_value == null && new_value == null) {} else if (old_value == null || new_value == null) {\n        events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n      } else {\n        if (!isEqual(old_value, new_value)) events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n      }\n    }\n\n    return events.filter(e => e != null);\n  } // we use this to detect changes during document deserialization\n  // (in model constructors and initializers)\n\n\n  static _compute_patch_since_json(from_json, to_doc) {\n    const to_json = to_doc.to_json(false); // include_defaults=false\n\n    function refs(json) {\n      const result = {};\n\n      for (const obj of json.roots.references) result[obj.id] = obj;\n\n      return result;\n    }\n\n    const from_references = refs(from_json);\n    const from_roots = {};\n    const from_root_ids = [];\n\n    for (const r of from_json.roots.root_ids) {\n      from_roots[r] = from_references[r];\n      from_root_ids.push(r);\n    }\n\n    const to_references = refs(to_json);\n    const to_roots = {};\n    const to_root_ids = [];\n\n    for (const r of to_json.roots.root_ids) {\n      to_roots[r] = to_references[r];\n      to_root_ids.push(r);\n    }\n\n    from_root_ids.sort();\n    to_root_ids.sort();\n\n    if (difference(from_root_ids, to_root_ids).length > 0 || difference(to_root_ids, from_root_ids).length > 0) {\n      // this would arise if someone does add_root/remove_root during\n      // document deserialization, hopefully they won't ever do so.\n      throw new Error(\"Not implemented: computing add/remove of document roots\");\n    }\n\n    const value_refs = {};\n    let events = [];\n\n    for (const id in to_doc._all_models) {\n      if (id in from_references) {\n        const update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);\n\n        events = events.concat(update_model_events);\n      }\n    }\n\n    return {\n      references: Document._references_json(values(value_refs), false),\n      events\n    };\n  }\n\n  to_json_string(include_defaults = true) {\n    return JSON.stringify(this.to_json(include_defaults));\n  }\n\n  to_json(include_defaults = true) {\n    const root_ids = this._roots.map(r => r.id);\n\n    const root_references = values(this._all_models);\n    return {\n      version: js_version,\n      title: this._title,\n      roots: {\n        root_ids,\n        references: Document._references_json(root_references, include_defaults)\n      }\n    };\n  }\n\n  static from_json_string(s) {\n    const json = JSON.parse(s);\n    return Document.from_json(json);\n  }\n\n  static from_json(json) {\n    logger.debug(\"Creating Document from JSON\");\n\n    function pyify(version) {\n      return version.replace(/-(dev|rc)\\./, \"$1\");\n    }\n\n    const py_version = json.version; // XXX!\n\n    const is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\n    const versions_string = `Library versions: JS (${js_version}) / Python (${py_version})`;\n\n    if (!is_dev && pyify(js_version) != py_version) {\n      logger.warn(\"JS/Python version mismatch\");\n      logger.warn(versions_string);\n    } else logger.debug(versions_string);\n\n    const roots_json = json.roots;\n    const root_ids = roots_json.root_ids;\n    const references_json = roots_json.references;\n\n    const references = Document._instantiate_references_json(references_json, {});\n\n    Document._initialize_references_json(references_json, {}, references);\n\n    const doc = new Document();\n\n    for (const r of root_ids) doc.add_root(references[r]); // XXX: HasProps\n\n\n    doc.set_title(json.title); // XXX!\n\n    return doc;\n  }\n\n  replace_with_json(json) {\n    const replacement = Document.from_json(json);\n    replacement.destructively_move(this);\n  }\n\n  create_json_patch_string(events) {\n    return JSON.stringify(this.create_json_patch(events));\n  }\n\n  create_json_patch(events) {\n    const references = {};\n    const json_events = [];\n\n    for (const event of events) {\n      if (event.document !== this) {\n        logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\n        throw new Error(\"Cannot create a patch using events from a different document\");\n      }\n\n      json_events.push(event.json(references));\n    }\n\n    return {\n      events: json_events,\n      references: Document._references_json(values(references))\n    };\n  }\n\n  apply_json_patch(patch, buffers = [], setter_id) {\n    const references_json = patch.references;\n    const events_json = patch.events;\n\n    const references = Document._instantiate_references_json(references_json, this._all_models); // The model being changed isn't always in references so add it in\n\n\n    for (const event_json of events_json) {\n      switch (event_json.kind) {\n        case \"RootAdded\":\n        case \"RootRemoved\":\n        case \"ModelChanged\":\n          {\n            const model_id = event_json.model.id;\n\n            if (model_id in this._all_models) {\n              references[model_id] = this._all_models[model_id];\n            } else {\n              if (!(model_id in references)) {\n                logger.warn(\"Got an event for unknown model \", event_json.model);\n                throw new Error(\"event model wasn't known\");\n              }\n            }\n\n            break;\n          }\n      }\n    } // split references into old and new so we know whether to initialize or update\n\n\n    const old_references = {};\n    const new_references = {};\n\n    for (const id in references) {\n      const value = references[id];\n      if (id in this._all_models) old_references[id] = value;else new_references[id] = value;\n    }\n\n    Document._initialize_references_json(references_json, old_references, new_references);\n\n    for (const event_json of events_json) {\n      switch (event_json.kind) {\n        case 'MessageSent':\n          {\n            const {\n              msg_type,\n              msg_data\n            } = event_json;\n            let data;\n\n            if (msg_data === undefined) {\n              if (buffers.length == 1) {\n                const [[, buffer]] = buffers;\n                data = buffer;\n              } else {\n                throw new Error(\"expected exactly one buffer\");\n              }\n            } else {\n              data = Document._resolve_refs(msg_data, old_references, new_references);\n            }\n\n            this._trigger_on_message(msg_type, data);\n\n            break;\n          }\n\n        case 'ModelChanged':\n          {\n            const patched_id = event_json.model.id;\n\n            if (!(patched_id in this._all_models)) {\n              throw new Error(`Cannot apply patch to ${patched_id} which is not in the document`);\n            }\n\n            const patched_obj = this._all_models[patched_id];\n            const attr = event_json.attr; // XXXX currently still need this first branch, some updates (initial?) go through here\n\n            if (attr === 'data' && patched_obj.type === 'ColumnDataSource') {\n              const [data, shapes] = decode_column_data(event_json.new, buffers);\n              patched_obj.setv({\n                _shapes: shapes,\n                data\n              }, {\n                setter_id\n              });\n            } else {\n              const value = Document._resolve_refs(event_json.new, old_references, new_references);\n\n              patched_obj.setv({\n                [attr]: value\n              }, {\n                setter_id\n              });\n            }\n\n            break;\n          }\n\n        case 'ColumnDataChanged':\n          {\n            const column_source_id = event_json.column_source.id;\n\n            if (!(column_source_id in this._all_models)) {\n              throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n            }\n\n            const column_source = this._all_models[column_source_id];\n            const [data, shapes] = decode_column_data(event_json.new, buffers);\n\n            if (event_json.cols != null) {\n              for (const k in column_source.data) {\n                if (!(k in data)) {\n                  data[k] = column_source.data[k];\n                }\n              }\n\n              for (const k in column_source._shapes) {\n                if (!(k in shapes)) {\n                  shapes[k] = column_source._shapes[k];\n                }\n              }\n            }\n\n            column_source.setv({\n              _shapes: shapes,\n              data\n            }, {\n              setter_id,\n              check_eq: false\n            });\n            break;\n          }\n\n        case 'ColumnsStreamed':\n          {\n            const column_source_id = event_json.column_source.id;\n\n            if (!(column_source_id in this._all_models)) {\n              throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n            }\n\n            const column_source = this._all_models[column_source_id];\n\n            if (!(column_source instanceof ColumnDataSource)) {\n              throw new Error(\"Cannot stream to non-ColumnDataSource\");\n            }\n\n            const data = event_json.data;\n            const rollover = event_json.rollover;\n            column_source.stream(data, rollover, setter_id);\n            break;\n          }\n\n        case 'ColumnsPatched':\n          {\n            const column_source_id = event_json.column_source.id;\n\n            if (!(column_source_id in this._all_models)) {\n              throw new Error(`Cannot patch ${column_source_id} which is not in the document`);\n            }\n\n            const column_source = this._all_models[column_source_id];\n\n            if (!(column_source instanceof ColumnDataSource)) {\n              throw new Error(\"Cannot patch non-ColumnDataSource\");\n            }\n\n            const patches = event_json.patches;\n            column_source.patch(patches, setter_id);\n            break;\n          }\n\n        case 'RootAdded':\n          {\n            const root_id = event_json.model.id;\n            const root_obj = references[root_id];\n            this.add_root(root_obj, setter_id); // XXX: HasProps\n\n            break;\n          }\n\n        case 'RootRemoved':\n          {\n            const root_id = event_json.model.id;\n            const root_obj = references[root_id];\n            this.remove_root(root_obj, setter_id); // XXX: HasProps\n\n            break;\n          }\n\n        case 'TitleChanged':\n          {\n            this.set_title(event_json.title, setter_id);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\n      }\n    }\n  }\n\n}\nDocument.__name__ = \"Document\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/document/document.js"],"names":["Models","version","js_version","logger","LODStart","LODEnd","HasProps","Signal0","is_ref","decode_column_data","MultiDict","Set","OurSet","difference","intersection","copy","includes","values","isEqual","isArray","isPlainObject","LayoutDOM","ColumnDataSource","Model","ModelChangedEvent","RootAddedEvent","RootRemovedEvent","TitleChangedEvent","MessageSentEvent","EventManager","constructor","document","session","subscribed_models","send_event","bokeh_event","event","to_json","_trigger_on_change","trigger","id","origin","model","_all_models","_process_event","__name__","documents","DEFAULT_TITLE","Document","push","_init_timestamp","Date","now","_title","_roots","_all_models_by_name","_all_models_freeze_count","_callbacks","_message_callbacks","Map","event_manager","idle","_idle_roots","WeakMap","_interactive_timestamp","_interactive_plot","layoutables","filter","root","is_idle","has","notify_idle","set","info","emit","clear","_push_all_models_freeze","length","remove_root","_pop_all_models_freeze","interactive_start","plot","trigger_event","interactive_stop","interactive_duration","destructively_move","dest_doc","Error","roots","Object","keys","add_root","set_title","_recompute_all_models","_invalidate_all_models","debug","new_all_models_set","r","union","references","old_all_models_set","to_detach","diff","to_attach","recomputed","m","d","detach_document","name","remove_value","a","attach_document","add_value","setter_id","i","indexOf","splice","title","get_model_by_id","model_id","get_model_by_name","get_one","on_message","msg_type","callback","message_callbacks","get","add","remove_on_message","_a","delete","_trigger_on_message","msg_data","cb","on_change","remove_on_change","_notify_change","attr","old","new_","options","hint","_references_json","include_defaults","references_json","struct","attributes","attributes_as_json","_instantiate_object","obj_id","obj_type","obj_attrs","full_attrs","assign","__deferred__","_instantiate_references_json","existing_models","obj","type","instance","subtype","set_subtype","_resolve_refs","value","old_references","new_references","resolve_ref","v","JSON","stringify","resolve_array","resolve_dict","array","results","dict","resolved","k","_initialize_references_json","to_update","was_new","resolved_attrs","foreach_depth_first","items","f","already_started","foreach_value","attrs","e","setv","silent","_attrs","finalize","_event_for_attribute_change","changed_obj","key","new_value","doc","value_refs","changed_model","attribute_is_serializable","kind","new","_json_record_references","_events_to_sync_objects","from_obj","to_obj","to_doc","from_keys","to_keys","removed","added","shared","events","warn","old_value","_compute_patch_since_json","from_json","refs","json","result","from_references","from_roots","from_root_ids","root_ids","to_references","to_roots","to_root_ids","sort","update_model_events","concat","to_json_string","map","root_references","from_json_string","s","parse","pyify","replace","py_version","is_dev","versions_string","roots_json","replace_with_json","replacement","create_json_patch_string","create_json_patch","json_events","apply_json_patch","patch","buffers","events_json","event_json","data","undefined","buffer","patched_id","patched_obj","shapes","_shapes","column_source_id","column_source","cols","check_eq","rollover","stream","patches","root_id","root_obj"],"mappings":"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","sourcesContent":["import { Models } from \"../base\";\nimport { version as js_version } from \"../version\";\nimport { logger } from \"../core/logging\";\nimport { LODStart, LODEnd } from \"../core/bokeh_events\";\nimport { HasProps } from \"../core/has_props\";\nimport { Signal0 } from \"../core/signaling\";\nimport { is_ref } from \"../core/util/refs\";\nimport { decode_column_data } from \"../core/util/serialization\";\nimport { MultiDict, Set as OurSet } from \"../core/util/data_structures\";\nimport { difference, intersection, copy, includes } from \"../core/util/array\";\nimport { values } from \"../core/util/object\";\nimport { isEqual } from \"../core/util/eq\";\nimport { isArray, isPlainObject } from \"../core/util/types\";\nimport { LayoutDOM } from \"../models/layouts/layout_dom\";\nimport { ColumnDataSource } from \"../models/sources/column_data_source\";\nimport { Model } from \"../model\";\nimport { ModelChangedEvent, RootAddedEvent, RootRemovedEvent, TitleChangedEvent, MessageSentEvent, } from \"./events\";\nexport class EventManager {\n    constructor(document) {\n        this.document = document;\n        // Dispatches events to the subscribed models\n        this.session = null;\n        this.subscribed_models = new Set();\n    }\n    send_event(bokeh_event) {\n        const event = new MessageSentEvent(this.document, \"bokeh_event\", bokeh_event.to_json());\n        this.document._trigger_on_change(event);\n    }\n    trigger(event) {\n        for (const id of this.subscribed_models) {\n            if (event.origin != null && event.origin.id !== id)\n                continue;\n            const model = this.document._all_models[id];\n            if (model != null && model instanceof Model)\n                model._process_event(event);\n        }\n    }\n}\nEventManager.__name__ = \"EventManager\";\nexport const documents = [];\nexport const DEFAULT_TITLE = \"Bokeh Application\";\n// This class should match the API of the Python Document class\n// as much as possible.\nexport class Document {\n    constructor() {\n        documents.push(this);\n        this._init_timestamp = Date.now();\n        this._title = DEFAULT_TITLE;\n        this._roots = [];\n        this._all_models = {};\n        this._all_models_by_name = new MultiDict();\n        this._all_models_freeze_count = 0;\n        this._callbacks = [];\n        this._message_callbacks = new Map();\n        this.event_manager = new EventManager(this);\n        this.idle = new Signal0(this, \"idle\");\n        this._idle_roots = new WeakMap(); // TODO: WeakSet would be better\n        this._interactive_timestamp = null;\n        this._interactive_plot = null;\n    }\n    get layoutables() {\n        return this._roots.filter((root) => root instanceof LayoutDOM);\n    }\n    get is_idle() {\n        for (const root of this.layoutables) {\n            if (!this._idle_roots.has(root))\n                return false;\n        }\n        return true;\n    }\n    notify_idle(model) {\n        this._idle_roots.set(model, true);\n        if (this.is_idle) {\n            logger.info(`document idle at ${Date.now() - this._init_timestamp} ms`);\n            this.idle.emit();\n        }\n    }\n    clear() {\n        this._push_all_models_freeze();\n        try {\n            while (this._roots.length > 0) {\n                this.remove_root(this._roots[0]);\n            }\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n    }\n    interactive_start(plot) {\n        if (this._interactive_plot == null) {\n            this._interactive_plot = plot;\n            this._interactive_plot.trigger_event(new LODStart());\n        }\n        this._interactive_timestamp = Date.now();\n    }\n    interactive_stop(plot) {\n        if (this._interactive_plot != null && this._interactive_plot.id === plot.id) {\n            this._interactive_plot.trigger_event(new LODEnd());\n        }\n        this._interactive_plot = null;\n        this._interactive_timestamp = null;\n    }\n    interactive_duration() {\n        if (this._interactive_timestamp == null)\n            return -1;\n        else\n            return Date.now() - this._interactive_timestamp;\n    }\n    destructively_move(dest_doc) {\n        if (dest_doc === this) {\n            throw new Error(\"Attempted to overwrite a document with itself\");\n        }\n        dest_doc.clear();\n        // we have to remove ALL roots before adding any\n        // to the new doc or else models referenced from multiple\n        // roots could be in both docs at once, which isn't allowed.\n        const roots = copy(this._roots);\n        this.clear();\n        for (const root of roots) {\n            if (root.document != null)\n                throw new Error(`Somehow we didn't detach ${root}`);\n        }\n        if (Object.keys(this._all_models).length !== 0) {\n            throw new Error(`this._all_models still had stuff in it: ${this._all_models}`);\n        }\n        for (const root of roots) {\n            dest_doc.add_root(root);\n        }\n        dest_doc.set_title(this._title);\n    }\n    // TODO other fields of doc\n    _push_all_models_freeze() {\n        this._all_models_freeze_count += 1;\n    }\n    _pop_all_models_freeze() {\n        this._all_models_freeze_count -= 1;\n        if (this._all_models_freeze_count === 0) {\n            this._recompute_all_models();\n        }\n    }\n    /*protected*/ _invalidate_all_models() {\n        logger.debug(\"invalidating document models\");\n        // if freeze count is > 0, we'll recompute on unfreeze\n        if (this._all_models_freeze_count === 0) {\n            this._recompute_all_models();\n        }\n    }\n    _recompute_all_models() {\n        let new_all_models_set = new OurSet();\n        for (const r of this._roots) {\n            new_all_models_set = new_all_models_set.union(r.references());\n        }\n        const old_all_models_set = new OurSet(values(this._all_models));\n        const to_detach = old_all_models_set.diff(new_all_models_set);\n        const to_attach = new_all_models_set.diff(old_all_models_set);\n        const recomputed = {};\n        for (const m of new_all_models_set.values) {\n            recomputed[m.id] = m;\n        }\n        for (const d of to_detach.values) {\n            d.detach_document();\n            if (d instanceof Model && d.name != null)\n                this._all_models_by_name.remove_value(d.name, d);\n        }\n        for (const a of to_attach.values) {\n            a.attach_document(this);\n            if (a instanceof Model && a.name != null)\n                this._all_models_by_name.add_value(a.name, a);\n        }\n        this._all_models = recomputed;\n    }\n    roots() {\n        return this._roots;\n    }\n    add_root(model, setter_id) {\n        logger.debug(`Adding root: ${model}`);\n        if (includes(this._roots, model))\n            return;\n        this._push_all_models_freeze();\n        try {\n            this._roots.push(model);\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        this._trigger_on_change(new RootAddedEvent(this, model, setter_id));\n    }\n    remove_root(model, setter_id) {\n        const i = this._roots.indexOf(model);\n        if (i < 0)\n            return;\n        this._push_all_models_freeze();\n        try {\n            this._roots.splice(i, 1);\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        this._trigger_on_change(new RootRemovedEvent(this, model, setter_id));\n    }\n    title() {\n        return this._title;\n    }\n    set_title(title, setter_id) {\n        if (title !== this._title) {\n            this._title = title;\n            this._trigger_on_change(new TitleChangedEvent(this, title, setter_id));\n        }\n    }\n    get_model_by_id(model_id) {\n        if (model_id in this._all_models) {\n            return this._all_models[model_id];\n        }\n        else {\n            return null;\n        }\n    }\n    get_model_by_name(name) {\n        return this._all_models_by_name.get_one(name, `Multiple models are named '${name}'`);\n    }\n    on_message(msg_type, callback) {\n        const message_callbacks = this._message_callbacks.get(msg_type);\n        if (message_callbacks == null)\n            this._message_callbacks.set(msg_type, new Set([callback]));\n        else\n            message_callbacks.add(callback);\n    }\n    remove_on_message(msg_type, callback) {\n        var _a;\n        (_a = this._message_callbacks.get(msg_type)) === null || _a === void 0 ? void 0 : _a.delete(callback);\n    }\n    _trigger_on_message(msg_type, msg_data) {\n        const message_callbacks = this._message_callbacks.get(msg_type);\n        if (message_callbacks != null) {\n            for (const cb of message_callbacks) {\n                cb(msg_data);\n            }\n        }\n    }\n    on_change(callback) {\n        if (!includes(this._callbacks, callback))\n            this._callbacks.push(callback);\n    }\n    remove_on_change(callback) {\n        const i = this._callbacks.indexOf(callback);\n        if (i >= 0)\n            this._callbacks.splice(i, 1);\n    }\n    _trigger_on_change(event) {\n        for (const cb of this._callbacks) {\n            cb(event);\n        }\n    }\n    // called by the model\n    _notify_change(model, attr, old, new_, options) {\n        if (attr === 'name') {\n            this._all_models_by_name.remove_value(old, model);\n            if (new_ != null)\n                this._all_models_by_name.add_value(new_, model);\n        }\n        const setter_id = options != null ? options.setter_id : void 0;\n        const hint = options != null ? options.hint : void 0;\n        this._trigger_on_change(new ModelChangedEvent(this, model, attr, old, new_, setter_id, hint));\n    }\n    static _references_json(references, include_defaults = true) {\n        const references_json = [];\n        for (const r of references) {\n            const struct = r.struct();\n            struct.attributes = r.attributes_as_json(include_defaults);\n            // server doesn't want id in here since it's already in ref above\n            delete struct.attributes.id;\n            references_json.push(struct);\n        }\n        return references_json;\n    }\n    static _instantiate_object(obj_id, obj_type, obj_attrs) {\n        const full_attrs = Object.assign(Object.assign({}, obj_attrs), { id: obj_id, __deferred__: true });\n        const model = Models(obj_type);\n        return new model(full_attrs);\n    }\n    // given a JSON representation of all models in a graph, return a\n    // dict of new model objects\n    static _instantiate_references_json(references_json, existing_models) {\n        // Create all instances, but without setting their props\n        const references = {};\n        for (const obj of references_json) {\n            const obj_id = obj.id;\n            const obj_type = obj.type;\n            const obj_attrs = obj.attributes || {};\n            let instance;\n            if (obj_id in existing_models)\n                instance = existing_models[obj_id];\n            else {\n                instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\n                if (obj.subtype != null)\n                    instance.set_subtype(obj.subtype);\n            }\n            references[instance.id] = instance;\n        }\n        return references;\n    }\n    // if v looks like a ref, or a collection, resolve it, otherwise return it unchanged\n    // recurse into collections but not into HasProps\n    static _resolve_refs(value, old_references, new_references) {\n        function resolve_ref(v) {\n            if (is_ref(v)) {\n                if (v.id in old_references)\n                    return old_references[v.id];\n                else if (v.id in new_references)\n                    return new_references[v.id];\n                else\n                    throw new Error(`reference ${JSON.stringify(v)} isn't known (not in Document?)`);\n            }\n            else if (isArray(v))\n                return resolve_array(v);\n            else if (isPlainObject(v))\n                return resolve_dict(v);\n            else\n                return v;\n        }\n        function resolve_array(array) {\n            const results = [];\n            for (const v of array) {\n                results.push(resolve_ref(v));\n            }\n            return results;\n        }\n        function resolve_dict(dict) {\n            const resolved = {};\n            for (const k in dict) {\n                const v = dict[k];\n                resolved[k] = resolve_ref(v);\n            }\n            return resolved;\n        }\n        return resolve_ref(value);\n    }\n    // given a JSON representation of all models in a graph and new\n    // model instances, set the properties on the models from the\n    // JSON\n    static _initialize_references_json(references_json, old_references, new_references) {\n        const to_update = {};\n        for (const obj of references_json) {\n            const obj_id = obj.id;\n            const obj_attrs = obj.attributes;\n            const was_new = !(obj_id in old_references);\n            const instance = !was_new ? old_references[obj_id] : new_references[obj_id];\n            // replace references with actual instances in obj_attrs\n            const resolved_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);\n            to_update[instance.id] = [instance, resolved_attrs, was_new];\n        }\n        function foreach_depth_first(items, f) {\n            const already_started = {};\n            function foreach_value(v) {\n                if (v instanceof HasProps) {\n                    // note that we ignore instances that aren't updated (not in to_update)\n                    if (!(v.id in already_started) && v.id in items) {\n                        already_started[v.id] = true;\n                        const [, attrs, was_new] = items[v.id];\n                        for (const a in attrs) {\n                            const e = attrs[a];\n                            foreach_value(e);\n                        }\n                        f(v, attrs, was_new);\n                    }\n                }\n                else if (isArray(v)) {\n                    for (const e of v)\n                        foreach_value(e);\n                }\n                else if (isPlainObject(v)) {\n                    for (const k in v) {\n                        const e = v[k];\n                        foreach_value(e);\n                    }\n                }\n            }\n            for (const k in items) {\n                const [instance, ,] = items[k];\n                foreach_value(instance);\n            }\n        }\n        // this first pass removes all 'refs' replacing them with real instances\n        foreach_depth_first(to_update, function (instance, attrs, was_new) {\n            if (was_new)\n                instance.setv(attrs, { silent: true });\n        });\n        // after removing all the refs, we can run the initialize code safely\n        foreach_depth_first(to_update, function (instance, _attrs, was_new) {\n            if (was_new)\n                instance.finalize();\n        });\n    }\n    static _event_for_attribute_change(changed_obj, key, new_value, doc, value_refs) {\n        const changed_model = doc.get_model_by_id(changed_obj.id); // XXX!\n        if (!changed_model.attribute_is_serializable(key))\n            return null;\n        else {\n            const event = {\n                kind: \"ModelChanged\",\n                model: { id: changed_obj.id },\n                attr: key,\n                new: new_value,\n            };\n            HasProps._json_record_references(doc, new_value, value_refs, true); // true = recurse\n            return event;\n        }\n    }\n    static _events_to_sync_objects(from_obj, to_obj, to_doc, value_refs) {\n        const from_keys = Object.keys(from_obj.attributes); //XXX!\n        const to_keys = Object.keys(to_obj.attributes); //XXX!\n        const removed = difference(from_keys, to_keys);\n        const added = difference(to_keys, from_keys);\n        const shared = intersection(from_keys, to_keys);\n        const events = [];\n        for (const key of removed) {\n            // we don't really have a \"remove\" event - not sure this ever\n            // happens even. One way this could happen is if the server\n            // does include_defaults=True and we do\n            // include_defaults=false ... in that case it'd be best to\n            // just ignore this probably. Warn about it, could mean\n            // there's a bug if we don't have a key that the server sent.\n            logger.warn(`Server sent key ${key} but we don't seem to have it in our JSON`);\n        }\n        for (const key of added) {\n            const new_value = to_obj.attributes[key]; // XXX!\n            events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n        }\n        for (const key of shared) {\n            const old_value = from_obj.attributes[key]; // XXX!\n            const new_value = to_obj.attributes[key]; // XXX!\n            if (old_value == null && new_value == null) {\n            }\n            else if (old_value == null || new_value == null) {\n                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n            }\n            else {\n                if (!isEqual(old_value, new_value))\n                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n            }\n        }\n        return events.filter((e) => e != null);\n    }\n    // we use this to detect changes during document deserialization\n    // (in model constructors and initializers)\n    static _compute_patch_since_json(from_json, to_doc) {\n        const to_json = to_doc.to_json(false); // include_defaults=false\n        function refs(json) {\n            const result = {};\n            for (const obj of json.roots.references)\n                result[obj.id] = obj;\n            return result;\n        }\n        const from_references = refs(from_json);\n        const from_roots = {};\n        const from_root_ids = [];\n        for (const r of from_json.roots.root_ids) {\n            from_roots[r] = from_references[r];\n            from_root_ids.push(r);\n        }\n        const to_references = refs(to_json);\n        const to_roots = {};\n        const to_root_ids = [];\n        for (const r of to_json.roots.root_ids) {\n            to_roots[r] = to_references[r];\n            to_root_ids.push(r);\n        }\n        from_root_ids.sort();\n        to_root_ids.sort();\n        if (difference(from_root_ids, to_root_ids).length > 0 ||\n            difference(to_root_ids, from_root_ids).length > 0) {\n            // this would arise if someone does add_root/remove_root during\n            // document deserialization, hopefully they won't ever do so.\n            throw new Error(\"Not implemented: computing add/remove of document roots\");\n        }\n        const value_refs = {};\n        let events = [];\n        for (const id in to_doc._all_models) {\n            if (id in from_references) {\n                const update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);\n                events = events.concat(update_model_events);\n            }\n        }\n        return {\n            references: Document._references_json(values(value_refs), false),\n            events,\n        };\n    }\n    to_json_string(include_defaults = true) {\n        return JSON.stringify(this.to_json(include_defaults));\n    }\n    to_json(include_defaults = true) {\n        const root_ids = this._roots.map((r) => r.id);\n        const root_references = values(this._all_models);\n        return {\n            version: js_version,\n            title: this._title,\n            roots: {\n                root_ids,\n                references: Document._references_json(root_references, include_defaults),\n            },\n        };\n    }\n    static from_json_string(s) {\n        const json = JSON.parse(s);\n        return Document.from_json(json);\n    }\n    static from_json(json) {\n        logger.debug(\"Creating Document from JSON\");\n        function pyify(version) {\n            return version.replace(/-(dev|rc)\\./, \"$1\");\n        }\n        const py_version = json.version; // XXX!\n        const is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\n        const versions_string = `Library versions: JS (${js_version}) / Python (${py_version})`;\n        if (!is_dev && pyify(js_version) != py_version) {\n            logger.warn(\"JS/Python version mismatch\");\n            logger.warn(versions_string);\n        }\n        else\n            logger.debug(versions_string);\n        const roots_json = json.roots;\n        const root_ids = roots_json.root_ids;\n        const references_json = roots_json.references;\n        const references = Document._instantiate_references_json(references_json, {});\n        Document._initialize_references_json(references_json, {}, references);\n        const doc = new Document();\n        for (const r of root_ids)\n            doc.add_root(references[r]); // XXX: HasProps\n        doc.set_title(json.title); // XXX!\n        return doc;\n    }\n    replace_with_json(json) {\n        const replacement = Document.from_json(json);\n        replacement.destructively_move(this);\n    }\n    create_json_patch_string(events) {\n        return JSON.stringify(this.create_json_patch(events));\n    }\n    create_json_patch(events) {\n        const references = {};\n        const json_events = [];\n        for (const event of events) {\n            if (event.document !== this) {\n                logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\n                throw new Error(\"Cannot create a patch using events from a different document\");\n            }\n            json_events.push(event.json(references));\n        }\n        return {\n            events: json_events,\n            references: Document._references_json(values(references)),\n        };\n    }\n    apply_json_patch(patch, buffers = [], setter_id) {\n        const references_json = patch.references;\n        const events_json = patch.events;\n        const references = Document._instantiate_references_json(references_json, this._all_models);\n        // The model being changed isn't always in references so add it in\n        for (const event_json of events_json) {\n            switch (event_json.kind) {\n                case \"RootAdded\":\n                case \"RootRemoved\":\n                case \"ModelChanged\": {\n                    const model_id = event_json.model.id;\n                    if (model_id in this._all_models) {\n                        references[model_id] = this._all_models[model_id];\n                    }\n                    else {\n                        if (!(model_id in references)) {\n                            logger.warn(\"Got an event for unknown model \", event_json.model);\n                            throw new Error(\"event model wasn't known\");\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        // split references into old and new so we know whether to initialize or update\n        const old_references = {};\n        const new_references = {};\n        for (const id in references) {\n            const value = references[id];\n            if (id in this._all_models)\n                old_references[id] = value;\n            else\n                new_references[id] = value;\n        }\n        Document._initialize_references_json(references_json, old_references, new_references);\n        for (const event_json of events_json) {\n            switch (event_json.kind) {\n                case 'MessageSent': {\n                    const { msg_type, msg_data } = event_json;\n                    let data;\n                    if (msg_data === undefined) {\n                        if (buffers.length == 1) {\n                            const [[, buffer]] = buffers;\n                            data = buffer;\n                        }\n                        else {\n                            throw new Error(\"expected exactly one buffer\");\n                        }\n                    }\n                    else {\n                        data = Document._resolve_refs(msg_data, old_references, new_references);\n                    }\n                    this._trigger_on_message(msg_type, data);\n                    break;\n                }\n                case 'ModelChanged': {\n                    const patched_id = event_json.model.id;\n                    if (!(patched_id in this._all_models)) {\n                        throw new Error(`Cannot apply patch to ${patched_id} which is not in the document`);\n                    }\n                    const patched_obj = this._all_models[patched_id];\n                    const attr = event_json.attr;\n                    // XXXX currently still need this first branch, some updates (initial?) go through here\n                    if (attr === 'data' && patched_obj.type === 'ColumnDataSource') {\n                        const [data, shapes] = decode_column_data(event_json.new, buffers);\n                        patched_obj.setv({ _shapes: shapes, data }, { setter_id });\n                    }\n                    else {\n                        const value = Document._resolve_refs(event_json.new, old_references, new_references);\n                        patched_obj.setv({ [attr]: value }, { setter_id });\n                    }\n                    break;\n                }\n                case 'ColumnDataChanged': {\n                    const column_source_id = event_json.column_source.id;\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n                    }\n                    const column_source = this._all_models[column_source_id];\n                    const [data, shapes] = decode_column_data(event_json.new, buffers);\n                    if (event_json.cols != null) {\n                        for (const k in column_source.data) {\n                            if (!(k in data)) {\n                                data[k] = column_source.data[k];\n                            }\n                        }\n                        for (const k in column_source._shapes) {\n                            if (!(k in shapes)) {\n                                shapes[k] = column_source._shapes[k];\n                            }\n                        }\n                    }\n                    column_source.setv({\n                        _shapes: shapes,\n                        data,\n                    }, {\n                        setter_id,\n                        check_eq: false,\n                    });\n                    break;\n                }\n                case 'ColumnsStreamed': {\n                    const column_source_id = event_json.column_source.id;\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n                    }\n                    const column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof ColumnDataSource)) {\n                        throw new Error(\"Cannot stream to non-ColumnDataSource\");\n                    }\n                    const data = event_json.data;\n                    const rollover = event_json.rollover;\n                    column_source.stream(data, rollover, setter_id);\n                    break;\n                }\n                case 'ColumnsPatched': {\n                    const column_source_id = event_json.column_source.id;\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(`Cannot patch ${column_source_id} which is not in the document`);\n                    }\n                    const column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof ColumnDataSource)) {\n                        throw new Error(\"Cannot patch non-ColumnDataSource\");\n                    }\n                    const patches = event_json.patches;\n                    column_source.patch(patches, setter_id);\n                    break;\n                }\n                case 'RootAdded': {\n                    const root_id = event_json.model.id;\n                    const root_obj = references[root_id];\n                    this.add_root(root_obj, setter_id); // XXX: HasProps\n                    break;\n                }\n                case 'RootRemoved': {\n                    const root_id = event_json.model.id;\n                    const root_obj = references[root_id];\n                    this.remove_root(root_obj, setter_id); // XXX: HasProps\n                    break;\n                }\n                case 'TitleChanged': {\n                    this.set_title(event_json.title, setter_id);\n                    break;\n                }\n                default:\n                    throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\n            }\n        }\n    }\n}\nDocument.__name__ = \"Document\";\n//# sourceMappingURL=document.js.map"]},"metadata":{},"sourceType":"module"}