{"ast":null,"code":"import { ContinuousTicker } from \"./continuous_ticker\";\nimport { argmin, nth } from \"../../core/util/array\";\nimport * as p from \"../../core/properties\"; // Forces a number x into a specified range [min_val, max_val].\n\nfunction clamp(x, min_val, max_val) {\n  return Math.max(min_val, Math.min(max_val, x));\n} // A log function with an optional base.\n\n\nfunction log(x, base = Math.E) {\n  return Math.log(x) / Math.log(base);\n}\n\nexport class AdaptiveTicker extends ContinuousTicker {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_AdaptiveTicker() {\n    this.define({\n      base: [p.Number, 10.0],\n      mantissas: [p.Array, [1, 2, 5]],\n      min_interval: [p.Number, 0.0],\n      max_interval: [p.Number]\n    });\n  } // These arguments control the range of possible intervals.  The interval I\n  // returned by get_interval() will be the one that most closely matches the\n  // desired number of ticks, subject to the following constraints:\n  // I = (M * B^N), where\n  // M is a member of mantissas,\n  // B is base,\n  // and N is an integer;\n  // and min_interval <= I <= max_interval.\n\n\n  initialize() {\n    super.initialize();\n    const prefix_mantissa = nth(this.mantissas, -1) / this.base;\n    const suffix_mantissa = nth(this.mantissas, 0) * this.base;\n    this.extended_mantissas = [prefix_mantissa, ...this.mantissas, suffix_mantissa];\n    this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\n  }\n\n  get_interval(data_low, data_high, desired_n_ticks) {\n    const data_range = data_high - data_low;\n    const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n    const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\n    const ideal_magnitude = this.base ** interval_exponent * this.base_factor; // An untested optimization.\n    //   const ideal_mantissa = ideal_interval / ideal_magnitude\n    //   index = sorted_index(this.extended_mantissas, ideal_mantissa)\n    //   candidate_mantissas = this.extended_mantissas[index..index + 1]\n\n    const candidate_mantissas = this.extended_mantissas;\n    const errors = candidate_mantissas.map(mantissa => {\n      return Math.abs(desired_n_ticks - data_range / (mantissa * ideal_magnitude));\n    });\n    const best_mantissa = candidate_mantissas[argmin(errors)];\n    const interval = best_mantissa * ideal_magnitude;\n    return clamp(interval, this.get_min_interval(), this.get_max_interval());\n  }\n\n}\nAdaptiveTicker.__name__ = \"AdaptiveTicker\";\nAdaptiveTicker.init_AdaptiveTicker();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/adaptive_ticker.js"],"names":["ContinuousTicker","argmin","nth","p","clamp","x","min_val","max_val","Math","max","min","log","base","E","AdaptiveTicker","constructor","attrs","init_AdaptiveTicker","define","Number","mantissas","Array","min_interval","max_interval","initialize","prefix_mantissa","suffix_mantissa","extended_mantissas","base_factor","get_min_interval","get_interval","data_low","data_high","desired_n_ticks","data_range","ideal_interval","get_ideal_interval","interval_exponent","floor","ideal_magnitude","candidate_mantissas","errors","map","mantissa","abs","best_mantissa","interval","get_max_interval","__name__"],"mappings":"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","sourcesContent":["import { ContinuousTicker } from \"./continuous_ticker\";\nimport { argmin, nth } from \"../../core/util/array\";\nimport * as p from \"../../core/properties\";\n// Forces a number x into a specified range [min_val, max_val].\nfunction clamp(x, min_val, max_val) {\n    return Math.max(min_val, Math.min(max_val, x));\n}\n// A log function with an optional base.\nfunction log(x, base = Math.E) {\n    return Math.log(x) / Math.log(base);\n}\nexport class AdaptiveTicker extends ContinuousTicker {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_AdaptiveTicker() {\n        this.define({\n            base: [p.Number, 10.0],\n            mantissas: [p.Array, [1, 2, 5]],\n            min_interval: [p.Number, 0.0],\n            max_interval: [p.Number],\n        });\n    }\n    // These arguments control the range of possible intervals.  The interval I\n    // returned by get_interval() will be the one that most closely matches the\n    // desired number of ticks, subject to the following constraints:\n    // I = (M * B^N), where\n    // M is a member of mantissas,\n    // B is base,\n    // and N is an integer;\n    // and min_interval <= I <= max_interval.\n    initialize() {\n        super.initialize();\n        const prefix_mantissa = nth(this.mantissas, -1) / this.base;\n        const suffix_mantissa = nth(this.mantissas, 0) * this.base;\n        this.extended_mantissas = [prefix_mantissa, ...this.mantissas, suffix_mantissa];\n        this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\n    }\n    get_interval(data_low, data_high, desired_n_ticks) {\n        const data_range = data_high - data_low;\n        const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n        const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\n        const ideal_magnitude = this.base ** interval_exponent * this.base_factor;\n        // An untested optimization.\n        //   const ideal_mantissa = ideal_interval / ideal_magnitude\n        //   index = sorted_index(this.extended_mantissas, ideal_mantissa)\n        //   candidate_mantissas = this.extended_mantissas[index..index + 1]\n        const candidate_mantissas = this.extended_mantissas;\n        const errors = candidate_mantissas.map((mantissa) => {\n            return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));\n        });\n        const best_mantissa = candidate_mantissas[argmin(errors)];\n        const interval = best_mantissa * ideal_magnitude;\n        return clamp(interval, this.get_min_interval(), this.get_max_interval());\n    }\n}\nAdaptiveTicker.__name__ = \"AdaptiveTicker\";\nAdaptiveTicker.init_AdaptiveTicker();\n//# sourceMappingURL=adaptive_ticker.js.map"]},"metadata":{},"sourceType":"module"}