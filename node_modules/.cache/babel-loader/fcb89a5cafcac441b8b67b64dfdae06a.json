{"ast":null,"code":"import { TickFormatter } from \"./tick_formatter\";\nimport * as p from \"../../core/properties\";\nexport class BasicTickFormatter extends TickFormatter {\n  constructor(attrs) {\n    super(attrs);\n    this.last_precision = 3;\n  }\n\n  static init_BasicTickFormatter() {\n    this.define({\n      precision: [p.Any, 'auto'],\n      use_scientific: [p.Boolean, true],\n      power_limit_high: [p.Number, 5],\n      power_limit_low: [p.Number, -3]\n    });\n  }\n\n  get scientific_limit_low() {\n    return 10.0 ** this.power_limit_low;\n  }\n\n  get scientific_limit_high() {\n    return 10.0 ** this.power_limit_high;\n  }\n\n  _need_sci(ticks) {\n    if (!this.use_scientific) return false;\n    const {\n      scientific_limit_high\n    } = this;\n    const {\n      scientific_limit_low\n    } = this;\n    const zeroish = ticks.length < 2 ? 0 : Math.abs(ticks[1] - ticks[0]) / 10000;\n\n    for (const tick of ticks) {\n      const tick_abs = Math.abs(tick);\n      if (tick_abs <= zeroish) continue;\n\n      if (tick_abs >= scientific_limit_high || tick_abs <= scientific_limit_low) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _format_with_precision(ticks, need_sci, precision) {\n    const labels = new Array(ticks.length);\n\n    if (need_sci) {\n      for (let i = 0, end = ticks.length; i < end; i++) {\n        labels[i] = ticks[i].toExponential(precision);\n      }\n    } else {\n      for (let i = 0, end = ticks.length; i < end; i++) {\n        // strip trailing zeros\n        labels[i] = ticks[i].toFixed(precision).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n      }\n    }\n\n    return labels;\n  }\n\n  _auto_precision(ticks, need_sci) {\n    const labels = new Array(ticks.length);\n    const asc = this.last_precision <= 15;\n\n    outer: for (let x = this.last_precision; asc ? x <= 15 : x >= 1; asc ? x++ : x--) {\n      if (need_sci) {\n        labels[0] = ticks[0].toExponential(x);\n\n        for (let i = 1; i < ticks.length; i++) {\n          if (labels[i] == labels[i - 1]) {\n            continue outer;\n          }\n        }\n\n        this.last_precision = x;\n        break;\n      } else {\n        labels[0] = ticks[0].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n\n        for (let i = 1; i < ticks.length; i++) {\n          labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n\n          if (labels[i] == labels[i - 1]) {\n            continue outer;\n          }\n        }\n\n        this.last_precision = x;\n        break;\n      }\n    }\n\n    return this.last_precision;\n  }\n\n  doFormat(ticks, _opts) {\n    if (ticks.length == 0) return [];\n\n    const need_sci = this._need_sci(ticks);\n\n    const precision = this.precision == \"auto\" ? this._auto_precision(ticks, need_sci) : this.precision;\n    return this._format_with_precision(ticks, need_sci, precision);\n  }\n\n}\nBasicTickFormatter.__name__ = \"BasicTickFormatter\";\nBasicTickFormatter.init_BasicTickFormatter();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/basic_tick_formatter.js"],"names":["TickFormatter","p","BasicTickFormatter","constructor","attrs","last_precision","init_BasicTickFormatter","define","precision","Any","use_scientific","Boolean","power_limit_high","Number","power_limit_low","scientific_limit_low","scientific_limit_high","_need_sci","ticks","zeroish","length","Math","abs","tick","tick_abs","_format_with_precision","need_sci","labels","Array","i","end","toExponential","toFixed","replace","_auto_precision","asc","outer","x","doFormat","_opts","__name__"],"mappings":"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","sourcesContent":["import { TickFormatter } from \"./tick_formatter\";\nimport * as p from \"../../core/properties\";\nexport class BasicTickFormatter extends TickFormatter {\n    constructor(attrs) {\n        super(attrs);\n        this.last_precision = 3;\n    }\n    static init_BasicTickFormatter() {\n        this.define({\n            precision: [p.Any, 'auto'],\n            use_scientific: [p.Boolean, true],\n            power_limit_high: [p.Number, 5],\n            power_limit_low: [p.Number, -3],\n        });\n    }\n    get scientific_limit_low() {\n        return 10.0 ** this.power_limit_low;\n    }\n    get scientific_limit_high() {\n        return 10.0 ** this.power_limit_high;\n    }\n    _need_sci(ticks) {\n        if (!this.use_scientific)\n            return false;\n        const { scientific_limit_high } = this;\n        const { scientific_limit_low } = this;\n        const zeroish = ticks.length < 2 ? 0 : Math.abs(ticks[1] - ticks[0]) / 10000;\n        for (const tick of ticks) {\n            const tick_abs = Math.abs(tick);\n            if (tick_abs <= zeroish)\n                continue;\n            if (tick_abs >= scientific_limit_high || tick_abs <= scientific_limit_low) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _format_with_precision(ticks, need_sci, precision) {\n        const labels = new Array(ticks.length);\n        if (need_sci) {\n            for (let i = 0, end = ticks.length; i < end; i++) {\n                labels[i] = ticks[i].toExponential(precision);\n            }\n        }\n        else {\n            for (let i = 0, end = ticks.length; i < end; i++) {\n                // strip trailing zeros\n                labels[i] = ticks[i].toFixed(precision).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n            }\n        }\n        return labels;\n    }\n    _auto_precision(ticks, need_sci) {\n        const labels = new Array(ticks.length);\n        const asc = this.last_precision <= 15;\n        outer: for (let x = this.last_precision; asc ? x <= 15 : x >= 1; asc ? x++ : x--) {\n            if (need_sci) {\n                labels[0] = ticks[0].toExponential(x);\n                for (let i = 1; i < ticks.length; i++) {\n                    if (labels[i] == labels[i - 1]) {\n                        continue outer;\n                    }\n                }\n                this.last_precision = x;\n                break;\n            }\n            else {\n                labels[0] = ticks[0].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                for (let i = 1; i < ticks.length; i++) {\n                    labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                    if (labels[i] == labels[i - 1]) {\n                        continue outer;\n                    }\n                }\n                this.last_precision = x;\n                break;\n            }\n        }\n        return this.last_precision;\n    }\n    doFormat(ticks, _opts) {\n        if (ticks.length == 0)\n            return [];\n        const need_sci = this._need_sci(ticks);\n        const precision = this.precision == \"auto\" ? this._auto_precision(ticks, need_sci) : this.precision;\n        return this._format_with_precision(ticks, need_sci, precision);\n    }\n}\nBasicTickFormatter.__name__ = \"BasicTickFormatter\";\nBasicTickFormatter.init_BasicTickFormatter();\n//# sourceMappingURL=basic_tick_formatter.js.map"]},"metadata":{},"sourceType":"module"}