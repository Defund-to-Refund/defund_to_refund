{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as p from \"../../core/properties\";\nimport { map, min, max } from \"../../core/util/arrayable\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { ImageLoader } from \"../../core/util/image\";\nexport class ImageURLView extends XYGlyphView {\n  constructor() {\n    super(...arguments);\n    this._images_rendered = false;\n  }\n\n  initialize() {\n    super.initialize();\n    this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n  }\n\n  _index_data() {\n    return new SpatialIndex([]);\n  }\n\n  _set_data() {\n    if (this.image == null || this.image.length != this._url.length) this.image = map(this._url, () => null);\n    const {\n      retry_attempts,\n      retry_timeout\n    } = this.model;\n\n    for (let i = 0, end = this._url.length; i < end; i++) {\n      const url = this._url[i];\n      if (url == null || url == \"\") continue;\n      new ImageLoader(url, {\n        loaded: image => {\n          this.image[i] = image;\n          this.renderer.request_render();\n        },\n        attempts: retry_attempts + 1,\n        timeout: retry_timeout\n      });\n    }\n\n    const w_data = this.model.properties.w.units == \"data\";\n    const h_data = this.model.properties.h.units == \"data\";\n    const n = this._x.length;\n    const xs = new Array(w_data ? 2 * n : n);\n    const ys = new Array(h_data ? 2 * n : n);\n\n    for (let i = 0; i < n; i++) {\n      xs[i] = this._x[i];\n      ys[i] = this._y[i];\n    } // if the width/height are in screen units, don't try to include them in bounds\n\n\n    if (w_data) {\n      for (let i = 0; i < n; i++) xs[n + i] = this._x[i] + this._w[i];\n    }\n\n    if (h_data) {\n      for (let i = 0; i < n; i++) ys[n + i] = this._y[i] + this._h[i];\n    }\n\n    const x0 = min(xs);\n    const x1 = max(xs);\n    const y0 = min(ys);\n    const y1 = max(ys);\n    this._bounds_rect = {\n      x0,\n      x1,\n      y0,\n      y1\n    };\n  }\n\n  has_finished() {\n    return super.has_finished() && this._images_rendered == true;\n  }\n\n  _map_data() {\n    // Better to check this.model.w and this.model.h for null since the set_data\n    // machinery will have converted this._w and this._w to lists of null\n    const ws = this.model.w != null ? this._w : map(this._x, () => NaN);\n    const hs = this.model.h != null ? this._h : map(this._x, () => NaN);\n\n    switch (this.model.properties.w.units) {\n      case \"data\":\n        {\n          this.sw = this.sdist(this.renderer.xscale, this._x, ws, \"edge\", this.model.dilate);\n          break;\n        }\n\n      case \"screen\":\n        {\n          this.sw = ws;\n          break;\n        }\n    }\n\n    switch (this.model.properties.h.units) {\n      case \"data\":\n        {\n          this.sh = this.sdist(this.renderer.yscale, this._y, hs, \"edge\", this.model.dilate);\n          break;\n        }\n\n      case \"screen\":\n        {\n          this.sh = hs;\n          break;\n        }\n    }\n  }\n\n  _render(ctx, indices, {\n    image,\n    sx,\n    sy,\n    sw,\n    sh,\n    _angle\n  }) {\n    // TODO (bev): take actual border width into account when clipping\n    const {\n      frame\n    } = this.renderer.plot_view;\n    ctx.rect(frame._left.value + 1, frame._top.value + 1, frame._width.value - 2, frame._height.value - 2);\n    ctx.clip();\n    let finished = true;\n\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + _angle[i])) continue;\n      const img = image[i];\n\n      if (img == null) {\n        finished = false;\n        continue;\n      }\n\n      this._render_image(ctx, i, img, sx, sy, sw, sh, _angle);\n    }\n\n    if (finished && !this._images_rendered) {\n      this._images_rendered = true;\n      this.notify_finished();\n    }\n  }\n\n  _final_sx_sy(anchor, sx, sy, sw, sh) {\n    switch (anchor) {\n      case 'top_left':\n        return [sx, sy];\n\n      case 'top_center':\n        return [sx - sw / 2, sy];\n\n      case 'top_right':\n        return [sx - sw, sy];\n\n      case 'center_right':\n        return [sx - sw, sy - sh / 2];\n\n      case 'bottom_right':\n        return [sx - sw, sy - sh];\n\n      case 'bottom_center':\n        return [sx - sw / 2, sy - sh];\n\n      case 'bottom_left':\n        return [sx, sy - sh];\n\n      case 'center_left':\n        return [sx, sy - sh / 2];\n\n      case 'center':\n        return [sx - sw / 2, sy - sh / 2];\n    }\n  }\n\n  _render_image(ctx, i, image, sx, sy, sw, sh, angle) {\n    if (isNaN(sw[i])) sw[i] = image.width;\n    if (isNaN(sh[i])) sh[i] = image.height;\n    const {\n      anchor\n    } = this.model;\n\n    const [sxi, syi] = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]);\n\n    ctx.save();\n    ctx.globalAlpha = this.model.global_alpha;\n    const sw2 = sw[i] / 2;\n    const sh2 = sh[i] / 2;\n\n    if (angle[i]) {\n      ctx.translate(sxi, syi); //rotation about center of image\n\n      ctx.translate(sw2, sh2);\n      ctx.rotate(angle[i]);\n      ctx.translate(-sw2, -sh2);\n      ctx.drawImage(image, 0, 0, sw[i], sh[i]);\n      ctx.translate(sw2, sh2);\n      ctx.rotate(-angle[i]);\n      ctx.translate(-sw2, -sh2);\n      ctx.translate(-sxi, -syi);\n    } else ctx.drawImage(image, sxi, syi, sw[i], sh[i]);\n\n    ctx.restore();\n  }\n\n  bounds() {\n    return this._bounds_rect;\n  }\n\n}\nImageURLView.__name__ = \"ImageURLView\";\nexport class ImageURL extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_ImageURL() {\n    this.prototype.default_view = ImageURLView;\n    this.define({\n      url: [p.StringSpec],\n      anchor: [p.Anchor, 'top_left'],\n      global_alpha: [p.Number, 1.0],\n      angle: [p.AngleSpec, 0],\n      w: [p.DistanceSpec],\n      h: [p.DistanceSpec],\n      dilate: [p.Boolean, false],\n      retry_attempts: [p.Number, 0],\n      retry_timeout: [p.Number, 0]\n    });\n  }\n\n}\nImageURL.__name__ = \"ImageURL\";\nImageURL.init_ImageURL();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image_url.js"],"names":["XYGlyph","XYGlyphView","p","map","min","max","SpatialIndex","ImageLoader","ImageURLView","constructor","arguments","_images_rendered","initialize","connect","model","properties","global_alpha","change","renderer","request_render","_index_data","_set_data","image","length","_url","retry_attempts","retry_timeout","i","end","url","loaded","attempts","timeout","w_data","w","units","h_data","h","n","_x","xs","Array","ys","_y","_w","_h","x0","x1","y0","y1","_bounds_rect","has_finished","_map_data","ws","NaN","hs","sw","sdist","xscale","dilate","sh","yscale","_render","ctx","indices","sx","sy","_angle","frame","plot_view","rect","_left","value","_top","_width","_height","clip","finished","isNaN","img","_render_image","notify_finished","_final_sx_sy","anchor","angle","width","height","sxi","syi","save","globalAlpha","sw2","sh2","translate","rotate","drawImage","restore","bounds","__name__","ImageURL","attrs","init_ImageURL","prototype","default_view","define","StringSpec","Anchor","Number","AngleSpec","DistanceSpec","Boolean"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as p from \"../../core/properties\";\nimport { map, min, max } from \"../../core/util/arrayable\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { ImageLoader } from \"../../core/util/image\";\nexport class ImageURLView extends XYGlyphView {\n    constructor() {\n        super(...arguments);\n        this._images_rendered = false;\n    }\n    initialize() {\n        super.initialize();\n        this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n    }\n    _index_data() {\n        return new SpatialIndex([]);\n    }\n    _set_data() {\n        if (this.image == null || this.image.length != this._url.length)\n            this.image = map(this._url, () => null);\n        const { retry_attempts, retry_timeout } = this.model;\n        for (let i = 0, end = this._url.length; i < end; i++) {\n            const url = this._url[i];\n            if (url == null || url == \"\")\n                continue;\n            new ImageLoader(url, {\n                loaded: (image) => {\n                    this.image[i] = image;\n                    this.renderer.request_render();\n                },\n                attempts: retry_attempts + 1,\n                timeout: retry_timeout,\n            });\n        }\n        const w_data = this.model.properties.w.units == \"data\";\n        const h_data = this.model.properties.h.units == \"data\";\n        const n = this._x.length;\n        const xs = new Array(w_data ? 2 * n : n);\n        const ys = new Array(h_data ? 2 * n : n);\n        for (let i = 0; i < n; i++) {\n            xs[i] = this._x[i];\n            ys[i] = this._y[i];\n        }\n        // if the width/height are in screen units, don't try to include them in bounds\n        if (w_data) {\n            for (let i = 0; i < n; i++)\n                xs[n + i] = this._x[i] + this._w[i];\n        }\n        if (h_data) {\n            for (let i = 0; i < n; i++)\n                ys[n + i] = this._y[i] + this._h[i];\n        }\n        const x0 = min(xs);\n        const x1 = max(xs);\n        const y0 = min(ys);\n        const y1 = max(ys);\n        this._bounds_rect = { x0, x1, y0, y1 };\n    }\n    has_finished() {\n        return super.has_finished() && this._images_rendered == true;\n    }\n    _map_data() {\n        // Better to check this.model.w and this.model.h for null since the set_data\n        // machinery will have converted this._w and this._w to lists of null\n        const ws = this.model.w != null ? this._w : map(this._x, () => NaN);\n        const hs = this.model.h != null ? this._h : map(this._x, () => NaN);\n        switch (this.model.properties.w.units) {\n            case \"data\": {\n                this.sw = this.sdist(this.renderer.xscale, this._x, ws, \"edge\", this.model.dilate);\n                break;\n            }\n            case \"screen\": {\n                this.sw = ws;\n                break;\n            }\n        }\n        switch (this.model.properties.h.units) {\n            case \"data\": {\n                this.sh = this.sdist(this.renderer.yscale, this._y, hs, \"edge\", this.model.dilate);\n                break;\n            }\n            case \"screen\": {\n                this.sh = hs;\n                break;\n            }\n        }\n    }\n    _render(ctx, indices, { image, sx, sy, sw, sh, _angle }) {\n        // TODO (bev): take actual border width into account when clipping\n        const { frame } = this.renderer.plot_view;\n        ctx.rect(frame._left.value + 1, frame._top.value + 1, frame._width.value - 2, frame._height.value - 2);\n        ctx.clip();\n        let finished = true;\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + _angle[i]))\n                continue;\n            const img = image[i];\n            if (img == null) {\n                finished = false;\n                continue;\n            }\n            this._render_image(ctx, i, img, sx, sy, sw, sh, _angle);\n        }\n        if (finished && !this._images_rendered) {\n            this._images_rendered = true;\n            this.notify_finished();\n        }\n    }\n    _final_sx_sy(anchor, sx, sy, sw, sh) {\n        switch (anchor) {\n            case 'top_left': return [sx, sy];\n            case 'top_center': return [sx - (sw / 2), sy];\n            case 'top_right': return [sx - sw, sy];\n            case 'center_right': return [sx - sw, sy - (sh / 2)];\n            case 'bottom_right': return [sx - sw, sy - sh];\n            case 'bottom_center': return [sx - (sw / 2), sy - sh];\n            case 'bottom_left': return [sx, sy - sh];\n            case 'center_left': return [sx, sy - (sh / 2)];\n            case 'center': return [sx - (sw / 2), sy - (sh / 2)];\n        }\n    }\n    _render_image(ctx, i, image, sx, sy, sw, sh, angle) {\n        if (isNaN(sw[i]))\n            sw[i] = image.width;\n        if (isNaN(sh[i]))\n            sh[i] = image.height;\n        const { anchor } = this.model;\n        const [sxi, syi] = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]);\n        ctx.save();\n        ctx.globalAlpha = this.model.global_alpha;\n        const sw2 = sw[i] / 2;\n        const sh2 = sh[i] / 2;\n        if (angle[i]) {\n            ctx.translate(sxi, syi);\n            //rotation about center of image\n            ctx.translate(sw2, sh2);\n            ctx.rotate(angle[i]);\n            ctx.translate(-sw2, -sh2);\n            ctx.drawImage(image, 0, 0, sw[i], sh[i]);\n            ctx.translate(sw2, sh2);\n            ctx.rotate(-angle[i]);\n            ctx.translate(-sw2, -sh2);\n            ctx.translate(-sxi, -syi);\n        }\n        else\n            ctx.drawImage(image, sxi, syi, sw[i], sh[i]);\n        ctx.restore();\n    }\n    bounds() {\n        return this._bounds_rect;\n    }\n}\nImageURLView.__name__ = \"ImageURLView\";\nexport class ImageURL extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ImageURL() {\n        this.prototype.default_view = ImageURLView;\n        this.define({\n            url: [p.StringSpec],\n            anchor: [p.Anchor, 'top_left'],\n            global_alpha: [p.Number, 1.0],\n            angle: [p.AngleSpec, 0],\n            w: [p.DistanceSpec],\n            h: [p.DistanceSpec],\n            dilate: [p.Boolean, false],\n            retry_attempts: [p.Number, 0],\n            retry_timeout: [p.Number, 0],\n        });\n    }\n}\nImageURL.__name__ = \"ImageURL\";\nImageURL.init_ImageURL();\n//# sourceMappingURL=image_url.js.map"]},"metadata":{},"sourceType":"module"}