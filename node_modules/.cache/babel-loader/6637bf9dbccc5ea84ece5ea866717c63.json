{"ast":null,"code":"import { RowSelectionModel } from \"@bokeh/slickgrid/plugins/slick.rowselectionmodel\";\nimport { CheckboxSelectColumn } from \"@bokeh/slickgrid/plugins/slick.checkboxselectcolumn\";\nimport { CellExternalCopyManager } from \"@bokeh/slickgrid/plugins/slick.cellexternalcopymanager\";\nimport { Grid as SlickGrid } from \"@bokeh/slickgrid\";\nimport * as p from \"../../../core/properties\";\nimport { uniqueId } from \"../../../core/util/string\";\nimport { isString } from \"../../../core/util/types\";\nimport { some, range } from \"../../../core/util/array\";\nimport { keys } from \"../../../core/util/object\";\nimport { logger } from \"../../../core/logging\";\nimport { LayoutItem } from \"../../../core/layout\";\nimport { TableWidget } from \"./table_widget\";\nimport { WidgetView } from \"../widget\";\nimport { bk_data_table, bk_cell_index, bk_header_index, bk_cell_select } from \"../../../styles/widgets/tables\";\nexport const DTINDEX_NAME = \"__bkdt_internal_index__\";\nexport class TableDataProvider {\n  constructor(source, view) {\n    this.init(source, view);\n  }\n\n  init(source, view) {\n    if (DTINDEX_NAME in source.data) throw new Error(`special name ${DTINDEX_NAME} cannot be used as a data table column`);\n    this.source = source;\n    this.view = view;\n    this.index = this.view.indices;\n  }\n\n  getLength() {\n    return this.index.length;\n  }\n\n  getItem(offset) {\n    const item = {};\n\n    for (const field of keys(this.source.data)) {\n      item[field] = this.source.data[field][this.index[offset]];\n    }\n\n    item[DTINDEX_NAME] = this.index[offset];\n    return item;\n  }\n\n  getField(offset, field) {\n    // offset is the\n    if (field == DTINDEX_NAME) {\n      return this.index[offset];\n    }\n\n    return this.source.data[field][this.index[offset]];\n  }\n\n  setField(offset, field, value) {\n    // field assumed never to be internal index name (ctor would throw)\n    const index = this.index[offset];\n    this.source.patch({\n      [field]: [[index, value]]\n    });\n  }\n\n  getItemMetadata(_index) {\n    return null;\n  }\n\n  getRecords() {\n    return range(0, this.getLength()).map(i => this.getItem(i));\n  }\n\n  sort(columns) {\n    let cols = columns.map(column => [column.sortCol.field, column.sortAsc ? 1 : -1]);\n\n    if (cols.length == 0) {\n      cols = [[DTINDEX_NAME, 1]];\n    }\n\n    const records = this.getRecords();\n    const old_index = this.index.slice();\n    this.index.sort(function (i1, i2) {\n      for (const [field, sign] of cols) {\n        const value1 = records[old_index.indexOf(i1)][field];\n        const value2 = records[old_index.indexOf(i2)][field];\n        const result = value1 == value2 ? 0 : value1 > value2 ? sign : -sign;\n        if (result != 0) return result;\n      }\n\n      return 0;\n    });\n  }\n\n}\nTableDataProvider.__name__ = \"TableDataProvider\";\nexport class DataTableView extends WidgetView {\n  constructor() {\n    super(...arguments);\n    this._in_selection_update = false;\n    this._warned_not_reorderable = false;\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.model.change, () => this.render());\n    this.connect(this.model.source.streaming, () => this.updateGrid());\n    this.connect(this.model.source.patching, () => this.updateGrid());\n    this.connect(this.model.source.change, () => this.updateGrid());\n    this.connect(this.model.source.properties.data.change, () => this.updateGrid());\n    this.connect(this.model.source.selected.change, () => this.updateSelection());\n    this.connect(this.model.source.selected.properties.indices.change, () => this.updateSelection());\n  }\n\n  _update_layout() {\n    this.layout = new LayoutItem();\n    this.layout.set_sizing(this.box_sizing());\n  }\n\n  update_position() {\n    super.update_position();\n    this.grid.resizeCanvas();\n  }\n\n  updateGrid() {\n    // TODO (bev) This is to ensure that CDSView indices are properly computed\n    // before passing to the DataProvider. This will result in extra calls to\n    // compute_indices. This \"over execution\" will be addressed in a more\n    // general look at events\n    this.model.view.compute_indices();\n    this.data.init(this.model.source, this.model.view); // This is obnoxious but there is no better way to programmatically force\n    // a re-sort on the existing sorted columns until/if we start using DataView\n\n    if (this.model.sortable) {\n      const columns = this.grid.getColumns();\n      const sorters = this.grid.getSortColumns().map(x => ({\n        sortCol: {\n          field: columns[this.grid.getColumnIndex(x.columnId)].field\n        },\n        sortAsc: x.sortAsc\n      }));\n      this.data.sort(sorters);\n    }\n\n    this.grid.invalidate();\n    this.grid.render();\n  }\n\n  updateSelection() {\n    if (this._in_selection_update) return;\n    const {\n      selected\n    } = this.model.source;\n    const permuted_indices = selected.indices.map(x => this.data.index.indexOf(x)).sort();\n    this._in_selection_update = true;\n    this.grid.setSelectedRows(permuted_indices);\n    this._in_selection_update = false; // If the selection is not in the current slickgrid viewport, scroll the\n    // datatable to start at the row before the first selected row, so that\n    // the selection is immediately brought into view. We don't scroll when\n    // the selection is already in the viewport so that selecting from the\n    // datatable itself does not re-scroll.\n\n    const cur_grid_range = this.grid.getViewport();\n    const scroll_index = this.model.get_scroll_index(cur_grid_range, permuted_indices);\n    if (scroll_index != null) this.grid.scrollRowToTop(scroll_index);\n  }\n\n  newIndexColumn() {\n    return {\n      id: uniqueId(),\n      name: this.model.index_header,\n      field: DTINDEX_NAME,\n      width: this.model.index_width,\n      behavior: \"select\",\n      cannotTriggerInsert: true,\n      resizable: false,\n      selectable: false,\n      sortable: true,\n      cssClass: bk_cell_index,\n      headerCssClass: bk_header_index\n    };\n  }\n\n  css_classes() {\n    return super.css_classes().concat(bk_data_table);\n  }\n\n  render() {\n    let checkboxSelector;\n    let columns = this.model.columns.map(column => column.toColumn());\n\n    if (this.model.selectable == \"checkbox\") {\n      checkboxSelector = new CheckboxSelectColumn({\n        cssClass: bk_cell_select\n      });\n      columns.unshift(checkboxSelector.getColumnDefinition());\n    }\n\n    if (this.model.index_position != null) {\n      const index_position = this.model.index_position;\n      const index = this.newIndexColumn(); // This is to be able to provide negative index behaviour that\n      // matches what python users will expect\n\n      if (index_position == -1) columns.push(index);else if (index_position < -1) columns.splice(index_position + 1, 0, index);else columns.splice(index_position, 0, index);\n    }\n\n    let {\n      reorderable\n    } = this.model;\n\n    if (reorderable && !(typeof $ !== \"undefined\" && $.fn != null && $.fn.sortable != null)) {\n      if (!this._warned_not_reorderable) {\n        logger.warn(\"jquery-ui is required to enable DataTable.reorderable\");\n        this._warned_not_reorderable = true;\n      }\n\n      reorderable = false;\n    }\n\n    const options = {\n      enableCellNavigation: this.model.selectable !== false,\n      enableColumnReorder: reorderable,\n      forceFitColumns: this.model.fit_columns,\n      multiColumnSort: this.model.sortable,\n      editable: this.model.editable,\n      autoEdit: false,\n      rowHeight: this.model.row_height\n    };\n    this.data = new TableDataProvider(this.model.source, this.model.view);\n    this.grid = new SlickGrid(this.el, this.data, columns, options);\n    this.grid.onSort.subscribe((_event, args) => {\n      if (!this.model.sortable) return;\n      columns = args.sortCols;\n      this.data.sort(columns);\n      this.grid.invalidate();\n      this.updateSelection();\n      this.grid.render();\n\n      if (!this.model.header_row) {\n        this._hide_header();\n      }\n\n      this.model.update_sort_columns(columns);\n    });\n\n    if (this.model.selectable !== false) {\n      this.grid.setSelectionModel(new RowSelectionModel({\n        selectActiveRow: checkboxSelector == null\n      }));\n      if (checkboxSelector != null) this.grid.registerPlugin(checkboxSelector);\n      const pluginOptions = {\n        dataItemColumnValueExtractor(val, col) {\n          // As defined in this file, Item can contain any type values\n          let value = val[col.field];\n\n          if (isString(value)) {\n            value = value.replace(/\\n/g, \"\\\\n\");\n          }\n\n          return value;\n        },\n\n        includeHeaderWhenCopying: false\n      };\n      this.grid.registerPlugin(new CellExternalCopyManager(pluginOptions));\n      this.grid.onSelectedRowsChanged.subscribe((_event, args) => {\n        if (this._in_selection_update) {\n          return;\n        }\n\n        this.model.source.selected.indices = args.rows.map(i => this.data.index[i]);\n      });\n      this.updateSelection();\n\n      if (!this.model.header_row) {\n        this._hide_header();\n      }\n    }\n  }\n\n  _hide_header() {\n    for (const el of Array.from(this.el.querySelectorAll('.slick-header-columns'))) {\n      el.style.height = \"0px\";\n    }\n\n    this.grid.resizeCanvas();\n  }\n\n}\nDataTableView.__name__ = \"DataTableView\";\nexport class DataTable extends TableWidget {\n  constructor(attrs) {\n    super(attrs);\n    this._sort_columns = [];\n  }\n\n  get sort_columns() {\n    return this._sort_columns;\n  }\n\n  static init_DataTable() {\n    this.prototype.default_view = DataTableView;\n    this.define({\n      columns: [p.Array, []],\n      fit_columns: [p.Boolean, true],\n      sortable: [p.Boolean, true],\n      reorderable: [p.Boolean, true],\n      editable: [p.Boolean, false],\n      selectable: [p.Any, true],\n      index_position: [p.Int, 0],\n      index_header: [p.String, \"#\"],\n      index_width: [p.Int, 40],\n      scroll_to_selection: [p.Boolean, true],\n      header_row: [p.Boolean, true],\n      row_height: [p.Int, 25]\n    });\n    this.override({\n      width: 600,\n      height: 400\n    });\n  }\n\n  update_sort_columns(sortCols) {\n    this._sort_columns = sortCols.map(x => ({\n      field: x.sortCol.field,\n      sortAsc: x.sortAsc\n    }));\n    return null;\n  }\n\n  get_scroll_index(grid_range, selected_indices) {\n    if (!this.scroll_to_selection || selected_indices.length == 0) return null;\n\n    if (!some(selected_indices, i => grid_range.top <= i && i <= grid_range.bottom)) {\n      return Math.max(0, Math.min(...selected_indices) - 1);\n    }\n\n    return null;\n  }\n\n}\nDataTable.__name__ = \"DataTable\";\nDataTable.init_DataTable();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/data_table.js"],"names":["RowSelectionModel","CheckboxSelectColumn","CellExternalCopyManager","Grid","SlickGrid","p","uniqueId","isString","some","range","keys","logger","LayoutItem","TableWidget","WidgetView","bk_data_table","bk_cell_index","bk_header_index","bk_cell_select","DTINDEX_NAME","TableDataProvider","constructor","source","view","init","data","Error","index","indices","getLength","length","getItem","offset","item","field","getField","setField","value","patch","getItemMetadata","_index","getRecords","map","i","sort","columns","cols","column","sortCol","sortAsc","records","old_index","slice","i1","i2","sign","value1","indexOf","value2","result","__name__","DataTableView","arguments","_in_selection_update","_warned_not_reorderable","connect_signals","connect","model","change","render","streaming","updateGrid","patching","properties","selected","updateSelection","_update_layout","layout","set_sizing","box_sizing","update_position","grid","resizeCanvas","compute_indices","sortable","getColumns","sorters","getSortColumns","x","getColumnIndex","columnId","invalidate","permuted_indices","setSelectedRows","cur_grid_range","getViewport","scroll_index","get_scroll_index","scrollRowToTop","newIndexColumn","id","name","index_header","width","index_width","behavior","cannotTriggerInsert","resizable","selectable","cssClass","headerCssClass","css_classes","concat","checkboxSelector","toColumn","unshift","getColumnDefinition","index_position","push","splice","reorderable","$","fn","warn","options","enableCellNavigation","enableColumnReorder","forceFitColumns","fit_columns","multiColumnSort","editable","autoEdit","rowHeight","row_height","el","onSort","subscribe","_event","args","sortCols","header_row","_hide_header","update_sort_columns","setSelectionModel","selectActiveRow","registerPlugin","pluginOptions","dataItemColumnValueExtractor","val","col","replace","includeHeaderWhenCopying","onSelectedRowsChanged","rows","Array","from","querySelectorAll","style","height","DataTable","attrs","_sort_columns","sort_columns","init_DataTable","prototype","default_view","define","Boolean","Any","Int","String","scroll_to_selection","override","grid_range","selected_indices","top","bottom","Math","max","min"],"mappings":"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","sourcesContent":["import { RowSelectionModel } from \"@bokeh/slickgrid/plugins/slick.rowselectionmodel\";\nimport { CheckboxSelectColumn } from \"@bokeh/slickgrid/plugins/slick.checkboxselectcolumn\";\nimport { CellExternalCopyManager } from \"@bokeh/slickgrid/plugins/slick.cellexternalcopymanager\";\nimport { Grid as SlickGrid } from \"@bokeh/slickgrid\";\nimport * as p from \"../../../core/properties\";\nimport { uniqueId } from \"../../../core/util/string\";\nimport { isString } from \"../../../core/util/types\";\nimport { some, range } from \"../../../core/util/array\";\nimport { keys } from \"../../../core/util/object\";\nimport { logger } from \"../../../core/logging\";\nimport { LayoutItem } from \"../../../core/layout\";\nimport { TableWidget } from \"./table_widget\";\nimport { WidgetView } from \"../widget\";\nimport { bk_data_table, bk_cell_index, bk_header_index, bk_cell_select } from \"../../../styles/widgets/tables\";\nexport const DTINDEX_NAME = \"__bkdt_internal_index__\";\nexport class TableDataProvider {\n    constructor(source, view) {\n        this.init(source, view);\n    }\n    init(source, view) {\n        if (DTINDEX_NAME in source.data)\n            throw new Error(`special name ${DTINDEX_NAME} cannot be used as a data table column`);\n        this.source = source;\n        this.view = view;\n        this.index = this.view.indices;\n    }\n    getLength() {\n        return this.index.length;\n    }\n    getItem(offset) {\n        const item = {};\n        for (const field of keys(this.source.data)) {\n            item[field] = this.source.data[field][this.index[offset]];\n        }\n        item[DTINDEX_NAME] = this.index[offset];\n        return item;\n    }\n    getField(offset, field) {\n        // offset is the\n        if (field == DTINDEX_NAME) {\n            return this.index[offset];\n        }\n        return this.source.data[field][this.index[offset]];\n    }\n    setField(offset, field, value) {\n        // field assumed never to be internal index name (ctor would throw)\n        const index = this.index[offset];\n        this.source.patch({ [field]: [[index, value]] });\n    }\n    getItemMetadata(_index) {\n        return null;\n    }\n    getRecords() {\n        return range(0, this.getLength()).map((i) => this.getItem(i));\n    }\n    sort(columns) {\n        let cols = columns.map((column) => [column.sortCol.field, column.sortAsc ? 1 : -1]);\n        if (cols.length == 0) {\n            cols = [[DTINDEX_NAME, 1]];\n        }\n        const records = this.getRecords();\n        const old_index = this.index.slice();\n        this.index.sort(function (i1, i2) {\n            for (const [field, sign] of cols) {\n                const value1 = records[old_index.indexOf(i1)][field];\n                const value2 = records[old_index.indexOf(i2)][field];\n                const result = value1 == value2 ? 0 : value1 > value2 ? sign : -sign;\n                if (result != 0)\n                    return result;\n            }\n            return 0;\n        });\n    }\n}\nTableDataProvider.__name__ = \"TableDataProvider\";\nexport class DataTableView extends WidgetView {\n    constructor() {\n        super(...arguments);\n        this._in_selection_update = false;\n        this._warned_not_reorderable = false;\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.change, () => this.render());\n        this.connect(this.model.source.streaming, () => this.updateGrid());\n        this.connect(this.model.source.patching, () => this.updateGrid());\n        this.connect(this.model.source.change, () => this.updateGrid());\n        this.connect(this.model.source.properties.data.change, () => this.updateGrid());\n        this.connect(this.model.source.selected.change, () => this.updateSelection());\n        this.connect(this.model.source.selected.properties.indices.change, () => this.updateSelection());\n    }\n    _update_layout() {\n        this.layout = new LayoutItem();\n        this.layout.set_sizing(this.box_sizing());\n    }\n    update_position() {\n        super.update_position();\n        this.grid.resizeCanvas();\n    }\n    updateGrid() {\n        // TODO (bev) This is to ensure that CDSView indices are properly computed\n        // before passing to the DataProvider. This will result in extra calls to\n        // compute_indices. This \"over execution\" will be addressed in a more\n        // general look at events\n        this.model.view.compute_indices();\n        this.data.init(this.model.source, this.model.view);\n        // This is obnoxious but there is no better way to programmatically force\n        // a re-sort on the existing sorted columns until/if we start using DataView\n        if (this.model.sortable) {\n            const columns = this.grid.getColumns();\n            const sorters = this.grid.getSortColumns().map((x) => ({\n                sortCol: {\n                    field: columns[this.grid.getColumnIndex(x.columnId)].field,\n                },\n                sortAsc: x.sortAsc,\n            }));\n            this.data.sort(sorters);\n        }\n        this.grid.invalidate();\n        this.grid.render();\n    }\n    updateSelection() {\n        if (this._in_selection_update)\n            return;\n        const { selected } = this.model.source;\n        const permuted_indices = selected.indices.map((x) => this.data.index.indexOf(x)).sort();\n        this._in_selection_update = true;\n        this.grid.setSelectedRows(permuted_indices);\n        this._in_selection_update = false;\n        // If the selection is not in the current slickgrid viewport, scroll the\n        // datatable to start at the row before the first selected row, so that\n        // the selection is immediately brought into view. We don't scroll when\n        // the selection is already in the viewport so that selecting from the\n        // datatable itself does not re-scroll.\n        const cur_grid_range = this.grid.getViewport();\n        const scroll_index = this.model.get_scroll_index(cur_grid_range, permuted_indices);\n        if (scroll_index != null)\n            this.grid.scrollRowToTop(scroll_index);\n    }\n    newIndexColumn() {\n        return {\n            id: uniqueId(),\n            name: this.model.index_header,\n            field: DTINDEX_NAME,\n            width: this.model.index_width,\n            behavior: \"select\",\n            cannotTriggerInsert: true,\n            resizable: false,\n            selectable: false,\n            sortable: true,\n            cssClass: bk_cell_index,\n            headerCssClass: bk_header_index,\n        };\n    }\n    css_classes() {\n        return super.css_classes().concat(bk_data_table);\n    }\n    render() {\n        let checkboxSelector;\n        let columns = this.model.columns.map((column) => column.toColumn());\n        if (this.model.selectable == \"checkbox\") {\n            checkboxSelector = new CheckboxSelectColumn({ cssClass: bk_cell_select });\n            columns.unshift(checkboxSelector.getColumnDefinition());\n        }\n        if (this.model.index_position != null) {\n            const index_position = this.model.index_position;\n            const index = this.newIndexColumn();\n            // This is to be able to provide negative index behaviour that\n            // matches what python users will expect\n            if (index_position == -1)\n                columns.push(index);\n            else if (index_position < -1)\n                columns.splice(index_position + 1, 0, index);\n            else\n                columns.splice(index_position, 0, index);\n        }\n        let { reorderable } = this.model;\n        if (reorderable && !(typeof $ !== \"undefined\" && $.fn != null && $.fn.sortable != null)) {\n            if (!this._warned_not_reorderable) {\n                logger.warn(\"jquery-ui is required to enable DataTable.reorderable\");\n                this._warned_not_reorderable = true;\n            }\n            reorderable = false;\n        }\n        const options = {\n            enableCellNavigation: this.model.selectable !== false,\n            enableColumnReorder: reorderable,\n            forceFitColumns: this.model.fit_columns,\n            multiColumnSort: this.model.sortable,\n            editable: this.model.editable,\n            autoEdit: false,\n            rowHeight: this.model.row_height,\n        };\n        this.data = new TableDataProvider(this.model.source, this.model.view);\n        this.grid = new SlickGrid(this.el, this.data, columns, options);\n        this.grid.onSort.subscribe((_event, args) => {\n            if (!this.model.sortable)\n                return;\n            columns = args.sortCols;\n            this.data.sort(columns);\n            this.grid.invalidate();\n            this.updateSelection();\n            this.grid.render();\n            if (!this.model.header_row) {\n                this._hide_header();\n            }\n            this.model.update_sort_columns(columns);\n        });\n        if (this.model.selectable !== false) {\n            this.grid.setSelectionModel(new RowSelectionModel({ selectActiveRow: checkboxSelector == null }));\n            if (checkboxSelector != null)\n                this.grid.registerPlugin(checkboxSelector);\n            const pluginOptions = {\n                dataItemColumnValueExtractor(val, col) {\n                    // As defined in this file, Item can contain any type values\n                    let value = val[col.field];\n                    if (isString(value)) {\n                        value = value.replace(/\\n/g, \"\\\\n\");\n                    }\n                    return value;\n                },\n                includeHeaderWhenCopying: false,\n            };\n            this.grid.registerPlugin(new CellExternalCopyManager(pluginOptions));\n            this.grid.onSelectedRowsChanged.subscribe((_event, args) => {\n                if (this._in_selection_update) {\n                    return;\n                }\n                this.model.source.selected.indices = args.rows.map((i) => this.data.index[i]);\n            });\n            this.updateSelection();\n            if (!this.model.header_row) {\n                this._hide_header();\n            }\n        }\n    }\n    _hide_header() {\n        for (const el of Array.from(this.el.querySelectorAll('.slick-header-columns'))) {\n            el.style.height = \"0px\";\n        }\n        this.grid.resizeCanvas();\n    }\n}\nDataTableView.__name__ = \"DataTableView\";\nexport class DataTable extends TableWidget {\n    constructor(attrs) {\n        super(attrs);\n        this._sort_columns = [];\n    }\n    get sort_columns() { return this._sort_columns; }\n    static init_DataTable() {\n        this.prototype.default_view = DataTableView;\n        this.define({\n            columns: [p.Array, []],\n            fit_columns: [p.Boolean, true],\n            sortable: [p.Boolean, true],\n            reorderable: [p.Boolean, true],\n            editable: [p.Boolean, false],\n            selectable: [p.Any, true],\n            index_position: [p.Int, 0],\n            index_header: [p.String, \"#\"],\n            index_width: [p.Int, 40],\n            scroll_to_selection: [p.Boolean, true],\n            header_row: [p.Boolean, true],\n            row_height: [p.Int, 25],\n        });\n        this.override({\n            width: 600,\n            height: 400,\n        });\n    }\n    update_sort_columns(sortCols) {\n        this._sort_columns = sortCols.map((x) => ({ field: x.sortCol.field, sortAsc: x.sortAsc }));\n        return null;\n    }\n    get_scroll_index(grid_range, selected_indices) {\n        if (!this.scroll_to_selection || (selected_indices.length == 0))\n            return null;\n        if (!some(selected_indices, i => grid_range.top <= i && i <= grid_range.bottom)) {\n            return Math.max(0, Math.min(...selected_indices) - 1);\n        }\n        return null;\n    }\n}\nDataTable.__name__ = \"DataTable\";\nDataTable.init_DataTable();\n//# sourceMappingURL=data_table.js.map"]},"metadata":{},"sourceType":"module"}