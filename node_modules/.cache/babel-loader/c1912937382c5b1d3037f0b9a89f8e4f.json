{"ast":null,"code":"import { ColumnarDataSource } from \"./columnar_data_source\";\nimport { HasProps } from \"../../core/has_props\";\nimport * as p from \"../../core/properties\";\nimport { Set } from \"../../core/util/data_structures\";\nimport { encode_column_data, decode_column_data } from \"../../core/util/serialization\";\nimport { isTypedArray, isArray, isNumber, isPlainObject } from \"../../core/util/types\";\nimport * as typed_array from \"../../core/util/typed_array\";\nimport { keys } from \"../../core/util/object\";\nimport { ColumnsPatchedEvent, ColumnsStreamedEvent } from \"../../document/events\"; //exported for testing\n\nexport function stream_to_column(col, new_col, rollover) {\n  if (isArray(col)) {\n    const result = col.concat(new_col);\n    if (rollover != null && result.length > rollover) return result.slice(-rollover);else return result;\n  } else if (isTypedArray(col)) {\n    const total_len = col.length + new_col.length; // handle rollover case for typed arrays\n\n    if (rollover != null && total_len > rollover) {\n      const start = total_len - rollover;\n      const end = col.length; // resize col if it is shorter than the rollover length\n\n      let result;\n\n      if (col.length < rollover) {\n        result = new col.constructor(rollover);\n        result.set(col, 0);\n      } else result = col; // shift values in original col to accommodate new_col\n\n\n      for (let i = start, endi = end; i < endi; i++) {\n        result[i - start] = result[i];\n      } // update end values in col with new_col\n\n\n      for (let i = 0, endi = new_col.length; i < endi; i++) {\n        result[i + (end - start)] = new_col[i];\n      }\n\n      return result;\n    } else {\n      const tmp = new col.constructor(new_col);\n      return typed_array.concat(col, tmp);\n    }\n  } else throw new Error(\"unsupported array types\");\n} // exported for testing\n\nexport function slice(ind, length) {\n  let start, step, stop;\n\n  if (isNumber(ind)) {\n    start = ind;\n    stop = ind + 1;\n    step = 1;\n  } else {\n    start = ind.start != null ? ind.start : 0;\n    stop = ind.stop != null ? ind.stop : length;\n    step = ind.step != null ? ind.step : 1;\n  }\n\n  return [start, stop, step];\n} // exported for testing\n\nexport function patch_to_column(col, patch, shapes) {\n  const patched = new Set();\n  let patched_range = false;\n\n  for (const [ind, val] of patch) {\n    // make the single index case look like the length-3 multi-index case\n    let item, shape;\n    let index;\n    let value;\n\n    if (isArray(ind)) {\n      const [i] = ind;\n      patched.add(i);\n      shape = shapes[i];\n      item = col[i];\n      value = val; // this is basically like NumPy's \"newaxis\", inserting an empty dimension\n      // makes length 2 and 3 multi-index cases uniform, so that the same code\n      // can handle both\n\n      if (ind.length === 2) {\n        shape = [1, shape[0]];\n        index = [ind[0], 0, ind[1]];\n      } else index = ind;\n    } else {\n      if (isNumber(ind)) {\n        value = [val];\n        patched.add(ind);\n      } else {\n        value = val;\n        patched_range = true;\n      }\n\n      index = [0, 0, ind];\n      shape = [1, col.length];\n      item = col;\n    } // now this one nested loop handles all cases\n\n\n    let flat_index = 0;\n    const [istart, istop, istep] = slice(index[1], shape[0]);\n    const [jstart, jstop, jstep] = slice(index[2], shape[1]);\n\n    for (let i = istart; i < istop; i += istep) {\n      for (let j = jstart; j < jstop; j += jstep) {\n        if (patched_range) {\n          patched.add(j);\n        }\n\n        item[i * shape[1] + j] = value[flat_index];\n        flat_index++;\n      }\n    }\n  }\n\n  return patched;\n}\nexport class ColumnDataSource extends ColumnarDataSource {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_ColumnDataSource() {\n    this.define({\n      data: [p.Any, {}]\n    });\n  }\n\n  initialize() {\n    super.initialize();\n    [this.data, this._shapes] = decode_column_data(this.data);\n  }\n\n  attributes_as_json(include_defaults = true, value_to_json = ColumnDataSource._value_to_json) {\n    const attrs = {};\n    const obj = this.serializable_attributes();\n\n    for (const key of keys(obj)) {\n      let value = obj[key];\n      if (key === 'data') value = encode_column_data(value, this._shapes);\n      if (include_defaults) attrs[key] = value;else if (key in this._set_after_defaults) attrs[key] = value;\n    }\n\n    return value_to_json(\"attributes\", attrs, this);\n  }\n\n  static _value_to_json(key, value, optional_parent_object) {\n    if (isPlainObject(value) && key === 'data') return encode_column_data(value, optional_parent_object._shapes); // XXX: unknown vs. any\n    else return HasProps._value_to_json(key, value, optional_parent_object);\n  }\n\n  stream(new_data, rollover, setter_id) {\n    const {\n      data\n    } = this;\n\n    for (const k in new_data) {\n      data[k] = stream_to_column(data[k], new_data[k], rollover);\n    }\n\n    this.setv({\n      data\n    }, {\n      silent: true\n    });\n    this.streaming.emit();\n\n    if (this.document != null) {\n      const hint = new ColumnsStreamedEvent(this.document, this.ref(), new_data, rollover);\n\n      this.document._notify_change(this, 'data', null, null, {\n        setter_id,\n        hint\n      });\n    }\n  }\n\n  patch(patches, setter_id) {\n    const {\n      data\n    } = this;\n    let patched = new Set();\n\n    for (const k in patches) {\n      const patch = patches[k];\n      patched = patched.union(patch_to_column(data[k], patch, this._shapes[k]));\n    }\n\n    this.setv({\n      data\n    }, {\n      silent: true\n    });\n    this.patching.emit(patched.values);\n\n    if (this.document != null) {\n      const hint = new ColumnsPatchedEvent(this.document, this.ref(), patches);\n\n      this.document._notify_change(this, 'data', null, null, {\n        setter_id,\n        hint\n      });\n    }\n  }\n\n}\nColumnDataSource.__name__ = \"ColumnDataSource\";\nColumnDataSource.init_ColumnDataSource();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/sources/column_data_source.js"],"names":["ColumnarDataSource","HasProps","p","Set","encode_column_data","decode_column_data","isTypedArray","isArray","isNumber","isPlainObject","typed_array","keys","ColumnsPatchedEvent","ColumnsStreamedEvent","stream_to_column","col","new_col","rollover","result","concat","length","slice","total_len","start","end","constructor","set","i","endi","tmp","Error","ind","step","stop","patch_to_column","patch","shapes","patched","patched_range","val","item","shape","index","value","add","flat_index","istart","istop","istep","jstart","jstop","jstep","j","ColumnDataSource","attrs","init_ColumnDataSource","define","data","Any","initialize","_shapes","attributes_as_json","include_defaults","value_to_json","_value_to_json","obj","serializable_attributes","key","_set_after_defaults","optional_parent_object","stream","new_data","setter_id","k","setv","silent","streaming","emit","document","hint","ref","_notify_change","patches","union","patching","values","__name__"],"mappings":"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","sourcesContent":["import { ColumnarDataSource } from \"./columnar_data_source\";\nimport { HasProps } from \"../../core/has_props\";\nimport * as p from \"../../core/properties\";\nimport { Set } from \"../../core/util/data_structures\";\nimport { encode_column_data, decode_column_data } from \"../../core/util/serialization\";\nimport { isTypedArray, isArray, isNumber, isPlainObject } from \"../../core/util/types\";\nimport * as typed_array from \"../../core/util/typed_array\";\nimport { keys } from \"../../core/util/object\";\nimport { ColumnsPatchedEvent, ColumnsStreamedEvent } from \"../../document/events\";\n//exported for testing\nexport function stream_to_column(col, new_col, rollover) {\n    if (isArray(col)) {\n        const result = col.concat(new_col);\n        if (rollover != null && result.length > rollover)\n            return result.slice(-rollover);\n        else\n            return result;\n    }\n    else if (isTypedArray(col)) {\n        const total_len = col.length + new_col.length;\n        // handle rollover case for typed arrays\n        if (rollover != null && total_len > rollover) {\n            const start = total_len - rollover;\n            const end = col.length;\n            // resize col if it is shorter than the rollover length\n            let result;\n            if (col.length < rollover) {\n                result = new col.constructor(rollover);\n                result.set(col, 0);\n            }\n            else\n                result = col;\n            // shift values in original col to accommodate new_col\n            for (let i = start, endi = end; i < endi; i++) {\n                result[i - start] = result[i];\n            }\n            // update end values in col with new_col\n            for (let i = 0, endi = new_col.length; i < endi; i++) {\n                result[i + (end - start)] = new_col[i];\n            }\n            return result;\n        }\n        else {\n            const tmp = new col.constructor(new_col);\n            return typed_array.concat(col, tmp);\n        }\n    }\n    else\n        throw new Error(\"unsupported array types\");\n}\n// exported for testing\nexport function slice(ind, length) {\n    let start, step, stop;\n    if (isNumber(ind)) {\n        start = ind;\n        stop = ind + 1;\n        step = 1;\n    }\n    else {\n        start = ind.start != null ? ind.start : 0;\n        stop = ind.stop != null ? ind.stop : length;\n        step = ind.step != null ? ind.step : 1;\n    }\n    return [start, stop, step];\n}\n// exported for testing\nexport function patch_to_column(col, patch, shapes) {\n    const patched = new Set();\n    let patched_range = false;\n    for (const [ind, val] of patch) {\n        // make the single index case look like the length-3 multi-index case\n        let item, shape;\n        let index;\n        let value;\n        if (isArray(ind)) {\n            const [i] = ind;\n            patched.add(i);\n            shape = shapes[i];\n            item = col[i];\n            value = val;\n            // this is basically like NumPy's \"newaxis\", inserting an empty dimension\n            // makes length 2 and 3 multi-index cases uniform, so that the same code\n            // can handle both\n            if (ind.length === 2) {\n                shape = [1, shape[0]];\n                index = [ind[0], 0, ind[1]];\n            }\n            else\n                index = ind;\n        }\n        else {\n            if (isNumber(ind)) {\n                value = [val];\n                patched.add(ind);\n            }\n            else {\n                value = val;\n                patched_range = true;\n            }\n            index = [0, 0, ind];\n            shape = [1, col.length];\n            item = col;\n        }\n        // now this one nested loop handles all cases\n        let flat_index = 0;\n        const [istart, istop, istep] = slice(index[1], shape[0]);\n        const [jstart, jstop, jstep] = slice(index[2], shape[1]);\n        for (let i = istart; i < istop; i += istep) {\n            for (let j = jstart; j < jstop; j += jstep) {\n                if (patched_range) {\n                    patched.add(j);\n                }\n                item[(i * shape[1]) + j] = value[flat_index];\n                flat_index++;\n            }\n        }\n    }\n    return patched;\n}\nexport class ColumnDataSource extends ColumnarDataSource {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ColumnDataSource() {\n        this.define({\n            data: [p.Any, {}],\n        });\n    }\n    initialize() {\n        super.initialize();\n        [this.data, this._shapes] = decode_column_data(this.data);\n    }\n    attributes_as_json(include_defaults = true, value_to_json = ColumnDataSource._value_to_json) {\n        const attrs = {};\n        const obj = this.serializable_attributes();\n        for (const key of keys(obj)) {\n            let value = obj[key];\n            if (key === 'data')\n                value = encode_column_data(value, this._shapes);\n            if (include_defaults)\n                attrs[key] = value;\n            else if (key in this._set_after_defaults)\n                attrs[key] = value;\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    }\n    static _value_to_json(key, value, optional_parent_object) {\n        if (isPlainObject(value) && key === 'data')\n            return encode_column_data(value, optional_parent_object._shapes); // XXX: unknown vs. any\n        else\n            return HasProps._value_to_json(key, value, optional_parent_object);\n    }\n    stream(new_data, rollover, setter_id) {\n        const { data } = this;\n        for (const k in new_data) {\n            data[k] = stream_to_column(data[k], new_data[k], rollover);\n        }\n        this.setv({ data }, { silent: true });\n        this.streaming.emit();\n        if (this.document != null) {\n            const hint = new ColumnsStreamedEvent(this.document, this.ref(), new_data, rollover);\n            this.document._notify_change(this, 'data', null, null, { setter_id, hint });\n        }\n    }\n    patch(patches, setter_id) {\n        const { data } = this;\n        let patched = new Set();\n        for (const k in patches) {\n            const patch = patches[k];\n            patched = patched.union(patch_to_column(data[k], patch, this._shapes[k]));\n        }\n        this.setv({ data }, { silent: true });\n        this.patching.emit(patched.values);\n        if (this.document != null) {\n            const hint = new ColumnsPatchedEvent(this.document, this.ref(), patches);\n            this.document._notify_change(this, 'data', null, null, { setter_id, hint });\n        }\n    }\n}\nColumnDataSource.__name__ = \"ColumnDataSource\";\nColumnDataSource.init_ColumnDataSource();\n//# sourceMappingURL=column_data_source.js.map"]},"metadata":{},"sourceType":"module"}