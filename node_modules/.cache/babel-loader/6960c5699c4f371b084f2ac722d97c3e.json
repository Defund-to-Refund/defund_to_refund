{"ast":null,"code":"export function angle_norm(angle) {\n  if (angle == 0) {\n    return 0;\n  }\n\n  while (angle <= 0) {\n    angle += 2 * Math.PI;\n  }\n\n  while (angle > 2 * Math.PI) {\n    angle -= 2 * Math.PI;\n  }\n\n  return angle;\n}\nexport function angle_dist(lhs, rhs) {\n  return angle_norm(lhs - rhs);\n}\nexport function angle_between(mid, lhs, rhs, direction) {\n  const d = angle_dist(lhs, rhs);\n  if (d == 0) return false;\n  if (d == 2 * Math.PI) return true;\n  const norm_mid = angle_norm(mid);\n  const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\n  return direction == 0\n  /* clock */\n  ? cond : !cond;\n}\nexport function random() {\n  return Math.random();\n}\nexport function randomIn(min, max) {\n  if (max == null) {\n    max = min;\n    min = 0;\n  }\n\n  return min + Math.floor(Math.random() * (max - min + 1));\n}\nexport function atan2(start, end) {\n  /*\n   * Calculate the angle between a line containing start and end points (composed\n   * of [x, y] arrays) and the positive x-axis.\n   */\n  return Math.atan2(end[1] - start[1], end[0] - start[0]);\n} // http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\n\nexport function rnorm(mu, sigma) {\n  // Generate a random normal with a mean of 0 and a sigma of 1\n  let r1;\n  let r2;\n\n  while (true) {\n    r1 = random();\n    r2 = random();\n    r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\n    if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2) break;\n  }\n\n  let rn = r2 / r1; // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n\n  rn = mu + sigma * rn;\n  return rn;\n}\nexport function clamp(val, min, max) {\n  if (val > max) return max;\n  if (val < min) return min;\n  return val;\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/math.js"],"names":["angle_norm","angle","Math","PI","angle_dist","lhs","rhs","angle_between","mid","direction","d","norm_mid","cond","random","randomIn","min","max","floor","atan2","start","end","rnorm","mu","sigma","r1","r2","sqrt","E","log","rn","clamp","val"],"mappings":"AAAA,OAAO,SAASA,UAAT,CAAoBC,KAApB,EAA2B;AAC9B,MAAIA,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAO,CAAP;AACH;;AACD,SAAOA,KAAK,IAAI,CAAhB,EAAmB;AACfA,IAAAA,KAAK,IAAI,IAAIC,IAAI,CAACC,EAAlB;AACH;;AACD,SAAOF,KAAK,GAAG,IAAIC,IAAI,CAACC,EAAxB,EAA4B;AACxBF,IAAAA,KAAK,IAAI,IAAIC,IAAI,CAACC,EAAlB;AACH;;AACD,SAAOF,KAAP;AACH;AACD,OAAO,SAASG,UAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AACjC,SAAON,UAAU,CAACK,GAAG,GAAGC,GAAP,CAAjB;AACH;AACD,OAAO,SAASC,aAAT,CAAuBC,GAAvB,EAA4BH,GAA5B,EAAiCC,GAAjC,EAAsCG,SAAtC,EAAiD;AACpD,QAAMC,CAAC,GAAGN,UAAU,CAACC,GAAD,EAAMC,GAAN,CAApB;AACA,MAAII,CAAC,IAAI,CAAT,EACI,OAAO,KAAP;AACJ,MAAIA,CAAC,IAAI,IAAIR,IAAI,CAACC,EAAlB,EACI,OAAO,IAAP;AACJ,QAAMQ,QAAQ,GAAGX,UAAU,CAACQ,GAAD,CAA3B;AACA,QAAMI,IAAI,GAAGR,UAAU,CAACC,GAAD,EAAMM,QAAN,CAAV,IAA6BD,CAA7B,IAAkCN,UAAU,CAACO,QAAD,EAAWL,GAAX,CAAV,IAA6BI,CAA5E;AACA,SAAQD,SAAS,IAAI;AAAE;AAAhB,IAA+BG,IAA/B,GAAsC,CAACA,IAA9C;AACH;AACD,OAAO,SAASC,MAAT,GAAkB;AACrB,SAAOX,IAAI,CAACW,MAAL,EAAP;AACH;AACD,OAAO,SAASC,QAAT,CAAkBC,GAAlB,EAAuBC,GAAvB,EAA4B;AAC/B,MAAIA,GAAG,IAAI,IAAX,EAAiB;AACbA,IAAAA,GAAG,GAAGD,GAAN;AACAA,IAAAA,GAAG,GAAG,CAAN;AACH;;AACD,SAAOA,GAAG,GAAGb,IAAI,CAACe,KAAL,CAAWf,IAAI,CAACW,MAAL,MAAiBG,GAAG,GAAGD,GAAN,GAAY,CAA7B,CAAX,CAAb;AACH;AACD,OAAO,SAASG,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2B;AAC9B;;;;AAIA,SAAOlB,IAAI,CAACgB,KAAL,CAAWE,GAAG,CAAC,CAAD,CAAH,GAASD,KAAK,CAAC,CAAD,CAAzB,EAA8BC,GAAG,CAAC,CAAD,CAAH,GAASD,KAAK,CAAC,CAAD,CAA5C,CAAP;AACH,C,CACD;;AACA,OAAO,SAASE,KAAT,CAAeC,EAAf,EAAmBC,KAAnB,EAA0B;AAC7B;AACA,MAAIC,EAAJ;AACA,MAAIC,EAAJ;;AACA,SAAO,IAAP,EAAa;AACTD,IAAAA,EAAE,GAAGX,MAAM,EAAX;AACAY,IAAAA,EAAE,GAAGZ,MAAM,EAAX;AACAY,IAAAA,EAAE,GAAG,CAAC,IAAIA,EAAJ,GAAS,CAAV,IAAevB,IAAI,CAACwB,IAAL,CAAU,KAAK,IAAIxB,IAAI,CAACyB,CAAd,CAAV,CAApB;AACA,QAAI,CAAC,CAAD,GAAKH,EAAL,GAAUA,EAAV,GAAetB,IAAI,CAAC0B,GAAL,CAASJ,EAAT,CAAf,IAA+BC,EAAE,GAAGA,EAAxC,EACI;AACP;;AACD,MAAII,EAAE,GAAGJ,EAAE,GAAGD,EAAd,CAX6B,CAY7B;;AACAK,EAAAA,EAAE,GAAGP,EAAE,GAAGC,KAAK,GAAGM,EAAlB;AACA,SAAOA,EAAP;AACH;AACD,OAAO,SAASC,KAAT,CAAeC,GAAf,EAAoBhB,GAApB,EAAyBC,GAAzB,EAA8B;AACjC,MAAIe,GAAG,GAAGf,GAAV,EACI,OAAOA,GAAP;AACJ,MAAIe,GAAG,GAAGhB,GAAV,EACI,OAAOA,GAAP;AACJ,SAAOgB,GAAP;AACH","sourcesContent":["export function angle_norm(angle) {\n    if (angle == 0) {\n        return 0;\n    }\n    while (angle <= 0) {\n        angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n    }\n    return angle;\n}\nexport function angle_dist(lhs, rhs) {\n    return angle_norm(lhs - rhs);\n}\nexport function angle_between(mid, lhs, rhs, direction) {\n    const d = angle_dist(lhs, rhs);\n    if (d == 0)\n        return false;\n    if (d == 2 * Math.PI)\n        return true;\n    const norm_mid = angle_norm(mid);\n    const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\n    return (direction == 0 /* clock */) ? cond : !cond;\n}\nexport function random() {\n    return Math.random();\n}\nexport function randomIn(min, max) {\n    if (max == null) {\n        max = min;\n        min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\nexport function atan2(start, end) {\n    /*\n     * Calculate the angle between a line containing start and end points (composed\n     * of [x, y] arrays) and the positive x-axis.\n     */\n    return Math.atan2(end[1] - start[1], end[0] - start[0]);\n}\n// http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\nexport function rnorm(mu, sigma) {\n    // Generate a random normal with a mean of 0 and a sigma of 1\n    let r1;\n    let r2;\n    while (true) {\n        r1 = random();\n        r2 = random();\n        r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\n        if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)\n            break;\n    }\n    let rn = r2 / r1;\n    // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n    rn = mu + sigma * rn;\n    return rn;\n}\nexport function clamp(val, min, max) {\n    if (val > max)\n        return max;\n    if (val < min)\n        return min;\n    return val;\n}\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}