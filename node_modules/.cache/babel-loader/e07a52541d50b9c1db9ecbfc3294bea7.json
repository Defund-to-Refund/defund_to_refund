{"ast":null,"code":"import { Transform } from \"./transform\";\nimport * as p from \"../../core/properties\";\nimport { includes } from \"../../core/util/array\";\nimport { isString, isArray } from \"../../core/util/types\";\nexport class Interpolator extends Transform {\n  constructor(attrs) {\n    super(attrs);\n    this._sorted_dirty = true;\n  }\n\n  static init_Interpolator() {\n    this.define({\n      x: [p.Any],\n      y: [p.Any],\n      data: [p.Any],\n      clip: [p.Boolean, true]\n    });\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.change, () => this._sorted_dirty = true);\n  }\n\n  v_compute(xs) {\n    const result = new Float64Array(xs.length);\n\n    for (let i = 0; i < xs.length; i++) {\n      const x = xs[i];\n      result[i] = this.compute(x);\n    }\n\n    return result;\n  }\n\n  sort(descending = false) {\n    if (!this._sorted_dirty) return;\n    let tsx;\n    let tsy;\n\n    if (isString(this.x) && isString(this.y) && this.data != null) {\n      const column_names = this.data.columns();\n      if (!includes(column_names, this.x)) throw new Error(\"The x parameter does not correspond to a valid column name defined in the data parameter\");\n      if (!includes(column_names, this.y)) throw new Error(\"The y parameter does not correspond to a valid column name defined in the data parameter\");\n      tsx = this.data.get_column(this.x);\n      tsy = this.data.get_column(this.y);\n    } else if (isArray(this.x) && isArray(this.y)) {\n      tsx = this.x;\n      tsy = this.y;\n    } else {\n      throw new Error(\"parameters 'x' and 'y' must be both either string fields or arrays\");\n    }\n\n    if (tsx.length !== tsy.length) throw new Error(\"The length for x and y do not match\");\n    if (tsx.length < 2) throw new Error(\"x and y must have at least two elements to support interpolation\"); // The following sorting code is referenced from:\n    // http://stackoverflow.com/questions/11499268/sort-two-arrays-the-same-way\n\n    const list = [];\n\n    for (const j in tsx) {\n      list.push({\n        x: tsx[j],\n        y: tsy[j]\n      });\n    }\n\n    if (descending) list.sort((a, b) => a.x > b.x ? -1 : a.x == b.x ? 0 : 1);else list.sort((a, b) => a.x < b.x ? -1 : a.x == b.x ? 0 : 1);\n    this._x_sorted = [];\n    this._y_sorted = [];\n\n    for (const {\n      x,\n      y\n    } of list) {\n      this._x_sorted.push(x);\n\n      this._y_sorted.push(y);\n    }\n\n    this._sorted_dirty = false;\n  }\n\n}\nInterpolator.__name__ = \"Interpolator\";\nInterpolator.init_Interpolator();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/interpolator.js"],"names":["Transform","p","includes","isString","isArray","Interpolator","constructor","attrs","_sorted_dirty","init_Interpolator","define","x","Any","y","data","clip","Boolean","connect_signals","connect","change","v_compute","xs","result","Float64Array","length","i","compute","sort","descending","tsx","tsy","column_names","columns","Error","get_column","list","j","push","a","b","_x_sorted","_y_sorted","__name__"],"mappings":"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","sourcesContent":["import { Transform } from \"./transform\";\nimport * as p from \"../../core/properties\";\nimport { includes } from \"../../core/util/array\";\nimport { isString, isArray } from \"../../core/util/types\";\nexport class Interpolator extends Transform {\n    constructor(attrs) {\n        super(attrs);\n        this._sorted_dirty = true;\n    }\n    static init_Interpolator() {\n        this.define({\n            x: [p.Any],\n            y: [p.Any],\n            data: [p.Any],\n            clip: [p.Boolean, true],\n        });\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.change, () => this._sorted_dirty = true);\n    }\n    v_compute(xs) {\n        const result = new Float64Array(xs.length);\n        for (let i = 0; i < xs.length; i++) {\n            const x = xs[i];\n            result[i] = this.compute(x);\n        }\n        return result;\n    }\n    sort(descending = false) {\n        if (!this._sorted_dirty)\n            return;\n        let tsx;\n        let tsy;\n        if (isString(this.x) && isString(this.y) && this.data != null) {\n            const column_names = this.data.columns();\n            if (!includes(column_names, this.x))\n                throw new Error(\"The x parameter does not correspond to a valid column name defined in the data parameter\");\n            if (!includes(column_names, this.y))\n                throw new Error(\"The y parameter does not correspond to a valid column name defined in the data parameter\");\n            tsx = this.data.get_column(this.x);\n            tsy = this.data.get_column(this.y);\n        }\n        else if (isArray(this.x) && isArray(this.y)) {\n            tsx = this.x;\n            tsy = this.y;\n        }\n        else {\n            throw new Error(\"parameters 'x' and 'y' must be both either string fields or arrays\");\n        }\n        if (tsx.length !== tsy.length)\n            throw new Error(\"The length for x and y do not match\");\n        if (tsx.length < 2)\n            throw new Error(\"x and y must have at least two elements to support interpolation\");\n        // The following sorting code is referenced from:\n        // http://stackoverflow.com/questions/11499268/sort-two-arrays-the-same-way\n        const list = [];\n        for (const j in tsx) {\n            list.push({ x: tsx[j], y: tsy[j] });\n        }\n        if (descending)\n            list.sort((a, b) => a.x > b.x ? -1 : (a.x == b.x ? 0 : 1));\n        else\n            list.sort((a, b) => a.x < b.x ? -1 : (a.x == b.x ? 0 : 1));\n        this._x_sorted = [];\n        this._y_sorted = [];\n        for (const { x, y } of list) {\n            this._x_sorted.push(x);\n            this._y_sorted.push(y);\n        }\n        this._sorted_dirty = false;\n    }\n}\nInterpolator.__name__ = \"Interpolator\";\nInterpolator.init_Interpolator();\n//# sourceMappingURL=interpolator.js.map"]},"metadata":{},"sourceType":"module"}