{"ast":null,"code":"import * as Numbro from \"@bokeh/numbro\";\nimport { sprintf as sprintf_js } from \"sprintf-js\";\nimport tz from \"timezone\";\nimport { escape } from \"./string\";\nimport { isNumber, isString, isArray, isTypedArray } from \"./types\";\nexport const DEFAULT_FORMATTERS = {\n  numeral: (value, format, _special_vars) => Numbro.format(value, format),\n  datetime: (value, format, _special_vars) => tz(value, format),\n  printf: (value, format, _special_vars) => sprintf(format, value)\n};\nexport function sprintf(format, ...args) {\n  return sprintf_js(format, ...args);\n}\nexport function basic_formatter(value, _format, _special_vars) {\n  if (isNumber(value)) {\n    const format = (() => {\n      switch (false) {\n        case Math.floor(value) != value:\n          return \"%d\";\n\n        case !(Math.abs(value) > 0.1) || !(Math.abs(value) < 1000):\n          return \"%0.3f\";\n\n        default:\n          return \"%0.3e\";\n      }\n    })();\n\n    return sprintf(format, value);\n  } else return `${value}`; // get strings for categorical types\n\n}\nexport function get_formatter(raw_spec, format, formatters) {\n  // no format, use default built in formatter\n  if (format == null) return basic_formatter; // format spec in the formatters dict, use that\n\n  if (formatters != null && raw_spec in formatters) {\n    const formatter = formatters[raw_spec];\n\n    if (isString(formatter)) {\n      if (formatter in DEFAULT_FORMATTERS) return DEFAULT_FORMATTERS[formatter];else throw new Error(`Unknown tooltip field formatter type '${formatter}'`);\n    }\n\n    return function (value, format, special_vars) {\n      return formatter.format(value, format, special_vars);\n    };\n  } // otherwise use \"numeral\" as default\n\n\n  return DEFAULT_FORMATTERS.numeral;\n}\n\nfunction _get_special_value(name, special_vars) {\n  if (name in special_vars) return special_vars[name];else throw new Error(`Unknown special variable '\\$${name}'`);\n}\n\nfunction _get_column_value(name, data_source, i) {\n  const column = data_source.get_column(name); // missing column\n\n  if (column == null) return null; // typical (non-image) index\n\n  if (isNumber(i)) return column[i]; // image index\n\n  const data = column[i.index];\n\n  if (isTypedArray(data) || isArray(data)) {\n    // inspect array of arrays\n    if (isArray(data[0])) {\n      const row = data[i.dim2];\n      return row[i.dim1];\n    } else return data[i.flat_index]; // inspect flat array\n\n  } else return data; // inspect per-image scalar data\n\n}\n\nexport function get_value(raw_name, data_source, i, special_vars) {\n  if (raw_name[0] == \"$\") {\n    const name = raw_name.substring(1);\n    return _get_special_value(name, special_vars);\n  } else {\n    const name = raw_name.substring(1).replace(/[{}]/g, \"\");\n    return _get_column_value(name, data_source, i);\n  }\n}\nexport function replace_placeholders(str, data_source, i, formatters, special_vars = {}) {\n  // this handles the special case @$name, replacing it with an @var corresponding to special_vars.name\n  str = str.replace(/@\\$name/g, _match => `@{${special_vars.name}}`); //\n  // (?:\\$\\w+) - special vars: $x\n  // (?:@\\w+) - simple names: @foo\n  // (?:@{(?:[^{}]+)})) - full names: @{one two}\n  //\n  // (?:{([^{}]+)})? - (optional) format for all of the above: @foo{fmt}\n  //\n\n  str = str.replace(/((?:\\$\\w+)|(?:@\\w+)|(?:@{(?:[^{}]+)}))(?:{([^{}]+)})?/g, (_match, spec, format) => {\n    const value = get_value(spec, data_source, i, special_vars); // missing value, return ???\n\n    if (value == null) return `${escape(\"???\")}`; // 'safe' format, return the value as-is\n\n    if (format == 'safe') return `${value}`; // format and escape everything else\n\n    const formatter = get_formatter(spec, format, formatters);\n    return `${escape(formatter(value, format, special_vars))}`;\n  });\n  return str;\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/templating.js"],"names":["Numbro","sprintf","sprintf_js","tz","escape","isNumber","isString","isArray","isTypedArray","DEFAULT_FORMATTERS","numeral","value","format","_special_vars","datetime","printf","args","basic_formatter","_format","Math","floor","abs","get_formatter","raw_spec","formatters","formatter","Error","special_vars","_get_special_value","name","_get_column_value","data_source","i","column","get_column","data","index","row","dim2","dim1","flat_index","get_value","raw_name","substring","replace","replace_placeholders","str","_match","spec"],"mappings":"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","sourcesContent":["import * as Numbro from \"@bokeh/numbro\";\nimport { sprintf as sprintf_js } from \"sprintf-js\";\nimport tz from \"timezone\";\nimport { escape } from \"./string\";\nimport { isNumber, isString, isArray, isTypedArray } from \"./types\";\nexport const DEFAULT_FORMATTERS = {\n    numeral: (value, format, _special_vars) => Numbro.format(value, format),\n    datetime: (value, format, _special_vars) => tz(value, format),\n    printf: (value, format, _special_vars) => sprintf(format, value),\n};\nexport function sprintf(format, ...args) {\n    return sprintf_js(format, ...args);\n}\nexport function basic_formatter(value, _format, _special_vars) {\n    if (isNumber(value)) {\n        const format = (() => {\n            switch (false) {\n                case Math.floor(value) != value:\n                    return \"%d\";\n                case !(Math.abs(value) > 0.1) || !(Math.abs(value) < 1000):\n                    return \"%0.3f\";\n                default:\n                    return \"%0.3e\";\n            }\n        })();\n        return sprintf(format, value);\n    }\n    else\n        return `${value}`; // get strings for categorical types\n}\nexport function get_formatter(raw_spec, format, formatters) {\n    // no format, use default built in formatter\n    if (format == null)\n        return basic_formatter;\n    // format spec in the formatters dict, use that\n    if (formatters != null && raw_spec in formatters) {\n        const formatter = formatters[raw_spec];\n        if (isString(formatter)) {\n            if (formatter in DEFAULT_FORMATTERS)\n                return DEFAULT_FORMATTERS[formatter];\n            else\n                throw new Error(`Unknown tooltip field formatter type '${formatter}'`);\n        }\n        return function (value, format, special_vars) {\n            return formatter.format(value, format, special_vars);\n        };\n    }\n    // otherwise use \"numeral\" as default\n    return DEFAULT_FORMATTERS.numeral;\n}\nfunction _get_special_value(name, special_vars) {\n    if (name in special_vars)\n        return special_vars[name];\n    else\n        throw new Error(`Unknown special variable '\\$${name}'`);\n}\nfunction _get_column_value(name, data_source, i) {\n    const column = data_source.get_column(name);\n    // missing column\n    if (column == null)\n        return null;\n    // typical (non-image) index\n    if (isNumber(i))\n        return column[i];\n    // image index\n    const data = column[i.index];\n    if (isTypedArray(data) || isArray(data)) {\n        // inspect array of arrays\n        if (isArray(data[0])) {\n            const row = data[i.dim2];\n            return row[i.dim1];\n        }\n        else\n            return data[i.flat_index]; // inspect flat array\n    }\n    else\n        return data; // inspect per-image scalar data\n}\nexport function get_value(raw_name, data_source, i, special_vars) {\n    if (raw_name[0] == \"$\") {\n        const name = raw_name.substring(1);\n        return _get_special_value(name, special_vars);\n    }\n    else {\n        const name = raw_name.substring(1).replace(/[{}]/g, \"\");\n        return _get_column_value(name, data_source, i);\n    }\n}\nexport function replace_placeholders(str, data_source, i, formatters, special_vars = {}) {\n    // this handles the special case @$name, replacing it with an @var corresponding to special_vars.name\n    str = str.replace(/@\\$name/g, (_match) => `@{${special_vars.name}}`);\n    //\n    // (?:\\$\\w+) - special vars: $x\n    // (?:@\\w+) - simple names: @foo\n    // (?:@{(?:[^{}]+)})) - full names: @{one two}\n    //\n    // (?:{([^{}]+)})? - (optional) format for all of the above: @foo{fmt}\n    //\n    str = str.replace(/((?:\\$\\w+)|(?:@\\w+)|(?:@{(?:[^{}]+)}))(?:{([^{}]+)})?/g, (_match, spec, format) => {\n        const value = get_value(spec, data_source, i, special_vars);\n        // missing value, return ???\n        if (value == null)\n            return `${escape(\"???\")}`;\n        // 'safe' format, return the value as-is\n        if (format == 'safe')\n            return `${value}`;\n        // format and escape everything else\n        const formatter = get_formatter(spec, format, formatters);\n        return `${escape(formatter(value, format, special_vars))}`;\n    });\n    return str;\n}\n//# sourceMappingURL=templating.js.map"]},"metadata":{},"sourceType":"module"}