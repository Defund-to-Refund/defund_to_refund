{"ast":null,"code":"import { Annotation, AnnotationView } from \"./annotation\";\nimport { BasicTicker } from \"../tickers/basic_ticker\";\nimport { BasicTickFormatter } from \"../formatters/basic_tick_formatter\";\nimport { LinearColorMapper } from \"../mappers/linear_color_mapper\";\nimport { LinearScale } from \"../scales/linear_scale\";\nimport { LogScale } from \"../scales/log_scale\";\nimport { Range1d } from \"../ranges/range1d\";\nimport * as p from \"../../core/properties\";\nimport * as text_util from \"../../core/util/text\";\nimport { min, max, range, reversed } from \"../../core/util/array\";\nimport { map } from \"../../core/util/arrayable\";\nimport { isEmpty } from \"../../core/util/object\";\nimport { isString, isArray } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nconst SHORT_DIM = 25;\nconst LONG_DIM_MIN_SCALAR = 0.3;\nconst LONG_DIM_MAX_SCALAR = 0.8;\nexport class ColorBarView extends AnnotationView {\n  initialize() {\n    super.initialize();\n\n    this._set_canvas_image();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.model.properties.visible.change, () => this.plot_view.request_render());\n    this.connect(this.model.ticker.change, () => this.plot_view.request_render());\n    this.connect(this.model.formatter.change, () => this.plot_view.request_render());\n\n    if (this.model.color_mapper != null) {\n      this.connect(this.model.color_mapper.change, () => {\n        this._set_canvas_image();\n\n        this.plot_view.request_render();\n      });\n    }\n  }\n\n  _get_size() {\n    if (this.model.color_mapper == null) return {\n      width: 0,\n      height: 0\n    };else {\n      const {\n        width,\n        height\n      } = this.compute_legend_dimensions();\n      return {\n        width,\n        height\n      };\n    }\n  }\n\n  _set_canvas_image() {\n    if (this.model.color_mapper == null) return;\n    let {\n      palette\n    } = this.model.color_mapper;\n    if (this.model.orientation == 'vertical') palette = reversed(palette);\n    let w, h;\n\n    switch (this.model.orientation) {\n      case \"vertical\":\n        {\n          [w, h] = [1, palette.length];\n          break;\n        }\n\n      case \"horizontal\":\n        {\n          [w, h] = [palette.length, 1];\n          break;\n        }\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n    const image_ctx = canvas.getContext('2d');\n    const image_data = image_ctx.getImageData(0, 0, w, h); // We always want to draw the entire palette linearly, so we create a new\n    // LinearColorMapper instance and map a monotonic range of values with\n    // length = palette.length to get each palette color in order.\n\n    const cmap = new LinearColorMapper({\n      palette\n    }).rgba_mapper;\n    const buf8 = cmap.v_compute(range(0, palette.length));\n    image_data.data.set(buf8);\n    image_ctx.putImageData(image_data, 0, 0);\n    this.image = canvas;\n  }\n\n  compute_legend_dimensions() {\n    const image_dimensions = this._computed_image_dimensions();\n\n    const [image_height, image_width] = [image_dimensions.height, image_dimensions.width];\n\n    const label_extent = this._get_label_extent();\n\n    const title_extent = this._title_extent();\n\n    const tick_extent = this._tick_extent();\n\n    const {\n      padding\n    } = this.model;\n    let legend_height, legend_width;\n\n    switch (this.model.orientation) {\n      case \"vertical\":\n        legend_height = image_height + title_extent + 2 * padding;\n        legend_width = image_width + tick_extent + label_extent + 2 * padding;\n        break;\n\n      case \"horizontal\":\n        legend_height = image_height + title_extent + tick_extent + label_extent + 2 * padding;\n        legend_width = image_width + 2 * padding;\n        break;\n    }\n\n    return {\n      width: legend_width,\n      height: legend_height\n    };\n  }\n\n  compute_legend_location() {\n    const legend_dimensions = this.compute_legend_dimensions();\n    const [legend_height, legend_width] = [legend_dimensions.height, legend_dimensions.width];\n    const legend_margin = this.model.margin;\n    const panel = this.panel != null ? this.panel : this.plot_view.frame;\n    const [hr, vr] = panel.bbox.ranges;\n    const {\n      location\n    } = this.model;\n    let sx, sy;\n\n    if (isString(location)) {\n      switch (location) {\n        case 'top_left':\n          sx = hr.start + legend_margin;\n          sy = vr.start + legend_margin;\n          break;\n\n        case 'top_center':\n          sx = (hr.end + hr.start) / 2 - legend_width / 2;\n          sy = vr.start + legend_margin;\n          break;\n\n        case 'top_right':\n          sx = hr.end - legend_margin - legend_width;\n          sy = vr.start + legend_margin;\n          break;\n\n        case 'bottom_right':\n          sx = hr.end - legend_margin - legend_width;\n          sy = vr.end - legend_margin - legend_height;\n          break;\n\n        case 'bottom_center':\n          sx = (hr.end + hr.start) / 2 - legend_width / 2;\n          sy = vr.end - legend_margin - legend_height;\n          break;\n\n        case 'bottom_left':\n          sx = hr.start + legend_margin;\n          sy = vr.end - legend_margin - legend_height;\n          break;\n\n        case 'center_left':\n          sx = hr.start + legend_margin;\n          sy = (vr.end + vr.start) / 2 - legend_height / 2;\n          break;\n\n        case 'center':\n          sx = (hr.end + hr.start) / 2 - legend_width / 2;\n          sy = (vr.end + vr.start) / 2 - legend_height / 2;\n          break;\n\n        case 'center_right':\n          sx = hr.end - legend_margin - legend_width;\n          sy = (vr.end + vr.start) / 2 - legend_height / 2;\n          break;\n      }\n    } else if (isArray(location) && location.length == 2) {\n      const [vx, vy] = location;\n      sx = panel.xview.compute(vx);\n      sy = panel.yview.compute(vy) - legend_height;\n    } else unreachable();\n\n    return {\n      sx,\n      sy\n    };\n  }\n\n  render() {\n    if (!this.model.visible || this.model.color_mapper == null) return;\n    const {\n      ctx\n    } = this.plot_view.canvas_view;\n    ctx.save();\n    const {\n      sx,\n      sy\n    } = this.compute_legend_location();\n    ctx.translate(sx, sy);\n\n    this._draw_bbox(ctx);\n\n    const image_offset = this._get_image_offset();\n\n    ctx.translate(image_offset.x, image_offset.y);\n\n    this._draw_image(ctx);\n\n    if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) {\n      const tick_info = this.tick_info();\n\n      this._draw_major_ticks(ctx, tick_info);\n\n      this._draw_minor_ticks(ctx, tick_info);\n\n      this._draw_major_labels(ctx, tick_info);\n    }\n\n    if (this.model.title) this._draw_title(ctx);\n    ctx.restore();\n  }\n\n  _draw_bbox(ctx) {\n    const bbox = this.compute_legend_dimensions();\n    ctx.save();\n\n    if (this.visuals.background_fill.doit) {\n      this.visuals.background_fill.set_value(ctx);\n      ctx.fillRect(0, 0, bbox.width, bbox.height);\n    }\n\n    if (this.visuals.border_line.doit) {\n      this.visuals.border_line.set_value(ctx);\n      ctx.strokeRect(0, 0, bbox.width, bbox.height);\n    }\n\n    ctx.restore();\n  }\n\n  _draw_image(ctx) {\n    const image = this._computed_image_dimensions();\n\n    ctx.save();\n    ctx.setImageSmoothingEnabled(false);\n    ctx.globalAlpha = this.model.scale_alpha;\n    ctx.drawImage(this.image, 0, 0, image.width, image.height);\n\n    if (this.visuals.bar_line.doit) {\n      this.visuals.bar_line.set_value(ctx);\n      ctx.strokeRect(0, 0, image.width, image.height);\n    }\n\n    ctx.restore();\n  }\n\n  _draw_major_ticks(ctx, tick_info) {\n    if (!this.visuals.major_tick_line.doit) return;\n\n    const [nx, ny] = this._normals();\n\n    const image = this._computed_image_dimensions();\n\n    const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n    const [sx, sy] = tick_info.coords.major;\n    const tin = this.model.major_tick_in;\n    const tout = this.model.major_tick_out;\n    ctx.save();\n    ctx.translate(x_offset, y_offset);\n    this.visuals.major_tick_line.set_value(ctx);\n\n    for (let i = 0, end = sx.length; i < end; i++) {\n      ctx.beginPath();\n      ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n      ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  _draw_minor_ticks(ctx, tick_info) {\n    if (!this.visuals.minor_tick_line.doit) return;\n\n    const [nx, ny] = this._normals();\n\n    const image = this._computed_image_dimensions();\n\n    const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n    const [sx, sy] = tick_info.coords.minor;\n    const tin = this.model.minor_tick_in;\n    const tout = this.model.minor_tick_out;\n    ctx.save();\n    ctx.translate(x_offset, y_offset);\n    this.visuals.minor_tick_line.set_value(ctx);\n\n    for (let i = 0, end = sx.length; i < end; i++) {\n      ctx.beginPath();\n      ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n      ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  _draw_major_labels(ctx, tick_info) {\n    if (!this.visuals.major_label_text.doit) return;\n\n    const [nx, ny] = this._normals();\n\n    const image = this._computed_image_dimensions();\n\n    const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n\n    const standoff = this.model.label_standoff + this._tick_extent();\n\n    const [x_standoff, y_standoff] = [standoff * nx, standoff * ny];\n    const [sx, sy] = tick_info.coords.major;\n    const formatted_labels = tick_info.labels.major;\n    this.visuals.major_label_text.set_value(ctx);\n    ctx.save();\n    ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\n\n    for (let i = 0, end = sx.length; i < end; i++) {\n      ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\n    }\n\n    ctx.restore();\n  }\n\n  _draw_title(ctx) {\n    if (!this.visuals.title_text.doit) return;\n    ctx.save();\n    this.visuals.title_text.set_value(ctx);\n    ctx.fillText(this.model.title, 0, -this.model.title_standoff);\n    ctx.restore();\n  }\n  /*protected*/\n\n\n  _get_label_extent() {\n    const major_labels = this.tick_info().labels.major;\n    let label_extent;\n\n    if (this.model.color_mapper.low != null && this.model.color_mapper.high != null && !isEmpty(major_labels)) {\n      const {\n        ctx\n      } = this.plot_view.canvas_view;\n      ctx.save();\n      this.visuals.major_label_text.set_value(ctx);\n\n      switch (this.model.orientation) {\n        case \"vertical\":\n          label_extent = max(major_labels.map(label => ctx.measureText(label.toString()).width));\n          break;\n\n        case \"horizontal\":\n          label_extent = text_util.measure_font(this.visuals.major_label_text.font_value()).height;\n          break;\n      }\n\n      label_extent += this.model.label_standoff;\n      ctx.restore();\n    } else label_extent = 0;\n\n    return label_extent;\n  }\n  /*protected*/\n\n\n  _get_image_offset() {\n    // Returns image offset relative to legend bounding box\n    const x = this.model.padding;\n\n    const y = this.model.padding + this._title_extent();\n\n    return {\n      x,\n      y\n    };\n  } // {{{ TODO: state\n\n\n  _normals() {\n    return this.model.orientation == 'vertical' ? [1, 0] : [0, 1];\n  }\n\n  _title_extent() {\n    const font_value = this.model.title_text_font + \" \" + this.model.title_text_font_size + \" \" + this.model.title_text_font_style;\n    const title_extent = this.model.title ? text_util.measure_font(font_value).height + this.model.title_standoff : 0;\n    return title_extent;\n  }\n\n  _tick_extent() {\n    if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) return max([this.model.major_tick_out, this.model.minor_tick_out]);else return 0;\n  }\n\n  _computed_image_dimensions() {\n    /*\n    Heuristics to determine ColorBar image dimensions if set to \"auto\"\n         Note: Returns the height/width values for the ColorBar's scale image, not\n    the dimensions of the entire ColorBar.\n         If the short dimension (the width of a vertical bar or height of a\n    horizontal bar) is set to \"auto\", the resulting dimension will be set to\n    25 px.\n         For a ColorBar in a side panel with the long dimension (the height of a\n    vertical bar or width of a horizontal bar) set to \"auto\", the\n    resulting dimension will be as long as the adjacent frame edge, so that the\n    bar \"fits\" to the plot.\n         For a ColorBar in the plot frame with the long dimension set to \"auto\", the\n    resulting dimension will be the greater of:\n      * The length of the color palette * 25px\n      * The parallel frame dimension * 0.30\n        (i.e the frame height for a vertical ColorBar)\n    But not greater than:\n      * The parallel frame dimension * 0.80\n    */\n    const frame_height = this.plot_view.frame._height.value;\n    const frame_width = this.plot_view.frame._width.value;\n\n    const title_extent = this._title_extent();\n\n    let height, width;\n\n    switch (this.model.orientation) {\n      case \"vertical\":\n        {\n          if (this.model.height == 'auto') {\n            if (this.panel != null) height = frame_height - 2 * this.model.padding - title_extent;else {\n              height = max([this.model.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\n              height = min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.model.padding - title_extent]);\n            }\n          } else height = this.model.height;\n\n          width = this.model.width == 'auto' ? SHORT_DIM : this.model.width;\n          break;\n        }\n\n      case \"horizontal\":\n        {\n          height = this.model.height == 'auto' ? SHORT_DIM : this.model.height;\n\n          if (this.model.width == 'auto') {\n            if (this.panel != null) width = frame_width - 2 * this.model.padding;else {\n              width = max([this.model.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\n              width = min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.model.padding]);\n            }\n          } else width = this.model.width;\n\n          break;\n        }\n    }\n\n    return {\n      width,\n      height\n    };\n  }\n  /*protected*/\n\n\n  _tick_coordinate_scale(scale_length) {\n    /*\n    Creates and returns a scale instance that maps the `color_mapper` range\n    (low to high) to a screen space range equal to the length of the ColorBar's\n    scale image. The scale is used to calculate the tick coordinates in screen\n    coordinates for plotting purposes.\n         Note: the type of color_mapper has to match the type of scale (i.e.\n    a LinearColorMapper will require a corresponding LinearScale instance).\n    */\n    const ranges = {\n      source_range: new Range1d({\n        start: this.model.color_mapper.low,\n        end: this.model.color_mapper.high\n      }),\n      target_range: new Range1d({\n        start: 0,\n        end: scale_length\n      })\n    };\n\n    switch (this.model.color_mapper.type) {\n      case \"LinearColorMapper\":\n        return new LinearScale(ranges);\n\n      case \"LogColorMapper\":\n        return new LogScale(ranges);\n\n      default:\n        unreachable();\n    }\n  }\n\n  _format_major_labels(initial_labels, major_ticks) {\n    // XXX: passing null as cross_loc probably means MercatorTickFormatters, etc\n    // will not function properly in conjunction with colorbars\n    const formatted_labels = this.model.formatter.doFormat(initial_labels, null);\n\n    for (let i = 0, end = major_ticks.length; i < end; i++) {\n      if (major_ticks[i] in this.model.major_label_overrides) formatted_labels[i] = this.model.major_label_overrides[major_ticks[i]];\n    }\n\n    return formatted_labels;\n  }\n\n  tick_info() {\n    const image_dimensions = this._computed_image_dimensions();\n\n    let scale_length;\n\n    switch (this.model.orientation) {\n      case \"vertical\":\n        {\n          scale_length = image_dimensions.height;\n          break;\n        }\n\n      case \"horizontal\":\n        {\n          scale_length = image_dimensions.width;\n          break;\n        }\n    }\n\n    const scale = this._tick_coordinate_scale(scale_length);\n\n    const [i, j] = this._normals();\n\n    const [start, end] = [this.model.color_mapper.low, this.model.color_mapper.high]; // XXX: passing null as cross_loc probably means MercatorTickers, etc\n    // will not function properly in conjunction with colorbars\n\n    const ticks = this.model.ticker.get_ticks(start, end, null, null, this.model.ticker.desired_num_ticks);\n    const majors = ticks.major;\n    const minors = ticks.minor;\n    const major_coords = [[], []];\n    const minor_coords = [[], []];\n\n    for (let ii = 0, _end = majors.length; ii < _end; ii++) {\n      if (majors[ii] < start || majors[ii] > end) continue;\n      major_coords[i].push(majors[ii]);\n      major_coords[j].push(0);\n    }\n\n    for (let ii = 0, _end = minors.length; ii < _end; ii++) {\n      if (minors[ii] < start || minors[ii] > end) continue;\n      minor_coords[i].push(minors[ii]);\n      minor_coords[j].push(0);\n    }\n\n    const labels = {\n      major: this._format_major_labels(major_coords[i], majors)\n    };\n    const coords = {\n      major: [[], []],\n      minor: [[], []]\n    };\n    coords.major[i] = scale.v_compute(major_coords[i]);\n    coords.minor[i] = scale.v_compute(minor_coords[i]);\n    coords.major[j] = major_coords[j];\n    coords.minor[j] = minor_coords[j]; // Because we want the scale to be reversed\n\n    if (this.model.orientation == 'vertical') {\n      coords.major[i] = map(coords.major[i], coord => scale_length - coord);\n      coords.minor[i] = map(coords.minor[i], coord => scale_length - coord);\n    }\n\n    return {\n      coords,\n      labels\n    };\n  }\n\n}\nColorBarView.__name__ = \"ColorBarView\";\nexport class ColorBar extends Annotation {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_ColorBar() {\n    this.prototype.default_view = ColorBarView;\n    this.mixins(['text:major_label_', 'text:title_', 'line:major_tick_', 'line:minor_tick_', 'line:border_', 'line:bar_', 'fill:background_']);\n    this.define({\n      location: [p.Any, 'top_right'],\n      orientation: [p.Orientation, 'vertical'],\n      title: [p.String],\n      title_standoff: [p.Number, 2],\n      width: [p.Any, 'auto'],\n      height: [p.Any, 'auto'],\n      scale_alpha: [p.Number, 1.0],\n      ticker: [p.Instance, () => new BasicTicker()],\n      formatter: [p.Instance, () => new BasicTickFormatter()],\n      major_label_overrides: [p.Any, {}],\n      color_mapper: [p.Instance],\n      label_standoff: [p.Number, 5],\n      margin: [p.Number, 30],\n      padding: [p.Number, 10],\n      major_tick_in: [p.Number, 5],\n      major_tick_out: [p.Number, 0],\n      minor_tick_in: [p.Number, 0],\n      minor_tick_out: [p.Number, 0]\n    });\n    this.override({\n      background_fill_color: \"#ffffff\",\n      background_fill_alpha: 0.95,\n      bar_line_color: null,\n      border_line_color: null,\n      major_label_text_align: \"center\",\n      major_label_text_baseline: \"middle\",\n      major_label_text_font_size: \"11px\",\n      major_tick_line_color: \"#ffffff\",\n      minor_tick_line_color: null,\n      title_text_font_size: \"13px\",\n      title_text_font_style: \"italic\"\n    });\n  }\n\n}\nColorBar.__name__ = \"ColorBar\";\nColorBar.init_ColorBar();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/color_bar.js"],"names":["Annotation","AnnotationView","BasicTicker","BasicTickFormatter","LinearColorMapper","LinearScale","LogScale","Range1d","p","text_util","min","max","range","reversed","map","isEmpty","isString","isArray","unreachable","SHORT_DIM","LONG_DIM_MIN_SCALAR","LONG_DIM_MAX_SCALAR","ColorBarView","initialize","_set_canvas_image","connect_signals","connect","model","properties","visible","change","plot_view","request_render","ticker","formatter","color_mapper","_get_size","width","height","compute_legend_dimensions","palette","orientation","w","h","length","canvas","document","createElement","image_ctx","getContext","image_data","getImageData","cmap","rgba_mapper","buf8","v_compute","data","set","putImageData","image","image_dimensions","_computed_image_dimensions","image_height","image_width","label_extent","_get_label_extent","title_extent","_title_extent","tick_extent","_tick_extent","padding","legend_height","legend_width","compute_legend_location","legend_dimensions","legend_margin","margin","panel","frame","hr","vr","bbox","ranges","location","sx","sy","start","end","vx","vy","xview","compute","yview","render","ctx","canvas_view","save","translate","_draw_bbox","image_offset","_get_image_offset","x","y","_draw_image","low","high","tick_info","_draw_major_ticks","_draw_minor_ticks","_draw_major_labels","title","_draw_title","restore","visuals","background_fill","doit","set_value","fillRect","border_line","strokeRect","setImageSmoothingEnabled","globalAlpha","scale_alpha","drawImage","bar_line","major_tick_line","nx","ny","_normals","x_offset","y_offset","coords","major","tin","major_tick_in","tout","major_tick_out","i","beginPath","moveTo","Math","round","lineTo","stroke","minor_tick_line","minor","minor_tick_in","minor_tick_out","major_label_text","standoff","label_standoff","x_standoff","y_standoff","formatted_labels","labels","fillText","title_text","title_standoff","major_labels","label","measureText","toString","measure_font","font_value","title_text_font","title_text_font_size","title_text_font_style","frame_height","_height","value","frame_width","_width","_tick_coordinate_scale","scale_length","source_range","target_range","type","_format_major_labels","initial_labels","major_ticks","doFormat","major_label_overrides","scale","j","ticks","get_ticks","desired_num_ticks","majors","minors","major_coords","minor_coords","ii","_end","push","coord","__name__","ColorBar","constructor","attrs","init_ColorBar","prototype","default_view","mixins","define","Any","Orientation","String","Number","Instance","override","background_fill_color","background_fill_alpha","bar_line_color","border_line_color","major_label_text_align","major_label_text_baseline","major_label_text_font_size","major_tick_line_color","minor_tick_line_color"],"mappings":"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","sourcesContent":["import { Annotation, AnnotationView } from \"./annotation\";\nimport { BasicTicker } from \"../tickers/basic_ticker\";\nimport { BasicTickFormatter } from \"../formatters/basic_tick_formatter\";\nimport { LinearColorMapper } from \"../mappers/linear_color_mapper\";\nimport { LinearScale } from \"../scales/linear_scale\";\nimport { LogScale } from \"../scales/log_scale\";\nimport { Range1d } from \"../ranges/range1d\";\nimport * as p from \"../../core/properties\";\nimport * as text_util from \"../../core/util/text\";\nimport { min, max, range, reversed } from \"../../core/util/array\";\nimport { map } from \"../../core/util/arrayable\";\nimport { isEmpty } from \"../../core/util/object\";\nimport { isString, isArray } from \"../../core/util/types\";\nimport { unreachable } from \"../../core/util/assert\";\nconst SHORT_DIM = 25;\nconst LONG_DIM_MIN_SCALAR = 0.3;\nconst LONG_DIM_MAX_SCALAR = 0.8;\nexport class ColorBarView extends AnnotationView {\n    initialize() {\n        super.initialize();\n        this._set_canvas_image();\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.properties.visible.change, () => this.plot_view.request_render());\n        this.connect(this.model.ticker.change, () => this.plot_view.request_render());\n        this.connect(this.model.formatter.change, () => this.plot_view.request_render());\n        if (this.model.color_mapper != null) {\n            this.connect(this.model.color_mapper.change, () => {\n                this._set_canvas_image();\n                this.plot_view.request_render();\n            });\n        }\n    }\n    _get_size() {\n        if (this.model.color_mapper == null)\n            return { width: 0, height: 0 };\n        else {\n            const { width, height } = this.compute_legend_dimensions();\n            return { width, height };\n        }\n    }\n    _set_canvas_image() {\n        if (this.model.color_mapper == null)\n            return;\n        let { palette } = this.model.color_mapper;\n        if (this.model.orientation == 'vertical')\n            palette = reversed(palette);\n        let w, h;\n        switch (this.model.orientation) {\n            case \"vertical\": {\n                [w, h] = [1, palette.length];\n                break;\n            }\n            case \"horizontal\": {\n                [w, h] = [palette.length, 1];\n                break;\n            }\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = w;\n        canvas.height = h;\n        const image_ctx = canvas.getContext('2d');\n        const image_data = image_ctx.getImageData(0, 0, w, h);\n        // We always want to draw the entire palette linearly, so we create a new\n        // LinearColorMapper instance and map a monotonic range of values with\n        // length = palette.length to get each palette color in order.\n        const cmap = new LinearColorMapper({ palette }).rgba_mapper;\n        const buf8 = cmap.v_compute(range(0, palette.length));\n        image_data.data.set(buf8);\n        image_ctx.putImageData(image_data, 0, 0);\n        this.image = canvas;\n    }\n    compute_legend_dimensions() {\n        const image_dimensions = this._computed_image_dimensions();\n        const [image_height, image_width] = [image_dimensions.height, image_dimensions.width];\n        const label_extent = this._get_label_extent();\n        const title_extent = this._title_extent();\n        const tick_extent = this._tick_extent();\n        const { padding } = this.model;\n        let legend_height, legend_width;\n        switch (this.model.orientation) {\n            case \"vertical\":\n                legend_height = image_height + title_extent + 2 * padding;\n                legend_width = image_width + tick_extent + label_extent + 2 * padding;\n                break;\n            case \"horizontal\":\n                legend_height = image_height + title_extent + tick_extent + label_extent + 2 * padding;\n                legend_width = image_width + 2 * padding;\n                break;\n        }\n        return { width: legend_width, height: legend_height };\n    }\n    compute_legend_location() {\n        const legend_dimensions = this.compute_legend_dimensions();\n        const [legend_height, legend_width] = [legend_dimensions.height, legend_dimensions.width];\n        const legend_margin = this.model.margin;\n        const panel = this.panel != null ? this.panel : this.plot_view.frame;\n        const [hr, vr] = panel.bbox.ranges;\n        const { location } = this.model;\n        let sx, sy;\n        if (isString(location)) {\n            switch (location) {\n                case 'top_left':\n                    sx = hr.start + legend_margin;\n                    sy = vr.start + legend_margin;\n                    break;\n                case 'top_center':\n                    sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                    sy = vr.start + legend_margin;\n                    break;\n                case 'top_right':\n                    sx = hr.end - legend_margin - legend_width;\n                    sy = vr.start + legend_margin;\n                    break;\n                case 'bottom_right':\n                    sx = hr.end - legend_margin - legend_width;\n                    sy = vr.end - legend_margin - legend_height;\n                    break;\n                case 'bottom_center':\n                    sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                    sy = vr.end - legend_margin - legend_height;\n                    break;\n                case 'bottom_left':\n                    sx = hr.start + legend_margin;\n                    sy = vr.end - legend_margin - legend_height;\n                    break;\n                case 'center_left':\n                    sx = hr.start + legend_margin;\n                    sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                    break;\n                case 'center':\n                    sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                    sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                    break;\n                case 'center_right':\n                    sx = hr.end - legend_margin - legend_width;\n                    sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                    break;\n            }\n        }\n        else if (isArray(location) && location.length == 2) {\n            const [vx, vy] = location;\n            sx = panel.xview.compute(vx);\n            sy = panel.yview.compute(vy) - legend_height;\n        }\n        else\n            unreachable();\n        return { sx, sy };\n    }\n    render() {\n        if (!this.model.visible || this.model.color_mapper == null)\n            return;\n        const { ctx } = this.plot_view.canvas_view;\n        ctx.save();\n        const { sx, sy } = this.compute_legend_location();\n        ctx.translate(sx, sy);\n        this._draw_bbox(ctx);\n        const image_offset = this._get_image_offset();\n        ctx.translate(image_offset.x, image_offset.y);\n        this._draw_image(ctx);\n        if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) {\n            const tick_info = this.tick_info();\n            this._draw_major_ticks(ctx, tick_info);\n            this._draw_minor_ticks(ctx, tick_info);\n            this._draw_major_labels(ctx, tick_info);\n        }\n        if (this.model.title)\n            this._draw_title(ctx);\n        ctx.restore();\n    }\n    _draw_bbox(ctx) {\n        const bbox = this.compute_legend_dimensions();\n        ctx.save();\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fillRect(0, 0, bbox.width, bbox.height);\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            ctx.strokeRect(0, 0, bbox.width, bbox.height);\n        }\n        ctx.restore();\n    }\n    _draw_image(ctx) {\n        const image = this._computed_image_dimensions();\n        ctx.save();\n        ctx.setImageSmoothingEnabled(false);\n        ctx.globalAlpha = this.model.scale_alpha;\n        ctx.drawImage(this.image, 0, 0, image.width, image.height);\n        if (this.visuals.bar_line.doit) {\n            this.visuals.bar_line.set_value(ctx);\n            ctx.strokeRect(0, 0, image.width, image.height);\n        }\n        ctx.restore();\n    }\n    _draw_major_ticks(ctx, tick_info) {\n        if (!this.visuals.major_tick_line.doit)\n            return;\n        const [nx, ny] = this._normals();\n        const image = this._computed_image_dimensions();\n        const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n        const [sx, sy] = tick_info.coords.major;\n        const tin = this.model.major_tick_in;\n        const tout = this.model.major_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.major_tick_line.set_value(ctx);\n        for (let i = 0, end = sx.length; i < end; i++) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    _draw_minor_ticks(ctx, tick_info) {\n        if (!this.visuals.minor_tick_line.doit)\n            return;\n        const [nx, ny] = this._normals();\n        const image = this._computed_image_dimensions();\n        const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n        const [sx, sy] = tick_info.coords.minor;\n        const tin = this.model.minor_tick_in;\n        const tout = this.model.minor_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.minor_tick_line.set_value(ctx);\n        for (let i = 0, end = sx.length; i < end; i++) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    _draw_major_labels(ctx, tick_info) {\n        if (!this.visuals.major_label_text.doit)\n            return;\n        const [nx, ny] = this._normals();\n        const image = this._computed_image_dimensions();\n        const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n        const standoff = (this.model.label_standoff + this._tick_extent());\n        const [x_standoff, y_standoff] = [standoff * nx, standoff * ny];\n        const [sx, sy] = tick_info.coords.major;\n        const formatted_labels = tick_info.labels.major;\n        this.visuals.major_label_text.set_value(ctx);\n        ctx.save();\n        ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\n        for (let i = 0, end = sx.length; i < end; i++) {\n            ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\n        }\n        ctx.restore();\n    }\n    _draw_title(ctx) {\n        if (!this.visuals.title_text.doit)\n            return;\n        ctx.save();\n        this.visuals.title_text.set_value(ctx);\n        ctx.fillText(this.model.title, 0, -this.model.title_standoff);\n        ctx.restore();\n    }\n    /*protected*/ _get_label_extent() {\n        const major_labels = this.tick_info().labels.major;\n        let label_extent;\n        if (this.model.color_mapper.low != null && this.model.color_mapper.high != null && !isEmpty(major_labels)) {\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            this.visuals.major_label_text.set_value(ctx);\n            switch (this.model.orientation) {\n                case \"vertical\":\n                    label_extent = max((major_labels.map((label) => ctx.measureText(label.toString()).width)));\n                    break;\n                case \"horizontal\":\n                    label_extent = text_util.measure_font(this.visuals.major_label_text.font_value()).height;\n                    break;\n            }\n            label_extent += this.model.label_standoff;\n            ctx.restore();\n        }\n        else\n            label_extent = 0;\n        return label_extent;\n    }\n    /*protected*/ _get_image_offset() {\n        // Returns image offset relative to legend bounding box\n        const x = this.model.padding;\n        const y = this.model.padding + this._title_extent();\n        return { x, y };\n    }\n    // {{{ TODO: state\n    _normals() {\n        return this.model.orientation == 'vertical' ? [1, 0] : [0, 1];\n    }\n    _title_extent() {\n        const font_value = this.model.title_text_font + \" \" + this.model.title_text_font_size + \" \" + this.model.title_text_font_style;\n        const title_extent = this.model.title ? text_util.measure_font(font_value).height + this.model.title_standoff : 0;\n        return title_extent;\n    }\n    _tick_extent() {\n        if (this.model.color_mapper.low != null && this.model.color_mapper.high != null)\n            return max([this.model.major_tick_out, this.model.minor_tick_out]);\n        else\n            return 0;\n    }\n    _computed_image_dimensions() {\n        /*\n        Heuristics to determine ColorBar image dimensions if set to \"auto\"\n    \n        Note: Returns the height/width values for the ColorBar's scale image, not\n        the dimensions of the entire ColorBar.\n    \n        If the short dimension (the width of a vertical bar or height of a\n        horizontal bar) is set to \"auto\", the resulting dimension will be set to\n        25 px.\n    \n        For a ColorBar in a side panel with the long dimension (the height of a\n        vertical bar or width of a horizontal bar) set to \"auto\", the\n        resulting dimension will be as long as the adjacent frame edge, so that the\n        bar \"fits\" to the plot.\n    \n        For a ColorBar in the plot frame with the long dimension set to \"auto\", the\n        resulting dimension will be the greater of:\n          * The length of the color palette * 25px\n          * The parallel frame dimension * 0.30\n            (i.e the frame height for a vertical ColorBar)\n        But not greater than:\n          * The parallel frame dimension * 0.80\n        */\n        const frame_height = this.plot_view.frame._height.value;\n        const frame_width = this.plot_view.frame._width.value;\n        const title_extent = this._title_extent();\n        let height, width;\n        switch (this.model.orientation) {\n            case \"vertical\": {\n                if (this.model.height == 'auto') {\n                    if (this.panel != null)\n                        height = frame_height - 2 * this.model.padding - title_extent;\n                    else {\n                        height = max([this.model.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\n                        height = min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.model.padding - title_extent]);\n                    }\n                }\n                else\n                    height = this.model.height;\n                width = this.model.width == 'auto' ? SHORT_DIM : this.model.width;\n                break;\n            }\n            case \"horizontal\": {\n                height = this.model.height == 'auto' ? SHORT_DIM : this.model.height;\n                if (this.model.width == 'auto') {\n                    if (this.panel != null)\n                        width = frame_width - 2 * this.model.padding;\n                    else {\n                        width = max([this.model.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\n                        width = min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.model.padding]);\n                    }\n                }\n                else\n                    width = this.model.width;\n                break;\n            }\n        }\n        return { width, height };\n    }\n    /*protected*/ _tick_coordinate_scale(scale_length) {\n        /*\n        Creates and returns a scale instance that maps the `color_mapper` range\n        (low to high) to a screen space range equal to the length of the ColorBar's\n        scale image. The scale is used to calculate the tick coordinates in screen\n        coordinates for plotting purposes.\n    \n        Note: the type of color_mapper has to match the type of scale (i.e.\n        a LinearColorMapper will require a corresponding LinearScale instance).\n        */\n        const ranges = {\n            source_range: new Range1d({\n                start: this.model.color_mapper.low,\n                end: this.model.color_mapper.high,\n            }),\n            target_range: new Range1d({\n                start: 0,\n                end: scale_length,\n            }),\n        };\n        switch (this.model.color_mapper.type) {\n            case \"LinearColorMapper\": return new LinearScale(ranges);\n            case \"LogColorMapper\": return new LogScale(ranges);\n            default:\n                unreachable();\n        }\n    }\n    _format_major_labels(initial_labels, major_ticks) {\n        // XXX: passing null as cross_loc probably means MercatorTickFormatters, etc\n        // will not function properly in conjunction with colorbars\n        const formatted_labels = this.model.formatter.doFormat(initial_labels, null);\n        for (let i = 0, end = major_ticks.length; i < end; i++) {\n            if (major_ticks[i] in this.model.major_label_overrides)\n                formatted_labels[i] = this.model.major_label_overrides[major_ticks[i]];\n        }\n        return formatted_labels;\n    }\n    tick_info() {\n        const image_dimensions = this._computed_image_dimensions();\n        let scale_length;\n        switch (this.model.orientation) {\n            case \"vertical\": {\n                scale_length = image_dimensions.height;\n                break;\n            }\n            case \"horizontal\": {\n                scale_length = image_dimensions.width;\n                break;\n            }\n        }\n        const scale = this._tick_coordinate_scale(scale_length);\n        const [i, j] = this._normals();\n        const [start, end] = [this.model.color_mapper.low, this.model.color_mapper.high];\n        // XXX: passing null as cross_loc probably means MercatorTickers, etc\n        // will not function properly in conjunction with colorbars\n        const ticks = this.model.ticker.get_ticks(start, end, null, null, this.model.ticker.desired_num_ticks);\n        const majors = ticks.major;\n        const minors = ticks.minor;\n        const major_coords = [[], []];\n        const minor_coords = [[], []];\n        for (let ii = 0, _end = majors.length; ii < _end; ii++) {\n            if (majors[ii] < start || majors[ii] > end)\n                continue;\n            major_coords[i].push(majors[ii]);\n            major_coords[j].push(0);\n        }\n        for (let ii = 0, _end = minors.length; ii < _end; ii++) {\n            if (minors[ii] < start || minors[ii] > end)\n                continue;\n            minor_coords[i].push(minors[ii]);\n            minor_coords[j].push(0);\n        }\n        const labels = { major: this._format_major_labels(major_coords[i], majors) };\n        const coords = {\n            major: [[], []],\n            minor: [[], []],\n        };\n        coords.major[i] = scale.v_compute(major_coords[i]);\n        coords.minor[i] = scale.v_compute(minor_coords[i]);\n        coords.major[j] = major_coords[j];\n        coords.minor[j] = minor_coords[j];\n        // Because we want the scale to be reversed\n        if (this.model.orientation == 'vertical') {\n            coords.major[i] = map(coords.major[i], (coord) => scale_length - coord);\n            coords.minor[i] = map(coords.minor[i], (coord) => scale_length - coord);\n        }\n        return { coords, labels };\n    }\n}\nColorBarView.__name__ = \"ColorBarView\";\nexport class ColorBar extends Annotation {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ColorBar() {\n        this.prototype.default_view = ColorBarView;\n        this.mixins([\n            'text:major_label_',\n            'text:title_',\n            'line:major_tick_',\n            'line:minor_tick_',\n            'line:border_',\n            'line:bar_',\n            'fill:background_',\n        ]);\n        this.define({\n            location: [p.Any, 'top_right'],\n            orientation: [p.Orientation, 'vertical'],\n            title: [p.String],\n            title_standoff: [p.Number, 2],\n            width: [p.Any, 'auto'],\n            height: [p.Any, 'auto'],\n            scale_alpha: [p.Number, 1.0],\n            ticker: [p.Instance, () => new BasicTicker()],\n            formatter: [p.Instance, () => new BasicTickFormatter()],\n            major_label_overrides: [p.Any, {}],\n            color_mapper: [p.Instance],\n            label_standoff: [p.Number, 5],\n            margin: [p.Number, 30],\n            padding: [p.Number, 10],\n            major_tick_in: [p.Number, 5],\n            major_tick_out: [p.Number, 0],\n            minor_tick_in: [p.Number, 0],\n            minor_tick_out: [p.Number, 0],\n        });\n        this.override({\n            background_fill_color: \"#ffffff\",\n            background_fill_alpha: 0.95,\n            bar_line_color: null,\n            border_line_color: null,\n            major_label_text_align: \"center\",\n            major_label_text_baseline: \"middle\",\n            major_label_text_font_size: \"11px\",\n            major_tick_line_color: \"#ffffff\",\n            minor_tick_line_color: null,\n            title_text_font_size: \"13px\",\n            title_text_font_style: \"italic\",\n        });\n    }\n}\nColorBar.__name__ = \"ColorBar\";\nColorBar.init_ColorBar();\n//# sourceMappingURL=color_bar.js.map"]},"metadata":{},"sourceType":"module"}