{"ast":null,"code":"import { Model } from \"../../model\";\nimport * as p from \"../../core/properties\";\nimport { union, intersection } from \"../../core/util/array\";\nimport { merge } from \"../../core/util/object\";\nexport class Selection extends Model {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Selection() {\n    this.define({\n      indices: [p.Array, []],\n      line_indices: [p.Array, []],\n      multiline_indices: [p.Any, {}]\n    });\n    this.internal({\n      final: [p.Boolean],\n      selected_glyphs: [p.Array, []],\n      get_view: [p.Any],\n      image_indices: [p.Array, []]\n    });\n  }\n\n  initialize() {\n    super.initialize();\n\n    this.get_view = () => null;\n  }\n\n  get selected_glyph() {\n    return this.selected_glyphs.length > 0 ? this.selected_glyphs[0] : null;\n  }\n\n  add_to_selected_glyphs(glyph) {\n    this.selected_glyphs.push(glyph);\n  }\n\n  update(selection, final, append) {\n    this.final = final;\n    if (append) this.update_through_union(selection);else {\n      this.indices = selection.indices;\n      this.line_indices = selection.line_indices;\n      this.selected_glyphs = selection.selected_glyphs;\n      this.get_view = selection.get_view;\n      this.multiline_indices = selection.multiline_indices;\n      this.image_indices = selection.image_indices;\n    }\n  }\n\n  clear() {\n    this.final = true;\n    this.indices = [];\n    this.line_indices = [];\n    this.multiline_indices = {};\n\n    this.get_view = () => null;\n\n    this.selected_glyphs = [];\n  }\n\n  is_empty() {\n    return this.indices.length == 0 && this.line_indices.length == 0 && this.image_indices.length == 0;\n  }\n\n  update_through_union(other) {\n    this.indices = union(other.indices, this.indices);\n    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);\n    this.line_indices = union(other.line_indices, this.line_indices);\n    if (!this.get_view()) this.get_view = other.get_view;\n    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);\n  }\n\n  update_through_intersection(other) {\n    this.indices = intersection(other.indices, this.indices); // TODO: think through and fix any logic below\n\n    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);\n    this.line_indices = union(other.line_indices, this.line_indices);\n    if (!this.get_view()) this.get_view = other.get_view;\n    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);\n  }\n\n}\nSelection.__name__ = \"Selection\";\nSelection.init_Selection();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/selections/selection.js"],"names":["Model","p","union","intersection","merge","Selection","constructor","attrs","init_Selection","define","indices","Array","line_indices","multiline_indices","Any","internal","final","Boolean","selected_glyphs","get_view","image_indices","initialize","selected_glyph","length","add_to_selected_glyphs","glyph","push","update","selection","append","update_through_union","clear","is_empty","other","update_through_intersection","__name__"],"mappings":"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","sourcesContent":["import { Model } from \"../../model\";\nimport * as p from \"../../core/properties\";\nimport { union, intersection } from \"../../core/util/array\";\nimport { merge } from \"../../core/util/object\";\nexport class Selection extends Model {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Selection() {\n        this.define({\n            indices: [p.Array, []],\n            line_indices: [p.Array, []],\n            multiline_indices: [p.Any, {}],\n        });\n        this.internal({\n            final: [p.Boolean],\n            selected_glyphs: [p.Array, []],\n            get_view: [p.Any],\n            image_indices: [p.Array, []],\n        });\n    }\n    initialize() {\n        super.initialize();\n        this.get_view = () => null;\n    }\n    get selected_glyph() {\n        return this.selected_glyphs.length > 0 ? this.selected_glyphs[0] : null;\n    }\n    add_to_selected_glyphs(glyph) {\n        this.selected_glyphs.push(glyph);\n    }\n    update(selection, final, append) {\n        this.final = final;\n        if (append)\n            this.update_through_union(selection);\n        else {\n            this.indices = selection.indices;\n            this.line_indices = selection.line_indices;\n            this.selected_glyphs = selection.selected_glyphs;\n            this.get_view = selection.get_view;\n            this.multiline_indices = selection.multiline_indices;\n            this.image_indices = selection.image_indices;\n        }\n    }\n    clear() {\n        this.final = true;\n        this.indices = [];\n        this.line_indices = [];\n        this.multiline_indices = {};\n        this.get_view = () => null;\n        this.selected_glyphs = [];\n    }\n    is_empty() {\n        return this.indices.length == 0 && this.line_indices.length == 0 && this.image_indices.length == 0;\n    }\n    update_through_union(other) {\n        this.indices = union(other.indices, this.indices);\n        this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);\n        this.line_indices = union(other.line_indices, this.line_indices);\n        if (!this.get_view())\n            this.get_view = other.get_view;\n        this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);\n    }\n    update_through_intersection(other) {\n        this.indices = intersection(other.indices, this.indices);\n        // TODO: think through and fix any logic below\n        this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);\n        this.line_indices = union(other.line_indices, this.line_indices);\n        if (!this.get_view())\n            this.get_view = other.get_view;\n        this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);\n    }\n}\nSelection.__name__ = \"Selection\";\nSelection.init_Selection();\n//# sourceMappingURL=selection.js.map"]},"metadata":{},"sourceType":"module"}