{"ast":null,"code":"import { GuideRenderer, GuideRendererView } from \"../renderers/guide_renderer\";\nimport * as p from \"../../core/properties\";\nimport { sum } from \"../../core/util/array\";\nimport { isString, isArray, isNumber } from \"../../core/util/types\";\nimport { FactorRange } from \"../ranges/factor_range\";\nconst {\n  abs,\n  min,\n  max\n} = Math;\nexport class AxisView extends GuideRendererView {\n  constructor() {\n    super(...arguments);\n    this.rotate = true;\n  }\n\n  get panel() {\n    return this.layout;\n  }\n\n  render() {\n    if (!this.model.visible) return;\n    const extents = {\n      tick: this._tick_extent(),\n      tick_label: this._tick_label_extents(),\n      axis_label: this._axis_label_extent()\n    };\n    const tick_coords = this.tick_coords;\n    const ctx = this.plot_view.canvas_view.ctx;\n    ctx.save();\n\n    this._draw_rule(ctx, extents);\n\n    this._draw_major_ticks(ctx, extents, tick_coords);\n\n    this._draw_minor_ticks(ctx, extents, tick_coords);\n\n    this._draw_major_labels(ctx, extents, tick_coords);\n\n    this._draw_axis_label(ctx, extents, tick_coords);\n\n    if (this._render != null) this._render(ctx, extents, tick_coords);\n    ctx.restore();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.model.change, () => this.plot_view.request_paint());\n    const p = this.model.properties;\n    this.on_change(p.visible, () => this.plot_view.request_layout());\n  }\n\n  get_size() {\n    if (this.model.visible && this.model.fixed_location == null) {\n      const size = this._get_size();\n\n      return {\n        width: 0\n        /* max */\n        ,\n        height: Math.round(size)\n      };\n    } else return {\n      width: 0,\n      height: 0\n    };\n  }\n\n  _get_size() {\n    return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\n  }\n\n  get needs_clip() {\n    return this.model.fixed_location != null;\n  } // drawing sub functions -----------------------------------------------------\n\n\n  _draw_rule(ctx, _extents) {\n    if (!this.visuals.axis_line.doit) return;\n    const [xs, ys] = this.rule_coords;\n    const [sxs, sys] = this.plot_view.map_to_screen(xs, ys, this.model.x_range_name, this.model.y_range_name);\n    const [nx, ny] = this.normals;\n    const [xoff, yoff] = this.offsets;\n    this.visuals.axis_line.set_value(ctx);\n    ctx.beginPath();\n    ctx.moveTo(Math.round(sxs[0] + nx * xoff), Math.round(sys[0] + ny * yoff));\n\n    for (let i = 1; i < sxs.length; i++) {\n      const sx = Math.round(sxs[i] + nx * xoff);\n      const sy = Math.round(sys[i] + ny * yoff);\n      ctx.lineTo(sx, sy);\n    }\n\n    ctx.stroke();\n  }\n\n  _draw_major_ticks(ctx, _extents, tick_coords) {\n    const tin = this.model.major_tick_in;\n    const tout = this.model.major_tick_out;\n    const visuals = this.visuals.major_tick_line;\n\n    this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);\n  }\n\n  _draw_minor_ticks(ctx, _extents, tick_coords) {\n    const tin = this.model.minor_tick_in;\n    const tout = this.model.minor_tick_out;\n    const visuals = this.visuals.minor_tick_line;\n\n    this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);\n  }\n\n  _draw_major_labels(ctx, extents, tick_coords) {\n    const coords = tick_coords.major;\n    const labels = this.compute_labels(coords[this.dimension]);\n    const orient = this.model.major_label_orientation;\n    const standoff = extents.tick + this.model.major_label_standoff;\n    const visuals = this.visuals.major_label_text;\n\n    this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\n  }\n\n  _draw_axis_label(ctx, extents, _tick_coords) {\n    if (this.model.axis_label == null || this.model.axis_label.length == 0 || this.model.fixed_location != null) return;\n    let sx;\n    let sy;\n\n    switch (this.panel.side) {\n      case \"above\":\n        sx = this.panel._hcenter.value;\n        sy = this.panel._bottom.value;\n        break;\n\n      case \"below\":\n        sx = this.panel._hcenter.value;\n        sy = this.panel._top.value;\n        break;\n\n      case \"left\":\n        sx = this.panel._right.value;\n        sy = this.panel._vcenter.value;\n        break;\n\n      case \"right\":\n        sx = this.panel._left.value;\n        sy = this.panel._vcenter.value;\n        break;\n\n      default:\n        throw new Error(`unknown side: ${this.panel.side}`);\n    }\n\n    const coords = [[sx], [sy]];\n    const standoff = extents.tick + sum(extents.tick_label) + this.model.axis_label_standoff;\n    const visuals = this.visuals.axis_label_text;\n\n    this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.panel.side, standoff, visuals, \"screen\");\n  }\n\n  _draw_ticks(ctx, coords, tin, tout, visuals) {\n    if (!visuals.doit) return;\n    const [x, y] = coords;\n    const [sxs, sys] = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    const [nx, ny] = this.normals;\n    const [xoff, yoff] = this.offsets;\n    const [nxin, nyin] = [nx * (xoff - tin), ny * (yoff - tin)];\n    const [nxout, nyout] = [nx * (xoff + tout), ny * (yoff + tout)];\n    visuals.set_value(ctx);\n\n    for (let i = 0; i < sxs.length; i++) {\n      const sx0 = Math.round(sxs[i] + nxout);\n      const sy0 = Math.round(sys[i] + nyout);\n      const sx1 = Math.round(sxs[i] + nxin);\n      const sy1 = Math.round(sys[i] + nyin);\n      ctx.beginPath();\n      ctx.moveTo(sx0, sy0);\n      ctx.lineTo(sx1, sy1);\n      ctx.stroke();\n    }\n  }\n\n  _draw_oriented_labels(ctx, labels, coords, orient, _side, standoff, visuals, units = \"data\") {\n    if (!visuals.doit || labels.length == 0) return;\n    let sxs, sys;\n    let xoff, yoff;\n\n    if (units == \"screen\") {\n      [sxs, sys] = coords;\n      [xoff, yoff] = [0, 0];\n    } else {\n      const [dxs, dys] = coords;\n      [sxs, sys] = this.plot_view.map_to_screen(dxs, dys, this.model.x_range_name, this.model.y_range_name);\n      [xoff, yoff] = this.offsets;\n    }\n\n    const [nx, ny] = this.normals;\n    const nxd = nx * (xoff + standoff);\n    const nyd = ny * (yoff + standoff);\n    visuals.set_value(ctx);\n    this.panel.apply_label_text_heuristics(ctx, orient);\n    let angle;\n    if (isString(orient)) angle = this.panel.get_label_angle_heuristic(orient);else angle = -orient;\n\n    for (let i = 0; i < sxs.length; i++) {\n      const sx = Math.round(sxs[i] + nxd);\n      const sy = Math.round(sys[i] + nyd);\n      ctx.translate(sx, sy);\n      ctx.rotate(angle);\n      ctx.fillText(labels[i], 0, 0);\n      ctx.rotate(-angle);\n      ctx.translate(-sx, -sy);\n    }\n  } // extents sub functions -----------------------------------------------------\n\n  /*protected*/\n\n\n  _axis_label_extent() {\n    if (this.model.axis_label == null || this.model.axis_label == \"\") return 0;\n    const standoff = this.model.axis_label_standoff;\n    const visuals = this.visuals.axis_label_text;\n    return this._oriented_labels_extent([this.model.axis_label], \"parallel\", this.panel.side, standoff, visuals);\n  }\n  /*protected*/\n\n\n  _tick_extent() {\n    return this.model.major_tick_out;\n  }\n  /*protected*/\n\n\n  _tick_label_extent() {\n    return sum(this._tick_label_extents());\n  }\n\n  _tick_label_extents() {\n    const coords = this.tick_coords.major;\n    const labels = this.compute_labels(coords[this.dimension]);\n    const orient = this.model.major_label_orientation;\n    const standoff = this.model.major_label_standoff;\n    const visuals = this.visuals.major_label_text;\n    return [this._oriented_labels_extent(labels, orient, this.panel.side, standoff, visuals)];\n  }\n\n  _oriented_labels_extent(labels, orient, side, standoff, visuals) {\n    if (labels.length == 0) return 0;\n    const ctx = this.plot_view.canvas_view.ctx;\n    visuals.set_value(ctx);\n    let hscale;\n    let angle;\n\n    if (isString(orient)) {\n      hscale = 1;\n      angle = this.panel.get_label_angle_heuristic(orient);\n    } else {\n      hscale = 2;\n      angle = -orient;\n    }\n\n    angle = Math.abs(angle);\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    let extent = 0;\n\n    for (let i = 0; i < labels.length; i++) {\n      const w = ctx.measureText(labels[i]).width * 1.1;\n      const h = ctx.measureText(labels[i]).ascent * 0.9;\n      let val;\n      if (side == \"above\" || side == \"below\") val = w * s + h / hscale * c;else val = w * c + h / hscale * s; // update extent if current value is larger\n\n      if (val > extent) extent = val;\n    } // only apply the standoff if we already have non-zero extent\n\n\n    if (extent > 0) extent += standoff;\n    return extent;\n  } // {{{ TODO: state\n\n\n  get normals() {\n    return this.panel.normals;\n  }\n\n  get dimension() {\n    return this.panel.dimension;\n  }\n\n  compute_labels(ticks) {\n    const labels = this.model.formatter.doFormat(ticks, this);\n\n    for (let i = 0; i < ticks.length; i++) {\n      if (ticks[i] in this.model.major_label_overrides) labels[i] = this.model.major_label_overrides[ticks[i]];\n    }\n\n    return labels;\n  }\n\n  get offsets() {\n    // If we have a fixed_position then we should respect that exactly and\n    // not apply any offsets (https://github.com/bokeh/bokeh/issues/8552)\n    if (this.model.fixed_location != null) return [0, 0];\n    const {\n      frame\n    } = this.plot_view;\n    let [xoff, yoff] = [0, 0];\n\n    switch (this.panel.side) {\n      case \"below\":\n        yoff = abs(this.panel._top.value - frame._bottom.value);\n        break;\n\n      case \"above\":\n        yoff = abs(this.panel._bottom.value - frame._top.value);\n        break;\n\n      case \"right\":\n        xoff = abs(this.panel._left.value - frame._right.value);\n        break;\n\n      case \"left\":\n        xoff = abs(this.panel._right.value - frame._left.value);\n        break;\n    }\n\n    return [xoff, yoff];\n  }\n\n  get ranges() {\n    const i = this.dimension;\n    const j = (i + 1) % 2;\n    const {\n      frame\n    } = this.plot_view;\n    const ranges = [frame.x_ranges[this.model.x_range_name], frame.y_ranges[this.model.y_range_name]];\n    return [ranges[i], ranges[j]];\n  }\n\n  get computed_bounds() {\n    const [range] = this.ranges;\n    const user_bounds = this.model.bounds; // XXX: ? 'auto'\n\n    const range_bounds = [range.min, range.max];\n    if (user_bounds == 'auto') return [range.min, range.max];else if (isArray(user_bounds)) {\n      let start;\n      let end;\n      const [user_start, user_end] = user_bounds;\n      const [range_start, range_end] = range_bounds;\n\n      if (abs(user_start - user_end) > abs(range_start - range_end)) {\n        start = max(min(user_start, user_end), range_start);\n        end = min(max(user_start, user_end), range_end);\n      } else {\n        start = min(user_start, user_end);\n        end = max(user_start, user_end);\n      }\n\n      return [start, end];\n    } else throw new Error(`user bounds '${user_bounds}' not understood`);\n  }\n\n  get rule_coords() {\n    const i = this.dimension;\n    const j = (i + 1) % 2;\n    const [range] = this.ranges;\n    const [start, end] = this.computed_bounds;\n    const xs = new Array(2);\n    const ys = new Array(2);\n    const coords = [xs, ys];\n    coords[i][0] = Math.max(start, range.min);\n    coords[i][1] = Math.min(end, range.max);\n    if (coords[i][0] > coords[i][1]) coords[i][0] = coords[i][1] = NaN;\n    coords[j][0] = this.loc;\n    coords[j][1] = this.loc;\n    return coords;\n  }\n\n  get tick_coords() {\n    const i = this.dimension;\n    const j = (i + 1) % 2;\n    const [range] = this.ranges;\n    const [start, end] = this.computed_bounds;\n    const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\n    const majors = ticks.major;\n    const minors = ticks.minor;\n    const xs = [];\n    const ys = [];\n    const coords = [xs, ys];\n    const minor_xs = [];\n    const minor_ys = [];\n    const minor_coords = [minor_xs, minor_ys];\n    const [range_min, range_max] = [range.min, range.max];\n\n    for (let ii = 0; ii < majors.length; ii++) {\n      if (majors[ii] < range_min || majors[ii] > range_max) continue;\n      coords[i].push(majors[ii]);\n      coords[j].push(this.loc);\n    }\n\n    for (let ii = 0; ii < minors.length; ii++) {\n      if (minors[ii] < range_min || minors[ii] > range_max) continue;\n      minor_coords[i].push(minors[ii]);\n      minor_coords[j].push(this.loc);\n    }\n\n    return {\n      major: coords,\n      minor: minor_coords\n    };\n  }\n\n  get loc() {\n    const {\n      fixed_location\n    } = this.model;\n\n    if (fixed_location != null) {\n      if (isNumber(fixed_location)) return fixed_location;\n      const [, cross_range] = this.ranges;\n      if (cross_range instanceof FactorRange) return cross_range.synthetic(fixed_location);\n      throw new Error(\"unexpected\");\n    }\n\n    const [, cross_range] = this.ranges;\n\n    switch (this.panel.side) {\n      case 'left':\n      case 'below':\n        return cross_range.start;\n\n      case 'right':\n      case 'above':\n        return cross_range.end;\n    }\n  } // }}}\n\n\n  serializable_state() {\n    return Object.assign(Object.assign({}, super.serializable_state()), {\n      bbox: this.layout.bbox.box\n    });\n  }\n\n}\nAxisView.__name__ = \"AxisView\";\nexport class Axis extends GuideRenderer {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Axis() {\n    this.prototype.default_view = AxisView;\n    this.mixins(['line:axis_', 'line:major_tick_', 'line:minor_tick_', 'text:major_label_', 'text:axis_label_']);\n    this.define({\n      bounds: [p.Any, 'auto'],\n      ticker: [p.Instance],\n      formatter: [p.Instance],\n      x_range_name: [p.String, 'default'],\n      y_range_name: [p.String, 'default'],\n      axis_label: [p.String, ''],\n      axis_label_standoff: [p.Int, 5],\n      major_label_standoff: [p.Int, 5],\n      major_label_orientation: [p.Any, \"horizontal\"],\n      major_label_overrides: [p.Any, {}],\n      major_tick_in: [p.Number, 2],\n      major_tick_out: [p.Number, 6],\n      minor_tick_in: [p.Number, 0],\n      minor_tick_out: [p.Number, 4],\n      fixed_location: [p.Any, null]\n    });\n    this.override({\n      axis_line_color: 'black',\n      major_tick_line_color: 'black',\n      minor_tick_line_color: 'black',\n      major_label_text_font_size: \"11px\",\n      major_label_text_align: \"center\",\n      major_label_text_baseline: \"alphabetic\",\n      axis_label_text_font_size: \"13px\",\n      axis_label_text_font_style: \"italic\"\n    });\n  }\n\n}\nAxis.__name__ = \"Axis\";\nAxis.init_Axis();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/axes/axis.js"],"names":["GuideRenderer","GuideRendererView","p","sum","isString","isArray","isNumber","FactorRange","abs","min","max","Math","AxisView","constructor","arguments","rotate","panel","layout","render","model","visible","extents","tick","_tick_extent","tick_label","_tick_label_extents","axis_label","_axis_label_extent","tick_coords","ctx","plot_view","canvas_view","save","_draw_rule","_draw_major_ticks","_draw_minor_ticks","_draw_major_labels","_draw_axis_label","_render","restore","connect_signals","connect","change","request_paint","properties","on_change","request_layout","get_size","fixed_location","size","_get_size","width","height","round","_tick_label_extent","needs_clip","_extents","visuals","axis_line","doit","xs","ys","rule_coords","sxs","sys","map_to_screen","x_range_name","y_range_name","nx","ny","normals","xoff","yoff","offsets","set_value","beginPath","moveTo","i","length","sx","sy","lineTo","stroke","tin","major_tick_in","tout","major_tick_out","major_tick_line","_draw_ticks","major","minor_tick_in","minor_tick_out","minor_tick_line","minor","coords","labels","compute_labels","dimension","orient","major_label_orientation","standoff","major_label_standoff","major_label_text","_draw_oriented_labels","side","_tick_coords","_hcenter","value","_bottom","_top","_right","_vcenter","_left","Error","axis_label_standoff","axis_label_text","x","y","nxin","nyin","nxout","nyout","sx0","sy0","sx1","sy1","_side","units","dxs","dys","nxd","nyd","apply_label_text_heuristics","angle","get_label_angle_heuristic","translate","fillText","_oriented_labels_extent","hscale","c","cos","s","sin","extent","w","measureText","h","ascent","val","ticks","formatter","doFormat","major_label_overrides","frame","ranges","j","x_ranges","y_ranges","computed_bounds","range","user_bounds","bounds","range_bounds","start","end","user_start","user_end","range_start","range_end","Array","NaN","loc","ticker","get_ticks","majors","minors","minor_xs","minor_ys","minor_coords","range_min","range_max","ii","push","cross_range","synthetic","serializable_state","Object","assign","bbox","box","__name__","Axis","attrs","init_Axis","prototype","default_view","mixins","define","Any","Instance","String","Int","Number","override","axis_line_color","major_tick_line_color","minor_tick_line_color","major_label_text_font_size","major_label_text_align","major_label_text_baseline","axis_label_text_font_size","axis_label_text_font_style"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,iBAAxB,QAAiD,6BAAjD;AACA,OAAO,KAAKC,CAAZ,MAAmB,uBAAnB;AACA,SAASC,GAAT,QAAoB,uBAApB;AACA,SAASC,QAAT,EAAmBC,OAAnB,EAA4BC,QAA5B,QAA4C,uBAA5C;AACA,SAASC,WAAT,QAA4B,wBAA5B;AACA,MAAM;AAAEC,EAAAA,GAAF;AAAOC,EAAAA,GAAP;AAAYC,EAAAA;AAAZ,IAAoBC,IAA1B;AACA,OAAO,MAAMC,QAAN,SAAuBX,iBAAvB,CAAyC;AAC5CY,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA,SAAKC,MAAL,GAAc,IAAd;AACH;;AACD,MAAIC,KAAJ,GAAY;AACR,WAAO,KAAKC,MAAZ;AACH;;AACDC,EAAAA,MAAM,GAAG;AACL,QAAI,CAAC,KAAKC,KAAL,CAAWC,OAAhB,EACI;AACJ,UAAMC,OAAO,GAAG;AACZC,MAAAA,IAAI,EAAE,KAAKC,YAAL,EADM;AAEZC,MAAAA,UAAU,EAAE,KAAKC,mBAAL,EAFA;AAGZC,MAAAA,UAAU,EAAE,KAAKC,kBAAL;AAHA,KAAhB;AAKA,UAAMC,WAAW,GAAG,KAAKA,WAAzB;AACA,UAAMC,GAAG,GAAG,KAAKC,SAAL,CAAeC,WAAf,CAA2BF,GAAvC;AACAA,IAAAA,GAAG,CAACG,IAAJ;;AACA,SAAKC,UAAL,CAAgBJ,GAAhB,EAAqBR,OAArB;;AACA,SAAKa,iBAAL,CAAuBL,GAAvB,EAA4BR,OAA5B,EAAqCO,WAArC;;AACA,SAAKO,iBAAL,CAAuBN,GAAvB,EAA4BR,OAA5B,EAAqCO,WAArC;;AACA,SAAKQ,kBAAL,CAAwBP,GAAxB,EAA6BR,OAA7B,EAAsCO,WAAtC;;AACA,SAAKS,gBAAL,CAAsBR,GAAtB,EAA2BR,OAA3B,EAAoCO,WAApC;;AACA,QAAI,KAAKU,OAAL,IAAgB,IAApB,EACI,KAAKA,OAAL,CAAaT,GAAb,EAAkBR,OAAlB,EAA2BO,WAA3B;AACJC,IAAAA,GAAG,CAACU,OAAJ;AACH;;AACDC,EAAAA,eAAe,GAAG;AACd,UAAMA,eAAN;AACA,SAAKC,OAAL,CAAa,KAAKtB,KAAL,CAAWuB,MAAxB,EAAgC,MAAM,KAAKZ,SAAL,CAAea,aAAf,EAAtC;AACA,UAAMzC,CAAC,GAAG,KAAKiB,KAAL,CAAWyB,UAArB;AACA,SAAKC,SAAL,CAAe3C,CAAC,CAACkB,OAAjB,EAA0B,MAAM,KAAKU,SAAL,CAAegB,cAAf,EAAhC;AACH;;AACDC,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAK5B,KAAL,CAAWC,OAAX,IAAsB,KAAKD,KAAL,CAAW6B,cAAX,IAA6B,IAAvD,EAA6D;AACzD,YAAMC,IAAI,GAAG,KAAKC,SAAL,EAAb;;AACA,aAAO;AAAEC,QAAAA,KAAK,EAAE;AAAE;AAAX;AAAsBC,QAAAA,MAAM,EAAEzC,IAAI,CAAC0C,KAAL,CAAWJ,IAAX;AAA9B,OAAP;AACH,KAHD,MAKI,OAAO;AAAEE,MAAAA,KAAK,EAAE,CAAT;AAAYC,MAAAA,MAAM,EAAE;AAApB,KAAP;AACP;;AACDF,EAAAA,SAAS,GAAG;AACR,WAAO,KAAK3B,YAAL,KAAsB,KAAK+B,kBAAL,EAAtB,GAAkD,KAAK3B,kBAAL,EAAzD;AACH;;AACD,MAAI4B,UAAJ,GAAiB;AACb,WAAO,KAAKpC,KAAL,CAAW6B,cAAX,IAA6B,IAApC;AACH,GA/C2C,CAgD5C;;;AACAf,EAAAA,UAAU,CAACJ,GAAD,EAAM2B,QAAN,EAAgB;AACtB,QAAI,CAAC,KAAKC,OAAL,CAAaC,SAAb,CAAuBC,IAA5B,EACI;AACJ,UAAM,CAACC,EAAD,EAAKC,EAAL,IAAW,KAAKC,WAAtB;AACA,UAAM,CAACC,GAAD,EAAMC,GAAN,IAAa,KAAKlC,SAAL,CAAemC,aAAf,CAA6BL,EAA7B,EAAiCC,EAAjC,EAAqC,KAAK1C,KAAL,CAAW+C,YAAhD,EAA8D,KAAK/C,KAAL,CAAWgD,YAAzE,CAAnB;AACA,UAAM,CAACC,EAAD,EAAKC,EAAL,IAAW,KAAKC,OAAtB;AACA,UAAM,CAACC,IAAD,EAAOC,IAAP,IAAe,KAAKC,OAA1B;AACA,SAAKhB,OAAL,CAAaC,SAAb,CAAuBgB,SAAvB,CAAiC7C,GAAjC;AACAA,IAAAA,GAAG,CAAC8C,SAAJ;AACA9C,IAAAA,GAAG,CAAC+C,MAAJ,CAAWjE,IAAI,CAAC0C,KAAL,CAAWU,GAAG,CAAC,CAAD,CAAH,GAASK,EAAE,GAAGG,IAAzB,CAAX,EAA2C5D,IAAI,CAAC0C,KAAL,CAAWW,GAAG,CAAC,CAAD,CAAH,GAASK,EAAE,GAAGG,IAAzB,CAA3C;;AACA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,GAAG,CAACe,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACjC,YAAME,EAAE,GAAGpE,IAAI,CAAC0C,KAAL,CAAWU,GAAG,CAACc,CAAD,CAAH,GAAST,EAAE,GAAGG,IAAzB,CAAX;AACA,YAAMS,EAAE,GAAGrE,IAAI,CAAC0C,KAAL,CAAWW,GAAG,CAACa,CAAD,CAAH,GAASR,EAAE,GAAGG,IAAzB,CAAX;AACA3C,MAAAA,GAAG,CAACoD,MAAJ,CAAWF,EAAX,EAAeC,EAAf;AACH;;AACDnD,IAAAA,GAAG,CAACqD,MAAJ;AACH;;AACDhD,EAAAA,iBAAiB,CAACL,GAAD,EAAM2B,QAAN,EAAgB5B,WAAhB,EAA6B;AAC1C,UAAMuD,GAAG,GAAG,KAAKhE,KAAL,CAAWiE,aAAvB;AACA,UAAMC,IAAI,GAAG,KAAKlE,KAAL,CAAWmE,cAAxB;AACA,UAAM7B,OAAO,GAAG,KAAKA,OAAL,CAAa8B,eAA7B;;AACA,SAAKC,WAAL,CAAiB3D,GAAjB,EAAsBD,WAAW,CAAC6D,KAAlC,EAAyCN,GAAzC,EAA8CE,IAA9C,EAAoD5B,OAApD;AACH;;AACDtB,EAAAA,iBAAiB,CAACN,GAAD,EAAM2B,QAAN,EAAgB5B,WAAhB,EAA6B;AAC1C,UAAMuD,GAAG,GAAG,KAAKhE,KAAL,CAAWuE,aAAvB;AACA,UAAML,IAAI,GAAG,KAAKlE,KAAL,CAAWwE,cAAxB;AACA,UAAMlC,OAAO,GAAG,KAAKA,OAAL,CAAamC,eAA7B;;AACA,SAAKJ,WAAL,CAAiB3D,GAAjB,EAAsBD,WAAW,CAACiE,KAAlC,EAAyCV,GAAzC,EAA8CE,IAA9C,EAAoD5B,OAApD;AACH;;AACDrB,EAAAA,kBAAkB,CAACP,GAAD,EAAMR,OAAN,EAAeO,WAAf,EAA4B;AAC1C,UAAMkE,MAAM,GAAGlE,WAAW,CAAC6D,KAA3B;AACA,UAAMM,MAAM,GAAG,KAAKC,cAAL,CAAoBF,MAAM,CAAC,KAAKG,SAAN,CAA1B,CAAf;AACA,UAAMC,MAAM,GAAG,KAAK/E,KAAL,CAAWgF,uBAA1B;AACA,UAAMC,QAAQ,GAAG/E,OAAO,CAACC,IAAR,GAAe,KAAKH,KAAL,CAAWkF,oBAA3C;AACA,UAAM5C,OAAO,GAAG,KAAKA,OAAL,CAAa6C,gBAA7B;;AACA,SAAKC,qBAAL,CAA2B1E,GAA3B,EAAgCkE,MAAhC,EAAwCD,MAAxC,EAAgDI,MAAhD,EAAwD,KAAKlF,KAAL,CAAWwF,IAAnE,EAAyEJ,QAAzE,EAAmF3C,OAAnF;AACH;;AACDpB,EAAAA,gBAAgB,CAACR,GAAD,EAAMR,OAAN,EAAeoF,YAAf,EAA6B;AACzC,QAAI,KAAKtF,KAAL,CAAWO,UAAX,IAAyB,IAAzB,IAAiC,KAAKP,KAAL,CAAWO,UAAX,CAAsBoD,MAAtB,IAAgC,CAAjE,IAAsE,KAAK3D,KAAL,CAAW6B,cAAX,IAA6B,IAAvG,EACI;AACJ,QAAI+B,EAAJ;AACA,QAAIC,EAAJ;;AACA,YAAQ,KAAKhE,KAAL,CAAWwF,IAAnB;AACI,WAAK,OAAL;AACIzB,QAAAA,EAAE,GAAG,KAAK/D,KAAL,CAAW0F,QAAX,CAAoBC,KAAzB;AACA3B,QAAAA,EAAE,GAAG,KAAKhE,KAAL,CAAW4F,OAAX,CAAmBD,KAAxB;AACA;;AACJ,WAAK,OAAL;AACI5B,QAAAA,EAAE,GAAG,KAAK/D,KAAL,CAAW0F,QAAX,CAAoBC,KAAzB;AACA3B,QAAAA,EAAE,GAAG,KAAKhE,KAAL,CAAW6F,IAAX,CAAgBF,KAArB;AACA;;AACJ,WAAK,MAAL;AACI5B,QAAAA,EAAE,GAAG,KAAK/D,KAAL,CAAW8F,MAAX,CAAkBH,KAAvB;AACA3B,QAAAA,EAAE,GAAG,KAAKhE,KAAL,CAAW+F,QAAX,CAAoBJ,KAAzB;AACA;;AACJ,WAAK,OAAL;AACI5B,QAAAA,EAAE,GAAG,KAAK/D,KAAL,CAAWgG,KAAX,CAAiBL,KAAtB;AACA3B,QAAAA,EAAE,GAAG,KAAKhE,KAAL,CAAW+F,QAAX,CAAoBJ,KAAzB;AACA;;AACJ;AACI,cAAM,IAAIM,KAAJ,CAAW,iBAAgB,KAAKjG,KAAL,CAAWwF,IAAK,EAA3C,CAAN;AAlBR;;AAoBA,UAAMV,MAAM,GAAG,CAAC,CAACf,EAAD,CAAD,EAAO,CAACC,EAAD,CAAP,CAAf;AACA,UAAMoB,QAAQ,GAAG/E,OAAO,CAACC,IAAR,GAAenB,GAAG,CAACkB,OAAO,CAACG,UAAT,CAAlB,GAAyC,KAAKL,KAAL,CAAW+F,mBAArE;AACA,UAAMzD,OAAO,GAAG,KAAKA,OAAL,CAAa0D,eAA7B;;AACA,SAAKZ,qBAAL,CAA2B1E,GAA3B,EAAgC,CAAC,KAAKV,KAAL,CAAWO,UAAZ,CAAhC,EAAyDoE,MAAzD,EAAiE,UAAjE,EAA6E,KAAK9E,KAAL,CAAWwF,IAAxF,EAA8FJ,QAA9F,EAAwG3C,OAAxG,EAAiH,QAAjH;AACH;;AACD+B,EAAAA,WAAW,CAAC3D,GAAD,EAAMiE,MAAN,EAAcX,GAAd,EAAmBE,IAAnB,EAAyB5B,OAAzB,EAAkC;AACzC,QAAI,CAACA,OAAO,CAACE,IAAb,EACI;AACJ,UAAM,CAACyD,CAAD,EAAIC,CAAJ,IAASvB,MAAf;AACA,UAAM,CAAC/B,GAAD,EAAMC,GAAN,IAAa,KAAKlC,SAAL,CAAemC,aAAf,CAA6BmD,CAA7B,EAAgCC,CAAhC,EAAmC,KAAKlG,KAAL,CAAW+C,YAA9C,EAA4D,KAAK/C,KAAL,CAAWgD,YAAvE,CAAnB;AACA,UAAM,CAACC,EAAD,EAAKC,EAAL,IAAW,KAAKC,OAAtB;AACA,UAAM,CAACC,IAAD,EAAOC,IAAP,IAAe,KAAKC,OAA1B;AACA,UAAM,CAAC6C,IAAD,EAAOC,IAAP,IAAe,CAACnD,EAAE,IAAIG,IAAI,GAAGY,GAAX,CAAH,EAAoBd,EAAE,IAAIG,IAAI,GAAGW,GAAX,CAAtB,CAArB;AACA,UAAM,CAACqC,KAAD,EAAQC,KAAR,IAAiB,CAACrD,EAAE,IAAIG,IAAI,GAAGc,IAAX,CAAH,EAAqBhB,EAAE,IAAIG,IAAI,GAAGa,IAAX,CAAvB,CAAvB;AACA5B,IAAAA,OAAO,CAACiB,SAAR,CAAkB7C,GAAlB;;AACA,SAAK,IAAIgD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,GAAG,CAACe,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACjC,YAAM6C,GAAG,GAAG/G,IAAI,CAAC0C,KAAL,CAAWU,GAAG,CAACc,CAAD,CAAH,GAAS2C,KAApB,CAAZ;AACA,YAAMG,GAAG,GAAGhH,IAAI,CAAC0C,KAAL,CAAWW,GAAG,CAACa,CAAD,CAAH,GAAS4C,KAApB,CAAZ;AACA,YAAMG,GAAG,GAAGjH,IAAI,CAAC0C,KAAL,CAAWU,GAAG,CAACc,CAAD,CAAH,GAASyC,IAApB,CAAZ;AACA,YAAMO,GAAG,GAAGlH,IAAI,CAAC0C,KAAL,CAAWW,GAAG,CAACa,CAAD,CAAH,GAAS0C,IAApB,CAAZ;AACA1F,MAAAA,GAAG,CAAC8C,SAAJ;AACA9C,MAAAA,GAAG,CAAC+C,MAAJ,CAAW8C,GAAX,EAAgBC,GAAhB;AACA9F,MAAAA,GAAG,CAACoD,MAAJ,CAAW2C,GAAX,EAAgBC,GAAhB;AACAhG,MAAAA,GAAG,CAACqD,MAAJ;AACH;AACJ;;AACDqB,EAAAA,qBAAqB,CAAC1E,GAAD,EAAMkE,MAAN,EAAcD,MAAd,EAAsBI,MAAtB,EAA8B4B,KAA9B,EAAqC1B,QAArC,EAA+C3C,OAA/C,EAAwDsE,KAAK,GAAG,MAAhE,EAAwE;AACzF,QAAI,CAACtE,OAAO,CAACE,IAAT,IAAiBoC,MAAM,CAACjB,MAAP,IAAiB,CAAtC,EACI;AACJ,QAAIf,GAAJ,EAASC,GAAT;AACA,QAAIO,IAAJ,EAAUC,IAAV;;AACA,QAAIuD,KAAK,IAAI,QAAb,EAAuB;AACnB,OAAChE,GAAD,EAAMC,GAAN,IAAa8B,MAAb;AACA,OAACvB,IAAD,EAAOC,IAAP,IAAe,CAAC,CAAD,EAAI,CAAJ,CAAf;AACH,KAHD,MAIK;AACD,YAAM,CAACwD,GAAD,EAAMC,GAAN,IAAanC,MAAnB;AACA,OAAC/B,GAAD,EAAMC,GAAN,IAAa,KAAKlC,SAAL,CAAemC,aAAf,CAA6B+D,GAA7B,EAAkCC,GAAlC,EAAuC,KAAK9G,KAAL,CAAW+C,YAAlD,EAAgE,KAAK/C,KAAL,CAAWgD,YAA3E,CAAb;AACA,OAACI,IAAD,EAAOC,IAAP,IAAe,KAAKC,OAApB;AACH;;AACD,UAAM,CAACL,EAAD,EAAKC,EAAL,IAAW,KAAKC,OAAtB;AACA,UAAM4D,GAAG,GAAG9D,EAAE,IAAIG,IAAI,GAAG6B,QAAX,CAAd;AACA,UAAM+B,GAAG,GAAG9D,EAAE,IAAIG,IAAI,GAAG4B,QAAX,CAAd;AACA3C,IAAAA,OAAO,CAACiB,SAAR,CAAkB7C,GAAlB;AACA,SAAKb,KAAL,CAAWoH,2BAAX,CAAuCvG,GAAvC,EAA4CqE,MAA5C;AACA,QAAImC,KAAJ;AACA,QAAIjI,QAAQ,CAAC8F,MAAD,CAAZ,EACImC,KAAK,GAAG,KAAKrH,KAAL,CAAWsH,yBAAX,CAAqCpC,MAArC,CAAR,CADJ,KAGImC,KAAK,GAAG,CAACnC,MAAT;;AACJ,SAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,GAAG,CAACe,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACjC,YAAME,EAAE,GAAGpE,IAAI,CAAC0C,KAAL,CAAWU,GAAG,CAACc,CAAD,CAAH,GAASqD,GAApB,CAAX;AACA,YAAMlD,EAAE,GAAGrE,IAAI,CAAC0C,KAAL,CAAWW,GAAG,CAACa,CAAD,CAAH,GAASsD,GAApB,CAAX;AACAtG,MAAAA,GAAG,CAAC0G,SAAJ,CAAcxD,EAAd,EAAkBC,EAAlB;AACAnD,MAAAA,GAAG,CAACd,MAAJ,CAAWsH,KAAX;AACAxG,MAAAA,GAAG,CAAC2G,QAAJ,CAAazC,MAAM,CAAClB,CAAD,CAAnB,EAAwB,CAAxB,EAA2B,CAA3B;AACAhD,MAAAA,GAAG,CAACd,MAAJ,CAAW,CAACsH,KAAZ;AACAxG,MAAAA,GAAG,CAAC0G,SAAJ,CAAc,CAACxD,EAAf,EAAmB,CAACC,EAApB;AACH;AACJ,GA1K2C,CA2K5C;;AACA;;;AAAcrD,EAAAA,kBAAkB,GAAG;AAC/B,QAAI,KAAKR,KAAL,CAAWO,UAAX,IAAyB,IAAzB,IAAiC,KAAKP,KAAL,CAAWO,UAAX,IAAyB,EAA9D,EACI,OAAO,CAAP;AACJ,UAAM0E,QAAQ,GAAG,KAAKjF,KAAL,CAAW+F,mBAA5B;AACA,UAAMzD,OAAO,GAAG,KAAKA,OAAL,CAAa0D,eAA7B;AACA,WAAO,KAAKsB,uBAAL,CAA6B,CAAC,KAAKtH,KAAL,CAAWO,UAAZ,CAA7B,EAAsD,UAAtD,EAAkE,KAAKV,KAAL,CAAWwF,IAA7E,EAAmFJ,QAAnF,EAA6F3C,OAA7F,CAAP;AACH;AACD;;;AAAclC,EAAAA,YAAY,GAAG;AACzB,WAAO,KAAKJ,KAAL,CAAWmE,cAAlB;AACH;AACD;;;AAAchC,EAAAA,kBAAkB,GAAG;AAC/B,WAAOnD,GAAG,CAAC,KAAKsB,mBAAL,EAAD,CAAV;AACH;;AACDA,EAAAA,mBAAmB,GAAG;AAClB,UAAMqE,MAAM,GAAG,KAAKlE,WAAL,CAAiB6D,KAAhC;AACA,UAAMM,MAAM,GAAG,KAAKC,cAAL,CAAoBF,MAAM,CAAC,KAAKG,SAAN,CAA1B,CAAf;AACA,UAAMC,MAAM,GAAG,KAAK/E,KAAL,CAAWgF,uBAA1B;AACA,UAAMC,QAAQ,GAAG,KAAKjF,KAAL,CAAWkF,oBAA5B;AACA,UAAM5C,OAAO,GAAG,KAAKA,OAAL,CAAa6C,gBAA7B;AACA,WAAO,CAAC,KAAKmC,uBAAL,CAA6B1C,MAA7B,EAAqCG,MAArC,EAA6C,KAAKlF,KAAL,CAAWwF,IAAxD,EAA8DJ,QAA9D,EAAwE3C,OAAxE,CAAD,CAAP;AACH;;AACDgF,EAAAA,uBAAuB,CAAC1C,MAAD,EAASG,MAAT,EAAiBM,IAAjB,EAAuBJ,QAAvB,EAAiC3C,OAAjC,EAA0C;AAC7D,QAAIsC,MAAM,CAACjB,MAAP,IAAiB,CAArB,EACI,OAAO,CAAP;AACJ,UAAMjD,GAAG,GAAG,KAAKC,SAAL,CAAeC,WAAf,CAA2BF,GAAvC;AACA4B,IAAAA,OAAO,CAACiB,SAAR,CAAkB7C,GAAlB;AACA,QAAI6G,MAAJ;AACA,QAAIL,KAAJ;;AACA,QAAIjI,QAAQ,CAAC8F,MAAD,CAAZ,EAAsB;AAClBwC,MAAAA,MAAM,GAAG,CAAT;AACAL,MAAAA,KAAK,GAAG,KAAKrH,KAAL,CAAWsH,yBAAX,CAAqCpC,MAArC,CAAR;AACH,KAHD,MAIK;AACDwC,MAAAA,MAAM,GAAG,CAAT;AACAL,MAAAA,KAAK,GAAG,CAACnC,MAAT;AACH;;AACDmC,IAAAA,KAAK,GAAG1H,IAAI,CAACH,GAAL,CAAS6H,KAAT,CAAR;AACA,UAAMM,CAAC,GAAGhI,IAAI,CAACiI,GAAL,CAASP,KAAT,CAAV;AACA,UAAMQ,CAAC,GAAGlI,IAAI,CAACmI,GAAL,CAAST,KAAT,CAAV;AACA,QAAIU,MAAM,GAAG,CAAb;;AACA,SAAK,IAAIlE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,MAAM,CAACjB,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,YAAMmE,CAAC,GAAGnH,GAAG,CAACoH,WAAJ,CAAgBlD,MAAM,CAAClB,CAAD,CAAtB,EAA2B1B,KAA3B,GAAmC,GAA7C;AACA,YAAM+F,CAAC,GAAGrH,GAAG,CAACoH,WAAJ,CAAgBlD,MAAM,CAAClB,CAAD,CAAtB,EAA2BsE,MAA3B,GAAoC,GAA9C;AACA,UAAIC,GAAJ;AACA,UAAI5C,IAAI,IAAI,OAAR,IAAmBA,IAAI,IAAI,OAA/B,EACI4C,GAAG,GAAGJ,CAAC,GAAGH,CAAJ,GAASK,CAAC,GAAGR,MAAL,GAAeC,CAA7B,CADJ,KAGIS,GAAG,GAAGJ,CAAC,GAAGL,CAAJ,GAASO,CAAC,GAAGR,MAAL,GAAeG,CAA7B,CAPgC,CAQpC;;AACA,UAAIO,GAAG,GAAGL,MAAV,EACIA,MAAM,GAAGK,GAAT;AACP,KA9B4D,CA+B7D;;;AACA,QAAIL,MAAM,GAAG,CAAb,EACIA,MAAM,IAAI3C,QAAV;AACJ,WAAO2C,MAAP;AACH,GApO2C,CAqO5C;;;AACA,MAAIzE,OAAJ,GAAc;AACV,WAAO,KAAKtD,KAAL,CAAWsD,OAAlB;AACH;;AACD,MAAI2B,SAAJ,GAAgB;AACZ,WAAO,KAAKjF,KAAL,CAAWiF,SAAlB;AACH;;AACDD,EAAAA,cAAc,CAACqD,KAAD,EAAQ;AAClB,UAAMtD,MAAM,GAAG,KAAK5E,KAAL,CAAWmI,SAAX,CAAqBC,QAArB,CAA8BF,KAA9B,EAAqC,IAArC,CAAf;;AACA,SAAK,IAAIxE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwE,KAAK,CAACvE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnC,UAAIwE,KAAK,CAACxE,CAAD,CAAL,IAAY,KAAK1D,KAAL,CAAWqI,qBAA3B,EACIzD,MAAM,CAAClB,CAAD,CAAN,GAAY,KAAK1D,KAAL,CAAWqI,qBAAX,CAAiCH,KAAK,CAACxE,CAAD,CAAtC,CAAZ;AACP;;AACD,WAAOkB,MAAP;AACH;;AACD,MAAItB,OAAJ,GAAc;AACV;AACA;AACA,QAAI,KAAKtD,KAAL,CAAW6B,cAAX,IAA6B,IAAjC,EACI,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACJ,UAAM;AAAEyG,MAAAA;AAAF,QAAY,KAAK3H,SAAvB;AACA,QAAI,CAACyC,IAAD,EAAOC,IAAP,IAAe,CAAC,CAAD,EAAI,CAAJ,CAAnB;;AACA,YAAQ,KAAKxD,KAAL,CAAWwF,IAAnB;AACI,WAAK,OAAL;AACIhC,QAAAA,IAAI,GAAGhE,GAAG,CAAC,KAAKQ,KAAL,CAAW6F,IAAX,CAAgBF,KAAhB,GAAwB8C,KAAK,CAAC7C,OAAN,CAAcD,KAAvC,CAAV;AACA;;AACJ,WAAK,OAAL;AACInC,QAAAA,IAAI,GAAGhE,GAAG,CAAC,KAAKQ,KAAL,CAAW4F,OAAX,CAAmBD,KAAnB,GAA2B8C,KAAK,CAAC5C,IAAN,CAAWF,KAAvC,CAAV;AACA;;AACJ,WAAK,OAAL;AACIpC,QAAAA,IAAI,GAAG/D,GAAG,CAAC,KAAKQ,KAAL,CAAWgG,KAAX,CAAiBL,KAAjB,GAAyB8C,KAAK,CAAC3C,MAAN,CAAaH,KAAvC,CAAV;AACA;;AACJ,WAAK,MAAL;AACIpC,QAAAA,IAAI,GAAG/D,GAAG,CAAC,KAAKQ,KAAL,CAAW8F,MAAX,CAAkBH,KAAlB,GAA0B8C,KAAK,CAACzC,KAAN,CAAYL,KAAvC,CAAV;AACA;AAZR;;AAcA,WAAO,CAACpC,IAAD,EAAOC,IAAP,CAAP;AACH;;AACD,MAAIkF,MAAJ,GAAa;AACT,UAAM7E,CAAC,GAAG,KAAKoB,SAAf;AACA,UAAM0D,CAAC,GAAG,CAAC9E,CAAC,GAAG,CAAL,IAAU,CAApB;AACA,UAAM;AAAE4E,MAAAA;AAAF,QAAY,KAAK3H,SAAvB;AACA,UAAM4H,MAAM,GAAG,CACXD,KAAK,CAACG,QAAN,CAAe,KAAKzI,KAAL,CAAW+C,YAA1B,CADW,EAEXuF,KAAK,CAACI,QAAN,CAAe,KAAK1I,KAAL,CAAWgD,YAA1B,CAFW,CAAf;AAIA,WAAO,CAACuF,MAAM,CAAC7E,CAAD,CAAP,EAAY6E,MAAM,CAACC,CAAD,CAAlB,CAAP;AACH;;AACD,MAAIG,eAAJ,GAAsB;AAClB,UAAM,CAACC,KAAD,IAAU,KAAKL,MAArB;AACA,UAAMM,WAAW,GAAG,KAAK7I,KAAL,CAAW8I,MAA/B,CAFkB,CAEqB;;AACvC,UAAMC,YAAY,GAAG,CAACH,KAAK,CAACtJ,GAAP,EAAYsJ,KAAK,CAACrJ,GAAlB,CAArB;AACA,QAAIsJ,WAAW,IAAI,MAAnB,EACI,OAAO,CAACD,KAAK,CAACtJ,GAAP,EAAYsJ,KAAK,CAACrJ,GAAlB,CAAP,CADJ,KAEK,IAAIL,OAAO,CAAC2J,WAAD,CAAX,EAA0B;AAC3B,UAAIG,KAAJ;AACA,UAAIC,GAAJ;AACA,YAAM,CAACC,UAAD,EAAaC,QAAb,IAAyBN,WAA/B;AACA,YAAM,CAACO,WAAD,EAAcC,SAAd,IAA2BN,YAAjC;;AACA,UAAI1J,GAAG,CAAC6J,UAAU,GAAGC,QAAd,CAAH,GAA6B9J,GAAG,CAAC+J,WAAW,GAAGC,SAAf,CAApC,EAA+D;AAC3DL,QAAAA,KAAK,GAAGzJ,GAAG,CAACD,GAAG,CAAC4J,UAAD,EAAaC,QAAb,CAAJ,EAA4BC,WAA5B,CAAX;AACAH,QAAAA,GAAG,GAAG3J,GAAG,CAACC,GAAG,CAAC2J,UAAD,EAAaC,QAAb,CAAJ,EAA4BE,SAA5B,CAAT;AACH,OAHD,MAIK;AACDL,QAAAA,KAAK,GAAG1J,GAAG,CAAC4J,UAAD,EAAaC,QAAb,CAAX;AACAF,QAAAA,GAAG,GAAG1J,GAAG,CAAC2J,UAAD,EAAaC,QAAb,CAAT;AACH;;AACD,aAAO,CAACH,KAAD,EAAQC,GAAR,CAAP;AACH,KAdI,MAgBD,MAAM,IAAInD,KAAJ,CAAW,gBAAe+C,WAAY,kBAAtC,CAAN;AACP;;AACD,MAAIlG,WAAJ,GAAkB;AACd,UAAMe,CAAC,GAAG,KAAKoB,SAAf;AACA,UAAM0D,CAAC,GAAG,CAAC9E,CAAC,GAAG,CAAL,IAAU,CAApB;AACA,UAAM,CAACkF,KAAD,IAAU,KAAKL,MAArB;AACA,UAAM,CAACS,KAAD,EAAQC,GAAR,IAAe,KAAKN,eAA1B;AACA,UAAMlG,EAAE,GAAG,IAAI6G,KAAJ,CAAU,CAAV,CAAX;AACA,UAAM5G,EAAE,GAAG,IAAI4G,KAAJ,CAAU,CAAV,CAAX;AACA,UAAM3E,MAAM,GAAG,CAAClC,EAAD,EAAKC,EAAL,CAAf;AACAiC,IAAAA,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,IAAelE,IAAI,CAACD,GAAL,CAASyJ,KAAT,EAAgBJ,KAAK,CAACtJ,GAAtB,CAAf;AACAqF,IAAAA,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,IAAelE,IAAI,CAACF,GAAL,CAAS2J,GAAT,EAAcL,KAAK,CAACrJ,GAApB,CAAf;AACA,QAAIoF,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,IAAeiB,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,CAAnB,EACIiB,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,IAAeiB,MAAM,CAACjB,CAAD,CAAN,CAAU,CAAV,IAAe6F,GAA9B;AACJ5E,IAAAA,MAAM,CAAC6D,CAAD,CAAN,CAAU,CAAV,IAAe,KAAKgB,GAApB;AACA7E,IAAAA,MAAM,CAAC6D,CAAD,CAAN,CAAU,CAAV,IAAe,KAAKgB,GAApB;AACA,WAAO7E,MAAP;AACH;;AACD,MAAIlE,WAAJ,GAAkB;AACd,UAAMiD,CAAC,GAAG,KAAKoB,SAAf;AACA,UAAM0D,CAAC,GAAG,CAAC9E,CAAC,GAAG,CAAL,IAAU,CAApB;AACA,UAAM,CAACkF,KAAD,IAAU,KAAKL,MAArB;AACA,UAAM,CAACS,KAAD,EAAQC,GAAR,IAAe,KAAKN,eAA1B;AACA,UAAMT,KAAK,GAAG,KAAKlI,KAAL,CAAWyJ,MAAX,CAAkBC,SAAlB,CAA4BV,KAA5B,EAAmCC,GAAnC,EAAwCL,KAAxC,EAA+C,KAAKY,GAApD,EAAyD,EAAzD,CAAd;AACA,UAAMG,MAAM,GAAGzB,KAAK,CAAC5D,KAArB;AACA,UAAMsF,MAAM,GAAG1B,KAAK,CAACxD,KAArB;AACA,UAAMjC,EAAE,GAAG,EAAX;AACA,UAAMC,EAAE,GAAG,EAAX;AACA,UAAMiC,MAAM,GAAG,CAAClC,EAAD,EAAKC,EAAL,CAAf;AACA,UAAMmH,QAAQ,GAAG,EAAjB;AACA,UAAMC,QAAQ,GAAG,EAAjB;AACA,UAAMC,YAAY,GAAG,CAACF,QAAD,EAAWC,QAAX,CAArB;AACA,UAAM,CAACE,SAAD,EAAYC,SAAZ,IAAyB,CAACrB,KAAK,CAACtJ,GAAP,EAAYsJ,KAAK,CAACrJ,GAAlB,CAA/B;;AACA,SAAK,IAAI2K,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGP,MAAM,CAAChG,MAA7B,EAAqCuG,EAAE,EAAvC,EAA2C;AACvC,UAAIP,MAAM,CAACO,EAAD,CAAN,GAAaF,SAAb,IAA0BL,MAAM,CAACO,EAAD,CAAN,GAAaD,SAA3C,EACI;AACJtF,MAAAA,MAAM,CAACjB,CAAD,CAAN,CAAUyG,IAAV,CAAeR,MAAM,CAACO,EAAD,CAArB;AACAvF,MAAAA,MAAM,CAAC6D,CAAD,CAAN,CAAU2B,IAAV,CAAe,KAAKX,GAApB;AACH;;AACD,SAAK,IAAIU,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGN,MAAM,CAACjG,MAA7B,EAAqCuG,EAAE,EAAvC,EAA2C;AACvC,UAAIN,MAAM,CAACM,EAAD,CAAN,GAAaF,SAAb,IAA0BJ,MAAM,CAACM,EAAD,CAAN,GAAaD,SAA3C,EACI;AACJF,MAAAA,YAAY,CAACrG,CAAD,CAAZ,CAAgByG,IAAhB,CAAqBP,MAAM,CAACM,EAAD,CAA3B;AACAH,MAAAA,YAAY,CAACvB,CAAD,CAAZ,CAAgB2B,IAAhB,CAAqB,KAAKX,GAA1B;AACH;;AACD,WAAO;AACHlF,MAAAA,KAAK,EAAEK,MADJ;AAEHD,MAAAA,KAAK,EAAEqF;AAFJ,KAAP;AAIH;;AACD,MAAIP,GAAJ,GAAU;AACN,UAAM;AAAE3H,MAAAA;AAAF,QAAqB,KAAK7B,KAAhC;;AACA,QAAI6B,cAAc,IAAI,IAAtB,EAA4B;AACxB,UAAI1C,QAAQ,CAAC0C,cAAD,CAAZ,EACI,OAAOA,cAAP;AACJ,YAAM,GAAGuI,WAAH,IAAkB,KAAK7B,MAA7B;AACA,UAAI6B,WAAW,YAAYhL,WAA3B,EACI,OAAOgL,WAAW,CAACC,SAAZ,CAAsBxI,cAAtB,CAAP;AACJ,YAAM,IAAIiE,KAAJ,CAAU,YAAV,CAAN;AACH;;AACD,UAAM,GAAGsE,WAAH,IAAkB,KAAK7B,MAA7B;;AACA,YAAQ,KAAK1I,KAAL,CAAWwF,IAAnB;AACI,WAAK,MAAL;AACA,WAAK,OAAL;AACI,eAAO+E,WAAW,CAACpB,KAAnB;;AACJ,WAAK,OAAL;AACA,WAAK,OAAL;AACI,eAAOoB,WAAW,CAACnB,GAAnB;AANR;AAQH,GAhX2C,CAiX5C;;;AACAqB,EAAAA,kBAAkB,GAAG;AACjB,WAAOC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,MAAMF,kBAAN,EAAlB,CAAd,EAA6D;AAAEG,MAAAA,IAAI,EAAE,KAAK3K,MAAL,CAAY2K,IAAZ,CAAiBC;AAAzB,KAA7D,CAAP;AACH;;AApX2C;AAsXhDjL,QAAQ,CAACkL,QAAT,GAAoB,UAApB;AACA,OAAO,MAAMC,IAAN,SAAmB/L,aAAnB,CAAiC;AACpCa,EAAAA,WAAW,CAACmL,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,SAAP,GAAmB;AACf,SAAKC,SAAL,CAAeC,YAAf,GAA8BvL,QAA9B;AACA,SAAKwL,MAAL,CAAY,CACR,YADQ,EAER,kBAFQ,EAGR,kBAHQ,EAIR,mBAJQ,EAKR,kBALQ,CAAZ;AAOA,SAAKC,MAAL,CAAY;AACRpC,MAAAA,MAAM,EAAE,CAAC/J,CAAC,CAACoM,GAAH,EAAQ,MAAR,CADA;AAER1B,MAAAA,MAAM,EAAE,CAAC1K,CAAC,CAACqM,QAAH,CAFA;AAGRjD,MAAAA,SAAS,EAAE,CAACpJ,CAAC,CAACqM,QAAH,CAHH;AAIRrI,MAAAA,YAAY,EAAE,CAAChE,CAAC,CAACsM,MAAH,EAAW,SAAX,CAJN;AAKRrI,MAAAA,YAAY,EAAE,CAACjE,CAAC,CAACsM,MAAH,EAAW,SAAX,CALN;AAMR9K,MAAAA,UAAU,EAAE,CAACxB,CAAC,CAACsM,MAAH,EAAW,EAAX,CANJ;AAORtF,MAAAA,mBAAmB,EAAE,CAAChH,CAAC,CAACuM,GAAH,EAAQ,CAAR,CAPb;AAQRpG,MAAAA,oBAAoB,EAAE,CAACnG,CAAC,CAACuM,GAAH,EAAQ,CAAR,CARd;AASRtG,MAAAA,uBAAuB,EAAE,CAACjG,CAAC,CAACoM,GAAH,EAAQ,YAAR,CATjB;AAUR9C,MAAAA,qBAAqB,EAAE,CAACtJ,CAAC,CAACoM,GAAH,EAAQ,EAAR,CAVf;AAWRlH,MAAAA,aAAa,EAAE,CAAClF,CAAC,CAACwM,MAAH,EAAW,CAAX,CAXP;AAYRpH,MAAAA,cAAc,EAAE,CAACpF,CAAC,CAACwM,MAAH,EAAW,CAAX,CAZR;AAaRhH,MAAAA,aAAa,EAAE,CAACxF,CAAC,CAACwM,MAAH,EAAW,CAAX,CAbP;AAcR/G,MAAAA,cAAc,EAAE,CAACzF,CAAC,CAACwM,MAAH,EAAW,CAAX,CAdR;AAeR1J,MAAAA,cAAc,EAAE,CAAC9C,CAAC,CAACoM,GAAH,EAAQ,IAAR;AAfR,KAAZ;AAiBA,SAAKK,QAAL,CAAc;AACVC,MAAAA,eAAe,EAAE,OADP;AAEVC,MAAAA,qBAAqB,EAAE,OAFb;AAGVC,MAAAA,qBAAqB,EAAE,OAHb;AAIVC,MAAAA,0BAA0B,EAAE,MAJlB;AAKVC,MAAAA,sBAAsB,EAAE,QALd;AAMVC,MAAAA,yBAAyB,EAAE,YANjB;AAOVC,MAAAA,yBAAyB,EAAE,MAPjB;AAQVC,MAAAA,0BAA0B,EAAE;AARlB,KAAd;AAUH;;AAxCmC;AA0CxCpB,IAAI,CAACD,QAAL,GAAgB,MAAhB;AACAC,IAAI,CAACE,SAAL","sourcesContent":["import { GuideRenderer, GuideRendererView } from \"../renderers/guide_renderer\";\nimport * as p from \"../../core/properties\";\nimport { sum } from \"../../core/util/array\";\nimport { isString, isArray, isNumber } from \"../../core/util/types\";\nimport { FactorRange } from \"../ranges/factor_range\";\nconst { abs, min, max } = Math;\nexport class AxisView extends GuideRendererView {\n    constructor() {\n        super(...arguments);\n        this.rotate = true;\n    }\n    get panel() {\n        return this.layout;\n    }\n    render() {\n        if (!this.model.visible)\n            return;\n        const extents = {\n            tick: this._tick_extent(),\n            tick_label: this._tick_label_extents(),\n            axis_label: this._axis_label_extent(),\n        };\n        const tick_coords = this.tick_coords;\n        const ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_rule(ctx, extents);\n        this._draw_major_ticks(ctx, extents, tick_coords);\n        this._draw_minor_ticks(ctx, extents, tick_coords);\n        this._draw_major_labels(ctx, extents, tick_coords);\n        this._draw_axis_label(ctx, extents, tick_coords);\n        if (this._render != null)\n            this._render(ctx, extents, tick_coords);\n        ctx.restore();\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.change, () => this.plot_view.request_paint());\n        const p = this.model.properties;\n        this.on_change(p.visible, () => this.plot_view.request_layout());\n    }\n    get_size() {\n        if (this.model.visible && this.model.fixed_location == null) {\n            const size = this._get_size();\n            return { width: 0 /* max */, height: Math.round(size) };\n        }\n        else\n            return { width: 0, height: 0 };\n    }\n    _get_size() {\n        return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\n    }\n    get needs_clip() {\n        return this.model.fixed_location != null;\n    }\n    // drawing sub functions -----------------------------------------------------\n    _draw_rule(ctx, _extents) {\n        if (!this.visuals.axis_line.doit)\n            return;\n        const [xs, ys] = this.rule_coords;\n        const [sxs, sys] = this.plot_view.map_to_screen(xs, ys, this.model.x_range_name, this.model.y_range_name);\n        const [nx, ny] = this.normals;\n        const [xoff, yoff] = this.offsets;\n        this.visuals.axis_line.set_value(ctx);\n        ctx.beginPath();\n        ctx.moveTo(Math.round(sxs[0] + nx * xoff), Math.round(sys[0] + ny * yoff));\n        for (let i = 1; i < sxs.length; i++) {\n            const sx = Math.round(sxs[i] + nx * xoff);\n            const sy = Math.round(sys[i] + ny * yoff);\n            ctx.lineTo(sx, sy);\n        }\n        ctx.stroke();\n    }\n    _draw_major_ticks(ctx, _extents, tick_coords) {\n        const tin = this.model.major_tick_in;\n        const tout = this.model.major_tick_out;\n        const visuals = this.visuals.major_tick_line;\n        this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);\n    }\n    _draw_minor_ticks(ctx, _extents, tick_coords) {\n        const tin = this.model.minor_tick_in;\n        const tout = this.model.minor_tick_out;\n        const visuals = this.visuals.minor_tick_line;\n        this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);\n    }\n    _draw_major_labels(ctx, extents, tick_coords) {\n        const coords = tick_coords.major;\n        const labels = this.compute_labels(coords[this.dimension]);\n        const orient = this.model.major_label_orientation;\n        const standoff = extents.tick + this.model.major_label_standoff;\n        const visuals = this.visuals.major_label_text;\n        this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\n    }\n    _draw_axis_label(ctx, extents, _tick_coords) {\n        if (this.model.axis_label == null || this.model.axis_label.length == 0 || this.model.fixed_location != null)\n            return;\n        let sx;\n        let sy;\n        switch (this.panel.side) {\n            case \"above\":\n                sx = this.panel._hcenter.value;\n                sy = this.panel._bottom.value;\n                break;\n            case \"below\":\n                sx = this.panel._hcenter.value;\n                sy = this.panel._top.value;\n                break;\n            case \"left\":\n                sx = this.panel._right.value;\n                sy = this.panel._vcenter.value;\n                break;\n            case \"right\":\n                sx = this.panel._left.value;\n                sy = this.panel._vcenter.value;\n                break;\n            default:\n                throw new Error(`unknown side: ${this.panel.side}`);\n        }\n        const coords = [[sx], [sy]];\n        const standoff = extents.tick + sum(extents.tick_label) + this.model.axis_label_standoff;\n        const visuals = this.visuals.axis_label_text;\n        this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.panel.side, standoff, visuals, \"screen\");\n    }\n    _draw_ticks(ctx, coords, tin, tout, visuals) {\n        if (!visuals.doit)\n            return;\n        const [x, y] = coords;\n        const [sxs, sys] = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n        const [nx, ny] = this.normals;\n        const [xoff, yoff] = this.offsets;\n        const [nxin, nyin] = [nx * (xoff - tin), ny * (yoff - tin)];\n        const [nxout, nyout] = [nx * (xoff + tout), ny * (yoff + tout)];\n        visuals.set_value(ctx);\n        for (let i = 0; i < sxs.length; i++) {\n            const sx0 = Math.round(sxs[i] + nxout);\n            const sy0 = Math.round(sys[i] + nyout);\n            const sx1 = Math.round(sxs[i] + nxin);\n            const sy1 = Math.round(sys[i] + nyin);\n            ctx.beginPath();\n            ctx.moveTo(sx0, sy0);\n            ctx.lineTo(sx1, sy1);\n            ctx.stroke();\n        }\n    }\n    _draw_oriented_labels(ctx, labels, coords, orient, _side, standoff, visuals, units = \"data\") {\n        if (!visuals.doit || labels.length == 0)\n            return;\n        let sxs, sys;\n        let xoff, yoff;\n        if (units == \"screen\") {\n            [sxs, sys] = coords;\n            [xoff, yoff] = [0, 0];\n        }\n        else {\n            const [dxs, dys] = coords;\n            [sxs, sys] = this.plot_view.map_to_screen(dxs, dys, this.model.x_range_name, this.model.y_range_name);\n            [xoff, yoff] = this.offsets;\n        }\n        const [nx, ny] = this.normals;\n        const nxd = nx * (xoff + standoff);\n        const nyd = ny * (yoff + standoff);\n        visuals.set_value(ctx);\n        this.panel.apply_label_text_heuristics(ctx, orient);\n        let angle;\n        if (isString(orient))\n            angle = this.panel.get_label_angle_heuristic(orient);\n        else\n            angle = -orient;\n        for (let i = 0; i < sxs.length; i++) {\n            const sx = Math.round(sxs[i] + nxd);\n            const sy = Math.round(sys[i] + nyd);\n            ctx.translate(sx, sy);\n            ctx.rotate(angle);\n            ctx.fillText(labels[i], 0, 0);\n            ctx.rotate(-angle);\n            ctx.translate(-sx, -sy);\n        }\n    }\n    // extents sub functions -----------------------------------------------------\n    /*protected*/ _axis_label_extent() {\n        if (this.model.axis_label == null || this.model.axis_label == \"\")\n            return 0;\n        const standoff = this.model.axis_label_standoff;\n        const visuals = this.visuals.axis_label_text;\n        return this._oriented_labels_extent([this.model.axis_label], \"parallel\", this.panel.side, standoff, visuals);\n    }\n    /*protected*/ _tick_extent() {\n        return this.model.major_tick_out;\n    }\n    /*protected*/ _tick_label_extent() {\n        return sum(this._tick_label_extents());\n    }\n    _tick_label_extents() {\n        const coords = this.tick_coords.major;\n        const labels = this.compute_labels(coords[this.dimension]);\n        const orient = this.model.major_label_orientation;\n        const standoff = this.model.major_label_standoff;\n        const visuals = this.visuals.major_label_text;\n        return [this._oriented_labels_extent(labels, orient, this.panel.side, standoff, visuals)];\n    }\n    _oriented_labels_extent(labels, orient, side, standoff, visuals) {\n        if (labels.length == 0)\n            return 0;\n        const ctx = this.plot_view.canvas_view.ctx;\n        visuals.set_value(ctx);\n        let hscale;\n        let angle;\n        if (isString(orient)) {\n            hscale = 1;\n            angle = this.panel.get_label_angle_heuristic(orient);\n        }\n        else {\n            hscale = 2;\n            angle = -orient;\n        }\n        angle = Math.abs(angle);\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        let extent = 0;\n        for (let i = 0; i < labels.length; i++) {\n            const w = ctx.measureText(labels[i]).width * 1.1;\n            const h = ctx.measureText(labels[i]).ascent * 0.9;\n            let val;\n            if (side == \"above\" || side == \"below\")\n                val = w * s + (h / hscale) * c;\n            else\n                val = w * c + (h / hscale) * s;\n            // update extent if current value is larger\n            if (val > extent)\n                extent = val;\n        }\n        // only apply the standoff if we already have non-zero extent\n        if (extent > 0)\n            extent += standoff;\n        return extent;\n    }\n    // {{{ TODO: state\n    get normals() {\n        return this.panel.normals;\n    }\n    get dimension() {\n        return this.panel.dimension;\n    }\n    compute_labels(ticks) {\n        const labels = this.model.formatter.doFormat(ticks, this);\n        for (let i = 0; i < ticks.length; i++) {\n            if (ticks[i] in this.model.major_label_overrides)\n                labels[i] = this.model.major_label_overrides[ticks[i]];\n        }\n        return labels;\n    }\n    get offsets() {\n        // If we have a fixed_position then we should respect that exactly and\n        // not apply any offsets (https://github.com/bokeh/bokeh/issues/8552)\n        if (this.model.fixed_location != null)\n            return [0, 0];\n        const { frame } = this.plot_view;\n        let [xoff, yoff] = [0, 0];\n        switch (this.panel.side) {\n            case \"below\":\n                yoff = abs(this.panel._top.value - frame._bottom.value);\n                break;\n            case \"above\":\n                yoff = abs(this.panel._bottom.value - frame._top.value);\n                break;\n            case \"right\":\n                xoff = abs(this.panel._left.value - frame._right.value);\n                break;\n            case \"left\":\n                xoff = abs(this.panel._right.value - frame._left.value);\n                break;\n        }\n        return [xoff, yoff];\n    }\n    get ranges() {\n        const i = this.dimension;\n        const j = (i + 1) % 2;\n        const { frame } = this.plot_view;\n        const ranges = [\n            frame.x_ranges[this.model.x_range_name],\n            frame.y_ranges[this.model.y_range_name],\n        ];\n        return [ranges[i], ranges[j]];\n    }\n    get computed_bounds() {\n        const [range] = this.ranges;\n        const user_bounds = this.model.bounds; // XXX: ? 'auto'\n        const range_bounds = [range.min, range.max];\n        if (user_bounds == 'auto')\n            return [range.min, range.max];\n        else if (isArray(user_bounds)) {\n            let start;\n            let end;\n            const [user_start, user_end] = user_bounds;\n            const [range_start, range_end] = range_bounds;\n            if (abs(user_start - user_end) > abs(range_start - range_end)) {\n                start = max(min(user_start, user_end), range_start);\n                end = min(max(user_start, user_end), range_end);\n            }\n            else {\n                start = min(user_start, user_end);\n                end = max(user_start, user_end);\n            }\n            return [start, end];\n        }\n        else\n            throw new Error(`user bounds '${user_bounds}' not understood`);\n    }\n    get rule_coords() {\n        const i = this.dimension;\n        const j = (i + 1) % 2;\n        const [range] = this.ranges;\n        const [start, end] = this.computed_bounds;\n        const xs = new Array(2);\n        const ys = new Array(2);\n        const coords = [xs, ys];\n        coords[i][0] = Math.max(start, range.min);\n        coords[i][1] = Math.min(end, range.max);\n        if (coords[i][0] > coords[i][1])\n            coords[i][0] = coords[i][1] = NaN;\n        coords[j][0] = this.loc;\n        coords[j][1] = this.loc;\n        return coords;\n    }\n    get tick_coords() {\n        const i = this.dimension;\n        const j = (i + 1) % 2;\n        const [range] = this.ranges;\n        const [start, end] = this.computed_bounds;\n        const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\n        const majors = ticks.major;\n        const minors = ticks.minor;\n        const xs = [];\n        const ys = [];\n        const coords = [xs, ys];\n        const minor_xs = [];\n        const minor_ys = [];\n        const minor_coords = [minor_xs, minor_ys];\n        const [range_min, range_max] = [range.min, range.max];\n        for (let ii = 0; ii < majors.length; ii++) {\n            if (majors[ii] < range_min || majors[ii] > range_max)\n                continue;\n            coords[i].push(majors[ii]);\n            coords[j].push(this.loc);\n        }\n        for (let ii = 0; ii < minors.length; ii++) {\n            if (minors[ii] < range_min || minors[ii] > range_max)\n                continue;\n            minor_coords[i].push(minors[ii]);\n            minor_coords[j].push(this.loc);\n        }\n        return {\n            major: coords,\n            minor: minor_coords,\n        };\n    }\n    get loc() {\n        const { fixed_location } = this.model;\n        if (fixed_location != null) {\n            if (isNumber(fixed_location))\n                return fixed_location;\n            const [, cross_range] = this.ranges;\n            if (cross_range instanceof FactorRange)\n                return cross_range.synthetic(fixed_location);\n            throw new Error(\"unexpected\");\n        }\n        const [, cross_range] = this.ranges;\n        switch (this.panel.side) {\n            case 'left':\n            case 'below':\n                return cross_range.start;\n            case 'right':\n            case 'above':\n                return cross_range.end;\n        }\n    }\n    // }}}\n    serializable_state() {\n        return Object.assign(Object.assign({}, super.serializable_state()), { bbox: this.layout.bbox.box });\n    }\n}\nAxisView.__name__ = \"AxisView\";\nexport class Axis extends GuideRenderer {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Axis() {\n        this.prototype.default_view = AxisView;\n        this.mixins([\n            'line:axis_',\n            'line:major_tick_',\n            'line:minor_tick_',\n            'text:major_label_',\n            'text:axis_label_',\n        ]);\n        this.define({\n            bounds: [p.Any, 'auto'],\n            ticker: [p.Instance],\n            formatter: [p.Instance],\n            x_range_name: [p.String, 'default'],\n            y_range_name: [p.String, 'default'],\n            axis_label: [p.String, ''],\n            axis_label_standoff: [p.Int, 5],\n            major_label_standoff: [p.Int, 5],\n            major_label_orientation: [p.Any, \"horizontal\"],\n            major_label_overrides: [p.Any, {}],\n            major_tick_in: [p.Number, 2],\n            major_tick_out: [p.Number, 6],\n            minor_tick_in: [p.Number, 0],\n            minor_tick_out: [p.Number, 4],\n            fixed_location: [p.Any, null],\n        });\n        this.override({\n            axis_line_color: 'black',\n            major_tick_line_color: 'black',\n            minor_tick_line_color: 'black',\n            major_label_text_font_size: \"11px\",\n            major_label_text_align: \"center\",\n            major_label_text_baseline: \"alphabetic\",\n            axis_label_text_font_size: \"13px\",\n            axis_label_text_font_style: \"italic\",\n        });\n    }\n}\nAxis.__name__ = \"Axis\";\nAxis.init_Axis();\n//# sourceMappingURL=axis.js.map"]},"metadata":{},"sourceType":"module"}