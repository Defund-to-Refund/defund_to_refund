{"ast":null,"code":"import { sort_by } from \"./util/array\";\nimport { Selection } from \"../models/selections/selection\";\nexport function point_in_poly(x, y, px, py) {\n  let inside = false;\n  let x1 = px[px.length - 1];\n  let y1 = py[py.length - 1];\n\n  for (let i = 0; i < px.length; i++) {\n    const x2 = px[i];\n    const y2 = py[i];\n\n    if (y1 < y != y2 < y) {\n      if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) inside = !inside;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return inside;\n}\nexport function point_in_ellipse(x, y, angle, b, a, x0, y0) {\n  const A = (Math.cos(angle) / a) ** 2 + (Math.sin(angle) / b) ** 2;\n  const B = 2 * Math.cos(angle) * Math.sin(angle) * ((1 / a) ** 2 - (1 / b) ** 2);\n  const C = (Math.cos(angle) / b) ** 2 + (Math.sin(angle) / a) ** 2;\n  const eqn = A * (x - x0) ** 2 + B * (x - x0) * (y - y0) + C * (y - y0) ** 2;\n  const inside = eqn <= 1;\n  return inside;\n}\nexport function create_empty_hit_test_result() {\n  return new Selection();\n}\nexport function create_hit_test_result_from_hits(hits) {\n  const result = new Selection();\n  result.indices = sort_by(hits, ([_i, dist]) => dist).map(([i, _dist]) => i);\n  return result;\n}\n\nfunction sqr(x) {\n  return x * x;\n}\n\nexport function dist_2_pts(p0, p1) {\n  return sqr(p0.x - p1.x) + sqr(p0.y - p1.y);\n}\nexport function dist_to_segment_squared(p, v, w) {\n  const l2 = dist_2_pts(v, w);\n  if (l2 == 0) return dist_2_pts(p, v);\n  const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n  if (t < 0) return dist_2_pts(p, v);\n  if (t > 1) return dist_2_pts(p, w);\n  const q = {\n    x: v.x + t * (w.x - v.x),\n    y: v.y + t * (w.y - v.y)\n  };\n  return dist_2_pts(p, q);\n}\nexport function dist_to_segment(p, v, w) {\n  return Math.sqrt(dist_to_segment_squared(p, v, w));\n}\nexport function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\n  /*\n   *  Check if 2 segments (l0 and l1) intersect. Returns a structure with\n   *  the following attributes:\n   *   * hit (boolean): whether the 2 segments intersect\n   *   * x (float): x coordinate of the intersection point\n   *   * y (float): y coordinate of the intersection point\n   */\n  const den = (l1_y1 - l1_y0) * (l0_x1 - l0_x0) - (l1_x1 - l1_x0) * (l0_y1 - l0_y0);\n\n  if (den == 0) {\n    return {\n      hit: false,\n      x: null,\n      y: null\n    };\n  } else {\n    let a = l0_y0 - l1_y0;\n    let b = l0_x0 - l1_x0;\n    const num1 = (l1_x1 - l1_x0) * a - (l1_y1 - l1_y0) * b;\n    const num2 = (l0_x1 - l0_x0) * a - (l0_y1 - l0_y0) * b;\n    a = num1 / den;\n    b = num2 / den;\n    const x = l0_x0 + a * (l0_x1 - l0_x0);\n    const y = l0_y0 + a * (l0_y1 - l0_y0);\n    return {\n      hit: a > 0 && a < 1 && b > 0 && b < 1,\n      x,\n      y\n    };\n  }\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/hittest.js"],"names":["sort_by","Selection","point_in_poly","x","y","px","py","inside","x1","length","y1","i","x2","y2","point_in_ellipse","angle","b","a","x0","y0","A","Math","cos","sin","B","C","eqn","create_empty_hit_test_result","create_hit_test_result_from_hits","hits","result","indices","_i","dist","map","_dist","sqr","dist_2_pts","p0","p1","dist_to_segment_squared","p","v","w","l2","t","q","dist_to_segment","sqrt","check_2_segments_intersect","l0_x0","l0_y0","l0_x1","l0_y1","l1_x0","l1_y0","l1_x1","l1_y1","den","hit","num1","num2"],"mappings":"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","sourcesContent":["import { sort_by } from \"./util/array\";\nimport { Selection } from \"../models/selections/selection\";\nexport function point_in_poly(x, y, px, py) {\n    let inside = false;\n    let x1 = px[px.length - 1];\n    let y1 = py[py.length - 1];\n    for (let i = 0; i < px.length; i++) {\n        const x2 = px[i];\n        const y2 = py[i];\n        if ((y1 < y) != (y2 < y)) {\n            if ((x1 + (y - y1) / (y2 - y1) * (x2 - x1)) < x)\n                inside = !inside;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return inside;\n}\nexport function point_in_ellipse(x, y, angle, b, a, x0, y0) {\n    const A = ((Math.cos(angle) / a) ** 2 + (Math.sin(angle) / b) ** 2);\n    const B = 2 * Math.cos(angle) * Math.sin(angle) * ((1 / a) ** 2 - (1 / b) ** 2);\n    const C = ((Math.cos(angle) / b) ** 2 + (Math.sin(angle) / a) ** 2);\n    const eqn = A * (x - x0) ** 2 + B * (x - x0) * (y - y0) + C * (y - y0) ** 2;\n    const inside = eqn <= 1;\n    return inside;\n}\nexport function create_empty_hit_test_result() {\n    return new Selection();\n}\nexport function create_hit_test_result_from_hits(hits) {\n    const result = new Selection();\n    result.indices = sort_by(hits, ([_i, dist]) => dist).map(([i, _dist]) => i);\n    return result;\n}\nfunction sqr(x) {\n    return x * x;\n}\nexport function dist_2_pts(p0, p1) {\n    return sqr(p0.x - p1.x) + sqr(p0.y - p1.y);\n}\nexport function dist_to_segment_squared(p, v, w) {\n    const l2 = dist_2_pts(v, w);\n    if (l2 == 0)\n        return dist_2_pts(p, v);\n    const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    if (t < 0)\n        return dist_2_pts(p, v);\n    if (t > 1)\n        return dist_2_pts(p, w);\n    const q = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };\n    return dist_2_pts(p, q);\n}\nexport function dist_to_segment(p, v, w) {\n    return Math.sqrt(dist_to_segment_squared(p, v, w));\n}\nexport function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\n    /*\n     *  Check if 2 segments (l0 and l1) intersect. Returns a structure with\n     *  the following attributes:\n     *   * hit (boolean): whether the 2 segments intersect\n     *   * x (float): x coordinate of the intersection point\n     *   * y (float): y coordinate of the intersection point\n     */\n    const den = ((l1_y1 - l1_y0) * (l0_x1 - l0_x0)) - ((l1_x1 - l1_x0) * (l0_y1 - l0_y0));\n    if (den == 0) {\n        return { hit: false, x: null, y: null };\n    }\n    else {\n        let a = l0_y0 - l1_y0;\n        let b = l0_x0 - l1_x0;\n        const num1 = ((l1_x1 - l1_x0) * a) - ((l1_y1 - l1_y0) * b);\n        const num2 = ((l0_x1 - l0_x0) * a) - ((l0_y1 - l0_y0) * b);\n        a = num1 / den;\n        b = num2 / den;\n        const x = l0_x0 + (a * (l0_x1 - l0_x0));\n        const y = l0_y0 + (a * (l0_y1 - l0_y0));\n        return { hit: (a > 0 && a < 1) && (b > 0 && b < 1), x, y };\n    }\n}\n//# sourceMappingURL=hittest.js.map"]},"metadata":{},"sourceType":"module"}