{"ast":null,"code":"import { difference, copy, min } from \"./array\";\nimport { isEqual } from \"./eq\";\nimport { isArray } from \"./types\";\nexport class MultiDict {\n  constructor() {\n    this._dict = {};\n  }\n\n  _existing(key) {\n    if (key in this._dict) return this._dict[key];else return null;\n  }\n\n  add_value(key, value) {\n    /*\n    if value == null\n      throw new Error(\"Can't put null in this dict\")\n    if isArray(value)\n      throw new Error(\"Can't put arrays in this dict\")\n    */\n    const existing = this._existing(key);\n\n    if (existing == null) {\n      this._dict[key] = value;\n    } else if (isArray(existing)) {\n      existing.push(value);\n    } else {\n      this._dict[key] = [existing, value];\n    }\n  }\n\n  remove_value(key, value) {\n    const existing = this._existing(key);\n\n    if (isArray(existing)) {\n      const new_array = difference(existing, [value]);\n      if (new_array.length > 0) this._dict[key] = new_array;else delete this._dict[key];\n    } else if (isEqual(existing, value)) {\n      delete this._dict[key];\n    }\n  }\n\n  get_one(key, duplicate_error) {\n    const existing = this._existing(key);\n\n    if (isArray(existing)) {\n      if (existing.length === 1) return existing[0];else throw new Error(duplicate_error);\n    } else return existing;\n  }\n\n}\nMultiDict.__name__ = \"MultiDict\";\nexport class Set {\n  constructor(obj) {\n    if (obj == null) this._values = [];else if (obj instanceof Set) this._values = copy(obj._values);else {\n      this._values = [];\n\n      for (const item of obj) this.add(item);\n    }\n  }\n\n  get values() {\n    return copy(this._values).sort();\n  }\n\n  toString() {\n    return `Set([${this.values.join(\",\")}])`;\n  }\n\n  get size() {\n    return this._values.length;\n  }\n\n  has(item) {\n    return this._values.indexOf(item) !== -1;\n  }\n\n  add(item) {\n    if (!this.has(item)) this._values.push(item);\n  }\n\n  remove(item) {\n    const i = this._values.indexOf(item);\n\n    if (i !== -1) this._values.splice(i, 1);\n  }\n\n  toggle(item) {\n    const i = this._values.indexOf(item);\n\n    if (i === -1) this._values.push(item);else this._values.splice(i, 1);\n  }\n\n  clear() {\n    this._values = [];\n  }\n\n  union(input) {\n    input = new Set(input);\n    return new Set(this._values.concat(input._values));\n  }\n\n  intersect(input) {\n    input = new Set(input);\n    const output = new Set();\n\n    for (const item of input._values) {\n      if (this.has(item) && input.has(item)) output.add(item);\n    }\n\n    return output;\n  }\n\n  diff(input) {\n    input = new Set(input);\n    const output = new Set();\n\n    for (const item of this._values) {\n      if (!input.has(item)) output.add(item);\n    }\n\n    return output;\n  }\n\n  forEach(fn, thisArg) {\n    for (const value of this._values) {\n      fn.call(thisArg || this, value, value, this);\n    }\n  }\n\n}\nSet.__name__ = \"Set\";\nexport class Matrix {\n  constructor(nrows, ncols, init) {\n    this.nrows = nrows;\n    this.ncols = ncols;\n    this._matrix = new Array(nrows);\n\n    for (let y = 0; y < nrows; y++) {\n      this._matrix[y] = new Array(ncols);\n\n      for (let x = 0; x < ncols; x++) {\n        this._matrix[y][x] = init(y, x);\n      }\n    }\n  }\n\n  at(row, col) {\n    return this._matrix[row][col];\n  }\n\n  map(fn) {\n    return new Matrix(this.nrows, this.ncols, (row, col) => fn(this.at(row, col), row, col));\n  }\n\n  apply(obj) {\n    const fn = Matrix.from(obj);\n    const {\n      nrows,\n      ncols\n    } = this;\n    if (nrows == fn.nrows && ncols == fn.ncols) return new Matrix(nrows, ncols, (row, col) => fn.at(row, col)(this.at(row, col), row, col));else throw new Error(\"dimensions don't match\");\n  }\n\n  to_sparse() {\n    const items = [];\n\n    for (let y = 0; y < this.nrows; y++) {\n      for (let x = 0; x < this.ncols; x++) {\n        const value = this._matrix[y][x];\n        items.push([value, y, x]);\n      }\n    }\n\n    return items;\n  }\n\n  static from(obj) {\n    if (obj instanceof Matrix) return obj;else {\n      const nrows = obj.length;\n      const ncols = min(obj.map(row => row.length));\n      return new Matrix(nrows, ncols, (row, col) => obj[row][col]);\n    }\n  }\n\n}\nMatrix.__name__ = \"Matrix\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/data_structures.js"],"names":["difference","copy","min","isEqual","isArray","MultiDict","constructor","_dict","_existing","key","add_value","value","existing","push","remove_value","new_array","length","get_one","duplicate_error","Error","__name__","Set","obj","_values","item","add","values","sort","toString","join","size","has","indexOf","remove","i","splice","toggle","clear","union","input","concat","intersect","output","diff","forEach","fn","thisArg","call","Matrix","nrows","ncols","init","_matrix","Array","y","x","at","row","col","map","apply","from","to_sparse","items"],"mappings":"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","sourcesContent":["import { difference, copy, min } from \"./array\";\nimport { isEqual } from \"./eq\";\nimport { isArray } from \"./types\";\nexport class MultiDict {\n    constructor() {\n        this._dict = {};\n    }\n    _existing(key) {\n        if (key in this._dict)\n            return this._dict[key];\n        else\n            return null;\n    }\n    add_value(key, value) {\n        /*\n        if value == null\n          throw new Error(\"Can't put null in this dict\")\n        if isArray(value)\n          throw new Error(\"Can't put arrays in this dict\")\n        */\n        const existing = this._existing(key);\n        if (existing == null) {\n            this._dict[key] = value;\n        }\n        else if (isArray(existing)) {\n            existing.push(value);\n        }\n        else {\n            this._dict[key] = [existing, value];\n        }\n    }\n    remove_value(key, value) {\n        const existing = this._existing(key);\n        if (isArray(existing)) {\n            const new_array = difference(existing, [value]);\n            if (new_array.length > 0)\n                this._dict[key] = new_array;\n            else\n                delete this._dict[key];\n        }\n        else if (isEqual(existing, value)) {\n            delete this._dict[key];\n        }\n    }\n    get_one(key, duplicate_error) {\n        const existing = this._existing(key);\n        if (isArray(existing)) {\n            if (existing.length === 1)\n                return existing[0];\n            else\n                throw new Error(duplicate_error);\n        }\n        else\n            return existing;\n    }\n}\nMultiDict.__name__ = \"MultiDict\";\nexport class Set {\n    constructor(obj) {\n        if (obj == null)\n            this._values = [];\n        else if (obj instanceof Set)\n            this._values = copy(obj._values);\n        else {\n            this._values = [];\n            for (const item of obj)\n                this.add(item);\n        }\n    }\n    get values() {\n        return copy(this._values).sort();\n    }\n    toString() {\n        return `Set([${this.values.join(\",\")}])`;\n    }\n    get size() {\n        return this._values.length;\n    }\n    has(item) {\n        return this._values.indexOf(item) !== -1;\n    }\n    add(item) {\n        if (!this.has(item))\n            this._values.push(item);\n    }\n    remove(item) {\n        const i = this._values.indexOf(item);\n        if (i !== -1)\n            this._values.splice(i, 1);\n    }\n    toggle(item) {\n        const i = this._values.indexOf(item);\n        if (i === -1)\n            this._values.push(item);\n        else\n            this._values.splice(i, 1);\n    }\n    clear() {\n        this._values = [];\n    }\n    union(input) {\n        input = new Set(input);\n        return new Set(this._values.concat(input._values));\n    }\n    intersect(input) {\n        input = new Set(input);\n        const output = new Set();\n        for (const item of input._values) {\n            if (this.has(item) && input.has(item))\n                output.add(item);\n        }\n        return output;\n    }\n    diff(input) {\n        input = new Set(input);\n        const output = new Set();\n        for (const item of this._values) {\n            if (!input.has(item))\n                output.add(item);\n        }\n        return output;\n    }\n    forEach(fn, thisArg) {\n        for (const value of this._values) {\n            fn.call(thisArg || this, value, value, this);\n        }\n    }\n}\nSet.__name__ = \"Set\";\nexport class Matrix {\n    constructor(nrows, ncols, init) {\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this._matrix = new Array(nrows);\n        for (let y = 0; y < nrows; y++) {\n            this._matrix[y] = new Array(ncols);\n            for (let x = 0; x < ncols; x++) {\n                this._matrix[y][x] = init(y, x);\n            }\n        }\n    }\n    at(row, col) {\n        return this._matrix[row][col];\n    }\n    map(fn) {\n        return new Matrix(this.nrows, this.ncols, (row, col) => fn(this.at(row, col), row, col));\n    }\n    apply(obj) {\n        const fn = Matrix.from(obj);\n        const { nrows, ncols } = this;\n        if (nrows == fn.nrows && ncols == fn.ncols)\n            return new Matrix(nrows, ncols, (row, col) => fn.at(row, col)(this.at(row, col), row, col));\n        else\n            throw new Error(\"dimensions don't match\");\n    }\n    to_sparse() {\n        const items = [];\n        for (let y = 0; y < this.nrows; y++) {\n            for (let x = 0; x < this.ncols; x++) {\n                const value = this._matrix[y][x];\n                items.push([value, y, x]);\n            }\n        }\n        return items;\n    }\n    static from(obj) {\n        if (obj instanceof Matrix)\n            return obj;\n        else {\n            const nrows = obj.length;\n            const ncols = min(obj.map((row) => row.length));\n            return new Matrix(nrows, ncols, (row, col) => obj[row][col]);\n        }\n    }\n}\nMatrix.__name__ = \"Matrix\";\n//# sourceMappingURL=data_structures.js.map"]},"metadata":{},"sourceType":"module"}