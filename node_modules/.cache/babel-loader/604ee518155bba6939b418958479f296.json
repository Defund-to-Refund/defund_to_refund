{"ast":null,"code":"import { TileSource } from \"./tile_source\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { meters_extent_to_geographic } from \"./tile_utils\";\nexport class MercatorTileSource extends TileSource {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_MercatorTileSource() {\n    this.define({\n      snap_to_zoom: [p.Boolean, false],\n      wrap_around: [p.Boolean, true]\n    });\n    this.override({\n      x_origin_offset: 20037508.34,\n      y_origin_offset: 20037508.34,\n      initial_resolution: 156543.03392804097\n    });\n  }\n\n  initialize() {\n    super.initialize();\n    this._resolutions = range(this.min_zoom, this.max_zoom + 1).map(z => this.get_resolution(z));\n  }\n\n  _computed_initial_resolution() {\n    if (this.initial_resolution != null) return this.initial_resolution;else {\n      // TODO testing 2015-11-17, if this codepath is used it seems\n      // to use 100% cpu and wedge Chrome\n      return 2 * Math.PI * 6378137 / this.tile_size;\n    }\n  }\n\n  is_valid_tile(x, y, z) {\n    if (!this.wrap_around) {\n      if (x < 0 || x >= 2 ** z) return false;\n    }\n\n    if (y < 0 || y >= 2 ** z) return false;\n    return true;\n  }\n\n  parent_by_tile_xyz(x, y, z) {\n    const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n    const parent_quadkey = quadkey.substring(0, quadkey.length - 1);\n    return this.quadkey_to_tile_xyz(parent_quadkey);\n  }\n\n  get_resolution(level) {\n    return this._computed_initial_resolution() / 2 ** level;\n  }\n\n  get_resolution_by_extent(extent, height, width) {\n    const x_rs = (extent[2] - extent[0]) / width;\n    const y_rs = (extent[3] - extent[1]) / height;\n    return [x_rs, y_rs];\n  }\n\n  get_level_by_extent(extent, height, width) {\n    const x_rs = (extent[2] - extent[0]) / width;\n    const y_rs = (extent[3] - extent[1]) / height;\n    const resolution = Math.max(x_rs, y_rs);\n    let i = 0;\n\n    for (const r of this._resolutions) {\n      if (resolution > r) {\n        if (i == 0) return 0;\n        if (i > 0) return i - 1;\n      }\n\n      i += 1;\n    } // otherwise return the highest available resolution\n\n\n    return i - 1;\n  }\n\n  get_closest_level_by_extent(extent, height, width) {\n    const x_rs = (extent[2] - extent[0]) / width;\n    const y_rs = (extent[3] - extent[1]) / height;\n    const resolution = Math.max(x_rs, y_rs);\n\n    const closest = this._resolutions.reduce(function (previous, current) {\n      if (Math.abs(current - resolution) < Math.abs(previous - resolution)) return current;else return previous;\n    });\n\n    return this._resolutions.indexOf(closest);\n  }\n\n  snap_to_zoom_level(extent, height, width, level) {\n    const [xmin, ymin, xmax, ymax] = extent;\n    const desired_res = this._resolutions[level];\n    let desired_x_delta = width * desired_res;\n    let desired_y_delta = height * desired_res;\n\n    if (!this.snap_to_zoom) {\n      const xscale = (xmax - xmin) / desired_x_delta;\n      const yscale = (ymax - ymin) / desired_y_delta;\n\n      if (xscale > yscale) {\n        desired_x_delta = xmax - xmin;\n        desired_y_delta = desired_y_delta * xscale;\n      } else {\n        desired_x_delta = desired_x_delta * yscale;\n        desired_y_delta = ymax - ymin;\n      }\n    }\n\n    const x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\n    const y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\n    return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\n  }\n\n  tms_to_wmts(x, y, z) {\n    // Note this works both ways\n    return [x, 2 ** z - 1 - y, z];\n  }\n\n  wmts_to_tms(x, y, z) {\n    // Note this works both ways\n    return [x, 2 ** z - 1 - y, z];\n  }\n\n  pixels_to_meters(px, py, level) {\n    const res = this.get_resolution(level);\n    const mx = px * res - this.x_origin_offset;\n    const my = py * res - this.y_origin_offset;\n    return [mx, my];\n  }\n\n  meters_to_pixels(mx, my, level) {\n    const res = this.get_resolution(level);\n    const px = (mx + this.x_origin_offset) / res;\n    const py = (my + this.y_origin_offset) / res;\n    return [px, py];\n  }\n\n  pixels_to_tile(px, py) {\n    let tx = Math.ceil(px / this.tile_size);\n    tx = tx === 0 ? tx : tx - 1;\n    const ty = Math.max(Math.ceil(py / this.tile_size) - 1, 0);\n    return [tx, ty];\n  }\n\n  pixels_to_raster(px, py, level) {\n    const mapSize = this.tile_size << level;\n    return [px, mapSize - py];\n  }\n\n  meters_to_tile(mx, my, level) {\n    const [px, py] = this.meters_to_pixels(mx, my, level);\n    return this.pixels_to_tile(px, py);\n  }\n\n  get_tile_meter_bounds(tx, ty, level) {\n    // expects tms styles coordinates (bottom-left origin)\n    const [xmin, ymin] = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level);\n    const [xmax, ymax] = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level);\n    return [xmin, ymin, xmax, ymax];\n  }\n\n  get_tile_geographic_bounds(tx, ty, level) {\n    const bounds = this.get_tile_meter_bounds(tx, ty, level);\n    const [minLon, minLat, maxLon, maxLat] = meters_extent_to_geographic(bounds);\n    return [minLon, minLat, maxLon, maxLat];\n  }\n\n  get_tiles_by_extent(extent, level, tile_border = 1) {\n    // unpack extent and convert to tile coordinates\n    const [xmin, ymin, xmax, ymax] = extent;\n    let [txmin, tymin] = this.meters_to_tile(xmin, ymin, level);\n    let [txmax, tymax] = this.meters_to_tile(xmax, ymax, level); // add tiles which border\n\n    txmin -= tile_border;\n    tymin -= tile_border;\n    txmax += tile_border;\n    tymax += tile_border;\n    const tiles = [];\n\n    for (let ty = tymax; ty >= tymin; ty--) {\n      for (let tx = txmin; tx <= txmax; tx++) {\n        if (this.is_valid_tile(tx, ty, level)) tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\n      }\n    }\n\n    this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\n    return tiles;\n  }\n\n  quadkey_to_tile_xyz(quadKey) {\n    /**\n     * Computes tile x, y and z values based on quadKey.\n     */\n    let tileX = 0;\n    let tileY = 0;\n    const tileZ = quadKey.length;\n\n    for (let i = tileZ; i > 0; i--) {\n      const value = quadKey.charAt(tileZ - i);\n      const mask = 1 << i - 1;\n\n      switch (value) {\n        case '0':\n          continue;\n\n        case '1':\n          tileX |= mask;\n          break;\n\n        case '2':\n          tileY |= mask;\n          break;\n\n        case '3':\n          tileX |= mask;\n          tileY |= mask;\n          break;\n\n        default:\n          throw new TypeError(`Invalid Quadkey: ${quadKey}`);\n      }\n    }\n\n    return [tileX, tileY, tileZ];\n  }\n\n  tile_xyz_to_quadkey(x, y, z) {\n    /*\n     * Computes quadkey value based on tile x, y and z values.\n     */\n    let quadkey = \"\";\n\n    for (let i = z; i > 0; i--) {\n      const mask = 1 << i - 1;\n      let digit = 0;\n\n      if ((x & mask) !== 0) {\n        digit += 1;\n      }\n\n      if ((y & mask) !== 0) {\n        digit += 2;\n      }\n\n      quadkey += digit.toString();\n    }\n\n    return quadkey;\n  }\n\n  children_by_tile_xyz(x, y, z) {\n    const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n    const child_tile_xyz = [];\n\n    for (let i = 0; i <= 3; i++) {\n      const [x, y, z] = this.quadkey_to_tile_xyz(quadkey + i.toString());\n      const b = this.get_tile_meter_bounds(x, y, z);\n      child_tile_xyz.push([x, y, z, b]);\n    }\n\n    return child_tile_xyz;\n  }\n\n  get_closest_parent_by_tile_xyz(x, y, z) {\n    const world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n    [x, y, z] = this.normalize_xyz(x, y, z);\n    let quadkey = this.tile_xyz_to_quadkey(x, y, z);\n\n    while (quadkey.length > 0) {\n      quadkey = quadkey.substring(0, quadkey.length - 1);\n      [x, y, z] = this.quadkey_to_tile_xyz(quadkey);\n      [x, y, z] = this.denormalize_xyz(x, y, z, world_x);\n      if (this.tiles.has(this.tile_xyz_to_key(x, y, z))) return [x, y, z];\n    }\n\n    return [0, 0, 0];\n  }\n\n  normalize_xyz(x, y, z) {\n    if (this.wrap_around) {\n      const tile_count = 2 ** z;\n      return [(x % tile_count + tile_count) % tile_count, y, z];\n    } else {\n      return [x, y, z];\n    }\n  }\n\n  denormalize_xyz(x, y, z, world_x) {\n    return [x + world_x * 2 ** z, y, z];\n  }\n\n  denormalize_meters(meters_x, meters_y, _level, world_x) {\n    return [meters_x + world_x * 2 * Math.PI * 6378137, meters_y];\n  }\n\n  calculate_world_x_by_tile_xyz(x, _y, z) {\n    return Math.floor(x / 2 ** z);\n  }\n\n}\nMercatorTileSource.__name__ = \"MercatorTileSource\";\nMercatorTileSource.init_MercatorTileSource();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/mercator_tile_source.js"],"names":["TileSource","p","range","meters_extent_to_geographic","MercatorTileSource","constructor","attrs","init_MercatorTileSource","define","snap_to_zoom","Boolean","wrap_around","override","x_origin_offset","y_origin_offset","initial_resolution","initialize","_resolutions","min_zoom","max_zoom","map","z","get_resolution","_computed_initial_resolution","Math","PI","tile_size","is_valid_tile","x","y","parent_by_tile_xyz","quadkey","tile_xyz_to_quadkey","parent_quadkey","substring","length","quadkey_to_tile_xyz","level","get_resolution_by_extent","extent","height","width","x_rs","y_rs","get_level_by_extent","resolution","max","i","r","get_closest_level_by_extent","closest","reduce","previous","current","abs","indexOf","snap_to_zoom_level","xmin","ymin","xmax","ymax","desired_res","desired_x_delta","desired_y_delta","xscale","yscale","x_adjust","y_adjust","tms_to_wmts","wmts_to_tms","pixels_to_meters","px","py","res","mx","my","meters_to_pixels","pixels_to_tile","tx","ceil","ty","pixels_to_raster","mapSize","meters_to_tile","get_tile_meter_bounds","get_tile_geographic_bounds","bounds","minLon","minLat","maxLon","maxLat","get_tiles_by_extent","tile_border","txmin","tymin","txmax","tymax","tiles","push","sort_tiles_from_center","quadKey","tileX","tileY","tileZ","value","charAt","mask","TypeError","digit","toString","children_by_tile_xyz","child_tile_xyz","b","get_closest_parent_by_tile_xyz","world_x","calculate_world_x_by_tile_xyz","normalize_xyz","denormalize_xyz","has","tile_xyz_to_key","tile_count","denormalize_meters","meters_x","meters_y","_level","_y","floor","__name__"],"mappings":"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","sourcesContent":["import { TileSource } from \"./tile_source\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { meters_extent_to_geographic } from \"./tile_utils\";\nexport class MercatorTileSource extends TileSource {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_MercatorTileSource() {\n        this.define({\n            snap_to_zoom: [p.Boolean, false],\n            wrap_around: [p.Boolean, true],\n        });\n        this.override({\n            x_origin_offset: 20037508.34,\n            y_origin_offset: 20037508.34,\n            initial_resolution: 156543.03392804097,\n        });\n    }\n    initialize() {\n        super.initialize();\n        this._resolutions = range(this.min_zoom, this.max_zoom + 1).map((z) => this.get_resolution(z));\n    }\n    _computed_initial_resolution() {\n        if (this.initial_resolution != null)\n            return this.initial_resolution;\n        else {\n            // TODO testing 2015-11-17, if this codepath is used it seems\n            // to use 100% cpu and wedge Chrome\n            return (2 * Math.PI * 6378137) / this.tile_size;\n        }\n    }\n    is_valid_tile(x, y, z) {\n        if (!this.wrap_around) {\n            if (x < 0 || x >= 2 ** z)\n                return false;\n        }\n        if (y < 0 || y >= 2 ** z)\n            return false;\n        return true;\n    }\n    parent_by_tile_xyz(x, y, z) {\n        const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n        const parent_quadkey = quadkey.substring(0, quadkey.length - 1);\n        return this.quadkey_to_tile_xyz(parent_quadkey);\n    }\n    get_resolution(level) {\n        return this._computed_initial_resolution() / 2 ** level;\n    }\n    get_resolution_by_extent(extent, height, width) {\n        const x_rs = (extent[2] - extent[0]) / width;\n        const y_rs = (extent[3] - extent[1]) / height;\n        return [x_rs, y_rs];\n    }\n    get_level_by_extent(extent, height, width) {\n        const x_rs = (extent[2] - extent[0]) / width;\n        const y_rs = (extent[3] - extent[1]) / height;\n        const resolution = Math.max(x_rs, y_rs);\n        let i = 0;\n        for (const r of this._resolutions) {\n            if (resolution > r) {\n                if (i == 0)\n                    return 0;\n                if (i > 0)\n                    return i - 1;\n            }\n            i += 1;\n        }\n        // otherwise return the highest available resolution\n        return (i - 1);\n    }\n    get_closest_level_by_extent(extent, height, width) {\n        const x_rs = (extent[2] - extent[0]) / width;\n        const y_rs = (extent[3] - extent[1]) / height;\n        const resolution = Math.max(x_rs, y_rs);\n        const closest = this._resolutions.reduce(function (previous, current) {\n            if (Math.abs(current - resolution) < Math.abs(previous - resolution))\n                return current;\n            else\n                return previous;\n        });\n        return this._resolutions.indexOf(closest);\n    }\n    snap_to_zoom_level(extent, height, width, level) {\n        const [xmin, ymin, xmax, ymax] = extent;\n        const desired_res = this._resolutions[level];\n        let desired_x_delta = width * desired_res;\n        let desired_y_delta = height * desired_res;\n        if (!this.snap_to_zoom) {\n            const xscale = (xmax - xmin) / desired_x_delta;\n            const yscale = (ymax - ymin) / desired_y_delta;\n            if (xscale > yscale) {\n                desired_x_delta = (xmax - xmin);\n                desired_y_delta = desired_y_delta * xscale;\n            }\n            else {\n                desired_x_delta = desired_x_delta * yscale;\n                desired_y_delta = (ymax - ymin);\n            }\n        }\n        const x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\n        const y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\n        return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\n    }\n    tms_to_wmts(x, y, z) {\n        // Note this works both ways\n        return [x, 2 ** z - 1 - y, z];\n    }\n    wmts_to_tms(x, y, z) {\n        // Note this works both ways\n        return [x, 2 ** z - 1 - y, z];\n    }\n    pixels_to_meters(px, py, level) {\n        const res = this.get_resolution(level);\n        const mx = (px * res) - this.x_origin_offset;\n        const my = (py * res) - this.y_origin_offset;\n        return [mx, my];\n    }\n    meters_to_pixels(mx, my, level) {\n        const res = this.get_resolution(level);\n        const px = (mx + this.x_origin_offset) / res;\n        const py = (my + this.y_origin_offset) / res;\n        return [px, py];\n    }\n    pixels_to_tile(px, py) {\n        let tx = Math.ceil(px / this.tile_size);\n        tx = tx === 0 ? tx : tx - 1;\n        const ty = Math.max(Math.ceil(py / this.tile_size) - 1, 0);\n        return [tx, ty];\n    }\n    pixels_to_raster(px, py, level) {\n        const mapSize = this.tile_size << level;\n        return [px, mapSize - py];\n    }\n    meters_to_tile(mx, my, level) {\n        const [px, py] = this.meters_to_pixels(mx, my, level);\n        return this.pixels_to_tile(px, py);\n    }\n    get_tile_meter_bounds(tx, ty, level) {\n        // expects tms styles coordinates (bottom-left origin)\n        const [xmin, ymin] = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level);\n        const [xmax, ymax] = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level);\n        return [xmin, ymin, xmax, ymax];\n    }\n    get_tile_geographic_bounds(tx, ty, level) {\n        const bounds = this.get_tile_meter_bounds(tx, ty, level);\n        const [minLon, minLat, maxLon, maxLat] = meters_extent_to_geographic(bounds);\n        return [minLon, minLat, maxLon, maxLat];\n    }\n    get_tiles_by_extent(extent, level, tile_border = 1) {\n        // unpack extent and convert to tile coordinates\n        const [xmin, ymin, xmax, ymax] = extent;\n        let [txmin, tymin] = this.meters_to_tile(xmin, ymin, level);\n        let [txmax, tymax] = this.meters_to_tile(xmax, ymax, level);\n        // add tiles which border\n        txmin -= tile_border;\n        tymin -= tile_border;\n        txmax += tile_border;\n        tymax += tile_border;\n        const tiles = [];\n        for (let ty = tymax; ty >= tymin; ty--) {\n            for (let tx = txmin; tx <= txmax; tx++) {\n                if (this.is_valid_tile(tx, ty, level))\n                    tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\n            }\n        }\n        this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\n        return tiles;\n    }\n    quadkey_to_tile_xyz(quadKey) {\n        /**\n         * Computes tile x, y and z values based on quadKey.\n         */\n        let tileX = 0;\n        let tileY = 0;\n        const tileZ = quadKey.length;\n        for (let i = tileZ; i > 0; i--) {\n            const value = quadKey.charAt(tileZ - i);\n            const mask = 1 << (i - 1);\n            switch (value) {\n                case '0':\n                    continue;\n                case '1':\n                    tileX |= mask;\n                    break;\n                case '2':\n                    tileY |= mask;\n                    break;\n                case '3':\n                    tileX |= mask;\n                    tileY |= mask;\n                    break;\n                default:\n                    throw new TypeError(`Invalid Quadkey: ${quadKey}`);\n            }\n        }\n        return [tileX, tileY, tileZ];\n    }\n    tile_xyz_to_quadkey(x, y, z) {\n        /*\n         * Computes quadkey value based on tile x, y and z values.\n         */\n        let quadkey = \"\";\n        for (let i = z; i > 0; i--) {\n            const mask = 1 << (i - 1);\n            let digit = 0;\n            if ((x & mask) !== 0) {\n                digit += 1;\n            }\n            if ((y & mask) !== 0) {\n                digit += 2;\n            }\n            quadkey += digit.toString();\n        }\n        return quadkey;\n    }\n    children_by_tile_xyz(x, y, z) {\n        const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n        const child_tile_xyz = [];\n        for (let i = 0; i <= 3; i++) {\n            const [x, y, z] = this.quadkey_to_tile_xyz(quadkey + i.toString());\n            const b = this.get_tile_meter_bounds(x, y, z);\n            child_tile_xyz.push([x, y, z, b]);\n        }\n        return child_tile_xyz;\n    }\n    get_closest_parent_by_tile_xyz(x, y, z) {\n        const world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n        [x, y, z] = this.normalize_xyz(x, y, z);\n        let quadkey = this.tile_xyz_to_quadkey(x, y, z);\n        while (quadkey.length > 0) {\n            quadkey = quadkey.substring(0, quadkey.length - 1);\n            [x, y, z] = this.quadkey_to_tile_xyz(quadkey);\n            [x, y, z] = this.denormalize_xyz(x, y, z, world_x);\n            if (this.tiles.has(this.tile_xyz_to_key(x, y, z)))\n                return [x, y, z];\n        }\n        return [0, 0, 0];\n    }\n    normalize_xyz(x, y, z) {\n        if (this.wrap_around) {\n            const tile_count = 2 ** z;\n            return [((x % tile_count) + tile_count) % tile_count, y, z];\n        }\n        else {\n            return [x, y, z];\n        }\n    }\n    denormalize_xyz(x, y, z, world_x) {\n        return [x + (world_x * 2 ** z), y, z];\n    }\n    denormalize_meters(meters_x, meters_y, _level, world_x) {\n        return [meters_x + (world_x * 2 * Math.PI * 6378137), meters_y];\n    }\n    calculate_world_x_by_tile_xyz(x, _y, z) {\n        return Math.floor(x / 2 ** z);\n    }\n}\nMercatorTileSource.__name__ = \"MercatorTileSource\";\nMercatorTileSource.init_MercatorTileSource();\n//# sourceMappingURL=mercator_tile_source.js.map"]},"metadata":{},"sourceType":"module"}