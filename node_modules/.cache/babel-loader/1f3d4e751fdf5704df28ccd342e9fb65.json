{"ast":null,"code":"import { Model } from \"../../model\";\nimport { indexOf } from \"../../core/util/arrayable\";\nimport { contains, uniq } from \"../../core/util/array\";\nimport { create_empty_hit_test_result } from \"../../core/hittest\";\nexport class GraphHitTestPolicy extends Model {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  _hit_test_nodes(geometry, graph_view) {\n    if (!graph_view.model.visible) return null;\n    const hit_test_result = graph_view.node_view.glyph.hit_test(geometry);\n    if (hit_test_result == null) return null;else return graph_view.node_view.model.view.convert_selection_from_subset(hit_test_result);\n  }\n\n  _hit_test_edges(geometry, graph_view) {\n    if (!graph_view.model.visible) return null;\n    const hit_test_result = graph_view.edge_view.glyph.hit_test(geometry);\n    if (hit_test_result == null) return null;else return graph_view.edge_view.model.view.convert_selection_from_subset(hit_test_result);\n  }\n\n}\nGraphHitTestPolicy.__name__ = \"GraphHitTestPolicy\";\nexport class NodesOnly extends GraphHitTestPolicy {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  hit_test(geometry, graph_view) {\n    return this._hit_test_nodes(geometry, graph_view);\n  }\n\n  do_selection(hit_test_result, graph, final, append) {\n    if (hit_test_result == null) return false;\n    const node_selection = graph.node_renderer.data_source.selected;\n    node_selection.update(hit_test_result, final, append);\n\n    graph.node_renderer.data_source._select.emit();\n\n    return !node_selection.is_empty();\n  }\n\n  do_inspection(hit_test_result, geometry, graph_view, final, append) {\n    if (hit_test_result == null) return false;\n    const node_inspection = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);\n    node_inspection.update(hit_test_result, final, append); // silently set inspected attr to avoid triggering data_source.change event and rerender\n\n    graph_view.node_view.model.data_source.setv({\n      inspected: node_inspection\n    }, {\n      silent: true\n    });\n    graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, {\n      geometry\n    }]);\n    return !node_inspection.is_empty();\n  }\n\n}\nNodesOnly.__name__ = \"NodesOnly\";\nexport class NodesAndLinkedEdges extends GraphHitTestPolicy {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  hit_test(geometry, graph_view) {\n    return this._hit_test_nodes(geometry, graph_view);\n  }\n\n  get_linked_edges(node_source, edge_source, mode) {\n    let node_indices = [];\n\n    if (mode == 'selection') {\n      node_indices = node_source.selected.indices.map(i => node_source.data.index[i]);\n    } else if (mode == 'inspection') {\n      node_indices = node_source.inspected.indices.map(i => node_source.data.index[i]);\n    }\n\n    const edge_indices = [];\n\n    for (let i = 0; i < edge_source.data.start.length; i++) {\n      if (contains(node_indices, edge_source.data.start[i]) || contains(node_indices, edge_source.data.end[i])) edge_indices.push(i);\n    }\n\n    const linked_edges = create_empty_hit_test_result();\n\n    for (const i of edge_indices) {\n      linked_edges.multiline_indices[i] = [0]; //currently only supports 2-element multilines, so this is all of it\n    }\n\n    linked_edges.indices = edge_indices;\n    return linked_edges;\n  }\n\n  do_selection(hit_test_result, graph, final, append) {\n    if (hit_test_result == null) return false;\n    const node_selection = graph.node_renderer.data_source.selected;\n    node_selection.update(hit_test_result, final, append);\n    const edge_selection = graph.edge_renderer.data_source.selected;\n    const linked_edges_selection = this.get_linked_edges(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n    edge_selection.update(linked_edges_selection, final, append);\n\n    graph.node_renderer.data_source._select.emit();\n\n    return !node_selection.is_empty();\n  }\n\n  do_inspection(hit_test_result, geometry, graph_view, final, append) {\n    if (hit_test_result == null) return false;\n    const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n    node_inspection.update(hit_test_result, final, append);\n    graph_view.node_view.model.data_source.setv({\n      inspected: node_inspection\n    }, {\n      silent: true\n    });\n    const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n    const linked_edges = this.get_linked_edges(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n    edge_inspection.update(linked_edges, final, append); //silently set inspected attr to avoid triggering data_source.change event and rerender\n\n    graph_view.edge_view.model.data_source.setv({\n      inspected: edge_inspection\n    }, {\n      silent: true\n    });\n    graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, {\n      geometry\n    }]);\n    return !node_inspection.is_empty();\n  }\n\n}\nNodesAndLinkedEdges.__name__ = \"NodesAndLinkedEdges\";\nexport class EdgesAndLinkedNodes extends GraphHitTestPolicy {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  hit_test(geometry, graph_view) {\n    return this._hit_test_edges(geometry, graph_view);\n  }\n\n  get_linked_nodes(node_source, edge_source, mode) {\n    let edge_indices = [];\n    if (mode == 'selection') edge_indices = edge_source.selected.indices;else if (mode == 'inspection') edge_indices = edge_source.inspected.indices;\n    const nodes = [];\n\n    for (const i of edge_indices) {\n      nodes.push(edge_source.data.start[i]);\n      nodes.push(edge_source.data.end[i]);\n    }\n\n    const node_indices = uniq(nodes).map(i => indexOf(node_source.data.index, i));\n    const linked_nodes = create_empty_hit_test_result();\n    linked_nodes.indices = node_indices;\n    return linked_nodes;\n  }\n\n  do_selection(hit_test_result, graph, final, append) {\n    if (hit_test_result == null) return false;\n    const edge_selection = graph.edge_renderer.data_source.selected;\n    edge_selection.update(hit_test_result, final, append);\n    const node_selection = graph.node_renderer.data_source.selected;\n    const linked_nodes = this.get_linked_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n    node_selection.update(linked_nodes, final, append);\n\n    graph.edge_renderer.data_source._select.emit();\n\n    return !edge_selection.is_empty();\n  }\n\n  do_inspection(hit_test_result, geometry, graph_view, final, append) {\n    if (hit_test_result == null) return false;\n    const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n    edge_inspection.update(hit_test_result, final, append);\n    graph_view.edge_view.model.data_source.setv({\n      inspected: edge_inspection\n    }, {\n      silent: true\n    });\n    const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n    const linked_nodes = this.get_linked_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n    node_inspection.update(linked_nodes, final, append); // silently set inspected attr to avoid triggering data_source.change event and rerender\n\n    graph_view.node_view.model.data_source.setv({\n      inspected: node_inspection\n    }, {\n      silent: true\n    });\n    graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view, {\n      geometry\n    }]);\n    return !edge_inspection.is_empty();\n  }\n\n}\nEdgesAndLinkedNodes.__name__ = \"EdgesAndLinkedNodes\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/graphs/graph_hit_test_policy.js"],"names":["Model","indexOf","contains","uniq","create_empty_hit_test_result","GraphHitTestPolicy","constructor","attrs","_hit_test_nodes","geometry","graph_view","model","visible","hit_test_result","node_view","glyph","hit_test","view","convert_selection_from_subset","_hit_test_edges","edge_view","__name__","NodesOnly","do_selection","graph","final","append","node_selection","node_renderer","data_source","selected","update","_select","emit","is_empty","do_inspection","node_inspection","get_selection_manager","get_or_create_inspector","setv","inspected","silent","inspect","NodesAndLinkedEdges","get_linked_edges","node_source","edge_source","mode","node_indices","indices","map","i","data","index","edge_indices","start","length","end","push","linked_edges","multiline_indices","edge_selection","edge_renderer","linked_edges_selection","selection_manager","edge_inspection","EdgesAndLinkedNodes","get_linked_nodes","nodes","linked_nodes"],"mappings":"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","sourcesContent":["import { Model } from \"../../model\";\nimport { indexOf } from \"../../core/util/arrayable\";\nimport { contains, uniq } from \"../../core/util/array\";\nimport { create_empty_hit_test_result } from \"../../core/hittest\";\nexport class GraphHitTestPolicy extends Model {\n    constructor(attrs) {\n        super(attrs);\n    }\n    _hit_test_nodes(geometry, graph_view) {\n        if (!graph_view.model.visible)\n            return null;\n        const hit_test_result = graph_view.node_view.glyph.hit_test(geometry);\n        if (hit_test_result == null)\n            return null;\n        else\n            return graph_view.node_view.model.view.convert_selection_from_subset(hit_test_result);\n    }\n    _hit_test_edges(geometry, graph_view) {\n        if (!graph_view.model.visible)\n            return null;\n        const hit_test_result = graph_view.edge_view.glyph.hit_test(geometry);\n        if (hit_test_result == null)\n            return null;\n        else\n            return graph_view.edge_view.model.view.convert_selection_from_subset(hit_test_result);\n    }\n}\nGraphHitTestPolicy.__name__ = \"GraphHitTestPolicy\";\nexport class NodesOnly extends GraphHitTestPolicy {\n    constructor(attrs) {\n        super(attrs);\n    }\n    hit_test(geometry, graph_view) {\n        return this._hit_test_nodes(geometry, graph_view);\n    }\n    do_selection(hit_test_result, graph, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const node_selection = graph.node_renderer.data_source.selected;\n        node_selection.update(hit_test_result, final, append);\n        graph.node_renderer.data_source._select.emit();\n        return !node_selection.is_empty();\n    }\n    do_inspection(hit_test_result, geometry, graph_view, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const node_inspection = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);\n        node_inspection.update(hit_test_result, final, append);\n        // silently set inspected attr to avoid triggering data_source.change event and rerender\n        graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n        graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\n        return !node_inspection.is_empty();\n    }\n}\nNodesOnly.__name__ = \"NodesOnly\";\nexport class NodesAndLinkedEdges extends GraphHitTestPolicy {\n    constructor(attrs) {\n        super(attrs);\n    }\n    hit_test(geometry, graph_view) {\n        return this._hit_test_nodes(geometry, graph_view);\n    }\n    get_linked_edges(node_source, edge_source, mode) {\n        let node_indices = [];\n        if (mode == 'selection') {\n            node_indices = node_source.selected.indices.map((i) => node_source.data.index[i]);\n        }\n        else if (mode == 'inspection') {\n            node_indices = node_source.inspected.indices.map((i) => node_source.data.index[i]);\n        }\n        const edge_indices = [];\n        for (let i = 0; i < edge_source.data.start.length; i++) {\n            if (contains(node_indices, edge_source.data.start[i]) || contains(node_indices, edge_source.data.end[i]))\n                edge_indices.push(i);\n        }\n        const linked_edges = create_empty_hit_test_result();\n        for (const i of edge_indices) {\n            linked_edges.multiline_indices[i] = [0]; //currently only supports 2-element multilines, so this is all of it\n        }\n        linked_edges.indices = edge_indices;\n        return linked_edges;\n    }\n    do_selection(hit_test_result, graph, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const node_selection = graph.node_renderer.data_source.selected;\n        node_selection.update(hit_test_result, final, append);\n        const edge_selection = graph.edge_renderer.data_source.selected;\n        const linked_edges_selection = this.get_linked_edges(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n        edge_selection.update(linked_edges_selection, final, append);\n        graph.node_renderer.data_source._select.emit();\n        return !node_selection.is_empty();\n    }\n    do_inspection(hit_test_result, geometry, graph_view, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n        node_inspection.update(hit_test_result, final, append);\n        graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n        const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n        const linked_edges = this.get_linked_edges(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n        edge_inspection.update(linked_edges, final, append);\n        //silently set inspected attr to avoid triggering data_source.change event and rerender\n        graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\n        graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\n        return !node_inspection.is_empty();\n    }\n}\nNodesAndLinkedEdges.__name__ = \"NodesAndLinkedEdges\";\nexport class EdgesAndLinkedNodes extends GraphHitTestPolicy {\n    constructor(attrs) {\n        super(attrs);\n    }\n    hit_test(geometry, graph_view) {\n        return this._hit_test_edges(geometry, graph_view);\n    }\n    get_linked_nodes(node_source, edge_source, mode) {\n        let edge_indices = [];\n        if (mode == 'selection')\n            edge_indices = edge_source.selected.indices;\n        else if (mode == 'inspection')\n            edge_indices = edge_source.inspected.indices;\n        const nodes = [];\n        for (const i of edge_indices) {\n            nodes.push(edge_source.data.start[i]);\n            nodes.push(edge_source.data.end[i]);\n        }\n        const node_indices = uniq(nodes).map((i) => indexOf(node_source.data.index, i));\n        const linked_nodes = create_empty_hit_test_result();\n        linked_nodes.indices = node_indices;\n        return linked_nodes;\n    }\n    do_selection(hit_test_result, graph, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const edge_selection = graph.edge_renderer.data_source.selected;\n        edge_selection.update(hit_test_result, final, append);\n        const node_selection = graph.node_renderer.data_source.selected;\n        const linked_nodes = this.get_linked_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n        node_selection.update(linked_nodes, final, append);\n        graph.edge_renderer.data_source._select.emit();\n        return !edge_selection.is_empty();\n    }\n    do_inspection(hit_test_result, geometry, graph_view, final, append) {\n        if (hit_test_result == null)\n            return false;\n        const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n        edge_inspection.update(hit_test_result, final, append);\n        graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\n        const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n        const linked_nodes = this.get_linked_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n        node_inspection.update(linked_nodes, final, append);\n        // silently set inspected attr to avoid triggering data_source.change event and rerender\n        graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n        graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view, { geometry }]);\n        return !edge_inspection.is_empty();\n    }\n}\nEdgesAndLinkedNodes.__name__ = \"EdgesAndLinkedNodes\";\n//# sourceMappingURL=graph_hit_test_policy.js.map"]},"metadata":{},"sourceType":"module"}