{"ast":null,"code":"import { ContinuousColorMapper } from \"./continuous_color_mapper\";\nimport { min, max } from \"../../core/util/arrayable\";\nexport class LogColorMapper extends ContinuousColorMapper {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  _v_compute(data, values, palette, colors) {\n    const {\n      nan_color,\n      low_color,\n      high_color\n    } = colors;\n    const n = palette.length;\n    const low = this.low != null ? this.low : min(data);\n    const high = this.high != null ? this.high : max(data);\n    const scale = n / (Math.log(high) - Math.log(low)); // subtract the low offset\n\n    const max_key = palette.length - 1;\n\n    for (let i = 0, end = data.length; i < end; i++) {\n      const d = data[i]; // Check NaN\n\n      if (isNaN(d)) {\n        values[i] = nan_color;\n        continue;\n      }\n\n      if (d > high) {\n        values[i] = high_color != null ? high_color : palette[max_key];\n        continue;\n      } // This handles the edge case where d == high, since the code below maps\n      // values exactly equal to high to palette.length, which is greater than\n      // max_key\n\n\n      if (d == high) {\n        values[i] = palette[max_key];\n        continue;\n      }\n\n      if (d < low) {\n        values[i] = low_color != null ? low_color : palette[0];\n        continue;\n      } // Get the key\n\n\n      const log = Math.log(d) - Math.log(low); // subtract the low offset\n\n      let key = Math.floor(log * scale); // Deal with upper bound\n\n      if (key > max_key) key = max_key;\n      values[i] = palette[key];\n    }\n  }\n\n}\nLogColorMapper.__name__ = \"LogColorMapper\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/log_color_mapper.js"],"names":["ContinuousColorMapper","min","max","LogColorMapper","constructor","attrs","_v_compute","data","values","palette","colors","nan_color","low_color","high_color","n","length","low","high","scale","Math","log","max_key","i","end","d","isNaN","key","floor","__name__"],"mappings":"AAAA,SAASA,qBAAT,QAAsC,2BAAtC;AACA,SAASC,GAAT,EAAcC,GAAd,QAAyB,2BAAzB;AACA,OAAO,MAAMC,cAAN,SAA6BH,qBAA7B,CAAmD;AACtDI,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACDC,EAAAA,UAAU,CAACC,IAAD,EAAOC,MAAP,EAAeC,OAAf,EAAwBC,MAAxB,EAAgC;AACtC,UAAM;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA;AAAxB,QAAuCH,MAA7C;AACA,UAAMI,CAAC,GAAGL,OAAO,CAACM,MAAlB;AACA,UAAMC,GAAG,GAAG,KAAKA,GAAL,IAAY,IAAZ,GAAmB,KAAKA,GAAxB,GAA8Bf,GAAG,CAACM,IAAD,CAA7C;AACA,UAAMU,IAAI,GAAG,KAAKA,IAAL,IAAa,IAAb,GAAoB,KAAKA,IAAzB,GAAgCf,GAAG,CAACK,IAAD,CAAhD;AACA,UAAMW,KAAK,GAAGJ,CAAC,IAAIK,IAAI,CAACC,GAAL,CAASH,IAAT,IAAiBE,IAAI,CAACC,GAAL,CAASJ,GAAT,CAArB,CAAf,CALsC,CAKc;;AACpD,UAAMK,OAAO,GAAGZ,OAAO,CAACM,MAAR,GAAiB,CAAjC;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGhB,IAAI,CAACQ,MAA3B,EAAmCO,CAAC,GAAGC,GAAvC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,YAAME,CAAC,GAAGjB,IAAI,CAACe,CAAD,CAAd,CAD6C,CAE7C;;AACA,UAAIG,KAAK,CAACD,CAAD,CAAT,EAAc;AACVhB,QAAAA,MAAM,CAACc,CAAD,CAAN,GAAYX,SAAZ;AACA;AACH;;AACD,UAAIa,CAAC,GAAGP,IAAR,EAAc;AACVT,QAAAA,MAAM,CAACc,CAAD,CAAN,GAAYT,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCJ,OAAO,CAACY,OAAD,CAArD;AACA;AACH,OAV4C,CAW7C;AACA;AACA;;;AACA,UAAIG,CAAC,IAAIP,IAAT,EAAe;AACXT,QAAAA,MAAM,CAACc,CAAD,CAAN,GAAYb,OAAO,CAACY,OAAD,CAAnB;AACA;AACH;;AACD,UAAIG,CAAC,GAAGR,GAAR,EAAa;AACTR,QAAAA,MAAM,CAACc,CAAD,CAAN,GAAYV,SAAS,IAAI,IAAb,GAAoBA,SAApB,GAAgCH,OAAO,CAAC,CAAD,CAAnD;AACA;AACH,OArB4C,CAsB7C;;;AACA,YAAMW,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASI,CAAT,IAAcL,IAAI,CAACC,GAAL,CAASJ,GAAT,CAA1B,CAvB6C,CAuBJ;;AACzC,UAAIU,GAAG,GAAGP,IAAI,CAACQ,KAAL,CAAWP,GAAG,GAAGF,KAAjB,CAAV,CAxB6C,CAyB7C;;AACA,UAAIQ,GAAG,GAAGL,OAAV,EACIK,GAAG,GAAGL,OAAN;AACJb,MAAAA,MAAM,CAACc,CAAD,CAAN,GAAYb,OAAO,CAACiB,GAAD,CAAnB;AACH;AACJ;;AAzCqD;AA2C1DvB,cAAc,CAACyB,QAAf,GAA0B,gBAA1B","sourcesContent":["import { ContinuousColorMapper } from \"./continuous_color_mapper\";\nimport { min, max } from \"../../core/util/arrayable\";\nexport class LogColorMapper extends ContinuousColorMapper {\n    constructor(attrs) {\n        super(attrs);\n    }\n    _v_compute(data, values, palette, colors) {\n        const { nan_color, low_color, high_color } = colors;\n        const n = palette.length;\n        const low = this.low != null ? this.low : min(data);\n        const high = this.high != null ? this.high : max(data);\n        const scale = n / (Math.log(high) - Math.log(low)); // subtract the low offset\n        const max_key = palette.length - 1;\n        for (let i = 0, end = data.length; i < end; i++) {\n            const d = data[i];\n            // Check NaN\n            if (isNaN(d)) {\n                values[i] = nan_color;\n                continue;\n            }\n            if (d > high) {\n                values[i] = high_color != null ? high_color : palette[max_key];\n                continue;\n            }\n            // This handles the edge case where d == high, since the code below maps\n            // values exactly equal to high to palette.length, which is greater than\n            // max_key\n            if (d == high) {\n                values[i] = palette[max_key];\n                continue;\n            }\n            if (d < low) {\n                values[i] = low_color != null ? low_color : palette[0];\n                continue;\n            }\n            // Get the key\n            const log = Math.log(d) - Math.log(low); // subtract the low offset\n            let key = Math.floor(log * scale);\n            // Deal with upper bound\n            if (key > max_key)\n                key = max_key;\n            values[i] = palette[key];\n        }\n    }\n}\nLogColorMapper.__name__ = \"LogColorMapper\";\n//# sourceMappingURL=log_color_mapper.js.map"]},"metadata":{},"sourceType":"module"}