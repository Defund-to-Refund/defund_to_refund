{"ast":null,"code":"import * as hittest from \"../../core/hittest\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_line_legend } from \"./utils\";\nexport class SegmentView extends GlyphView {\n  _index_data() {\n    const points = [];\n\n    for (let i = 0, end = this._x0.length; i < end; i++) {\n      const x0 = this._x0[i];\n      const x1 = this._x1[i];\n      const y0 = this._y0[i];\n      const y1 = this._y1[i];\n\n      if (!isNaN(x0 + x1 + y0 + y1)) {\n        points.push({\n          x0: Math.min(x0, x1),\n          y0: Math.min(y0, y1),\n          x1: Math.max(x0, x1),\n          y1: Math.max(y0, y1),\n          i\n        });\n      }\n    }\n\n    return new SpatialIndex(points);\n  }\n\n  _render(ctx, indices, {\n    sx0,\n    sy0,\n    sx1,\n    sy1\n  }) {\n    if (this.visuals.line.doit) {\n      for (const i of indices) {\n        if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) continue;\n        ctx.beginPath();\n        ctx.moveTo(sx0[i], sy0[i]);\n        ctx.lineTo(sx1[i], sy1[i]);\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const point = {\n      x: sx,\n      y: sy\n    };\n    const hits = [];\n    const lw_voffset = 2; // FIXME: Use maximum of segments line_width/2 instead of magic constant 2\n\n    const [x0, x1] = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset);\n    const candidates = this.index.indices({\n      x0,\n      y0,\n      x1,\n      y1\n    });\n\n    for (const i of candidates) {\n      const threshold2 = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2) ** 2;\n      const p0 = {\n        x: this.sx0[i],\n        y: this.sy0[i]\n      };\n      const p1 = {\n        x: this.sx1[i],\n        y: this.sy1[i]\n      };\n      const dist2 = hittest.dist_to_segment_squared(point, p0, p1);\n      if (dist2 < threshold2) hits.push(i);\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_span(geometry) {\n    const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n    const {\n      sx,\n      sy\n    } = geometry;\n    let v0;\n    let v1;\n    let val;\n\n    if (geometry.direction == 'v') {\n      val = this.renderer.yscale.invert(sy);\n      [v0, v1] = [this._y0, this._y1];\n    } else {\n      val = this.renderer.xscale.invert(sx);\n      [v0, v1] = [this._x0, this._x1];\n    }\n\n    const hits = [];\n    const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n    const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n    const candidates = this.index.indices({\n      x0,\n      y0,\n      x1,\n      y1\n    });\n\n    for (const i of candidates) {\n      if (v0[i] <= val && val <= v1[i] || v1[i] <= val && val <= v0[i]) hits.push(i);\n      const threshold = 1.5 + this.visuals.line.cache_select('line_width', i) / 2; // Maximum pixel difference to detect hit\n\n      if (v0[i] == v1[i]) {\n        if (geometry.direction == 'h') {\n          if (Math.abs(this.sx0[i] - sx) <= threshold) {\n            hits.push(i);\n          }\n        } else {\n          if (Math.abs(this.sy0[i] - sy) <= threshold) {\n            hits.push(i);\n          }\n        }\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  scenterx(i) {\n    return (this.sx0[i] + this.sx1[i]) / 2;\n  }\n\n  scentery(i) {\n    return (this.sy0[i] + this.sy1[i]) / 2;\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_line_legend(this.visuals, ctx, bbox, index);\n  }\n\n}\nSegmentView.__name__ = \"SegmentView\";\nexport class Segment extends Glyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Segment() {\n    this.prototype.default_view = SegmentView;\n    this.coords([['x0', 'y0'], ['x1', 'y1']]);\n    this.mixins(['line']);\n  }\n\n}\nSegment.__name__ = \"Segment\";\nSegment.init_Segment();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/segment.js"],"names":["hittest","SpatialIndex","Glyph","GlyphView","generic_line_legend","SegmentView","_index_data","points","i","end","_x0","length","x0","x1","_x1","y0","_y0","y1","_y1","isNaN","push","Math","min","max","_render","ctx","indices","sx0","sy0","sx1","sy1","visuals","line","doit","beginPath","moveTo","lineTo","set_vectorize","stroke","_hit_point","geometry","sx","sy","point","x","y","hits","lw_voffset","renderer","xscale","r_invert","yscale","candidates","index","threshold2","cache_select","p0","p1","dist2","dist_to_segment_squared","result","create_empty_hit_test_result","_hit_span","hr","vr","plot_view","frame","bbox","ranges","v0","v1","val","direction","invert","start","threshold","abs","scenterx","scentery","draw_legend_for_index","__name__","Segment","constructor","attrs","init_Segment","prototype","default_view","coords","mixins"],"mappings":"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","sourcesContent":["import * as hittest from \"../../core/hittest\";\nimport { SpatialIndex } from \"../../core/util/spatial\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_line_legend } from \"./utils\";\nexport class SegmentView extends GlyphView {\n    _index_data() {\n        const points = [];\n        for (let i = 0, end = this._x0.length; i < end; i++) {\n            const x0 = this._x0[i];\n            const x1 = this._x1[i];\n            const y0 = this._y0[i];\n            const y1 = this._y1[i];\n            if (!isNaN(x0 + x1 + y0 + y1)) {\n                points.push({\n                    x0: Math.min(x0, x1),\n                    y0: Math.min(y0, y1),\n                    x1: Math.max(x0, x1),\n                    y1: Math.max(y0, y1),\n                    i,\n                });\n            }\n        }\n        return new SpatialIndex(points);\n    }\n    _render(ctx, indices, { sx0, sy0, sx1, sy1 }) {\n        if (this.visuals.line.doit) {\n            for (const i of indices) {\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i]))\n                    continue;\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.lineTo(sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const point = { x: sx, y: sy };\n        const hits = [];\n        const lw_voffset = 2; // FIXME: Use maximum of segments line_width/2 instead of magic constant 2\n        const [x0, x1] = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset);\n        const candidates = this.index.indices({ x0, y0, x1, y1 });\n        for (const i of candidates) {\n            const threshold2 = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2) ** 2;\n            const p0 = { x: this.sx0[i], y: this.sy0[i] };\n            const p1 = { x: this.sx1[i], y: this.sy1[i] };\n            const dist2 = hittest.dist_to_segment_squared(point, p0, p1);\n            if (dist2 < threshold2)\n                hits.push(i);\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _hit_span(geometry) {\n        const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n        const { sx, sy } = geometry;\n        let v0;\n        let v1;\n        let val;\n        if (geometry.direction == 'v') {\n            val = this.renderer.yscale.invert(sy);\n            [v0, v1] = [this._y0, this._y1];\n        }\n        else {\n            val = this.renderer.xscale.invert(sx);\n            [v0, v1] = [this._x0, this._x1];\n        }\n        const hits = [];\n        const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n        const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n        const candidates = this.index.indices({ x0, y0, x1, y1 });\n        for (const i of candidates) {\n            if ((v0[i] <= val && val <= v1[i]) || (v1[i] <= val && val <= v0[i]))\n                hits.push(i);\n            const threshold = 1.5 + (this.visuals.line.cache_select('line_width', i) / 2); // Maximum pixel difference to detect hit\n            if (v0[i] == v1[i]) {\n                if (geometry.direction == 'h') {\n                    if (Math.abs(this.sx0[i] - sx) <= threshold) {\n                        hits.push(i);\n                    }\n                }\n                else {\n                    if (Math.abs(this.sy0[i] - sy) <= threshold) {\n                        hits.push(i);\n                    }\n                }\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    scenterx(i) {\n        return (this.sx0[i] + this.sx1[i]) / 2;\n    }\n    scentery(i) {\n        return (this.sy0[i] + this.sy1[i]) / 2;\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_line_legend(this.visuals, ctx, bbox, index);\n    }\n}\nSegmentView.__name__ = \"SegmentView\";\nexport class Segment extends Glyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Segment() {\n        this.prototype.default_view = SegmentView;\n        this.coords([['x0', 'y0'], ['x1', 'y1']]);\n        this.mixins(['line']);\n    }\n}\nSegment.__name__ = \"Segment\";\nSegment.init_Segment();\n//# sourceMappingURL=segment.js.map"]},"metadata":{},"sourceType":"module"}