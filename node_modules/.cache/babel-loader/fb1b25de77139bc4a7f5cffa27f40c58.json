{"ast":null,"code":"/*!\n * jquery.event.drop - v 2.3.0\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04\n// Updated: 2012-05-21\n// Updated: 2016-08-16   Luiz Gonzaga dos Santos Filho\n// REQUIRES: jquery 1.8 +, , event.drag 2.3.0\n// TESTED WITH: jQuery 1.8.3, 1.11.2, 2.2.4, and 3.1.0\nvar $ = require(\"../slick.jquery\"); // Events: drop, dropstart, dropend\n// add the jquery instance method\n\n\n$.fn.drop = function (str, arg, opts) {\n  // figure out the event type\n  var type = typeof str == \"string\" ? str : \"\",\n      // figure out the event handler...\n  fn = $.isFunction(str) ? str : $.isFunction(arg) ? arg : null; // fix the event type\n\n  if (type.indexOf(\"drop\") !== 0) type = \"drop\" + type; // were options passed\n\n  opts = (str == fn ? arg : opts) || {}; // trigger or bind event handler\n\n  return fn ? this.on(type, opts, fn) : this.trigger(type);\n}; // DROP MANAGEMENT UTILITY\n// returns filtered drop target elements, caches their positions\n\n\n$.drop = function (opts) {\n  opts = opts || {}; // safely set new options...\n\n  drop.multi = opts.multi === true ? Infinity : opts.multi === false ? 1 : !isNaN(opts.multi) ? opts.multi : drop.multi;\n  drop.delay = opts.delay || drop.delay;\n  drop.tolerance = $.isFunction(opts.tolerance) ? opts.tolerance : opts.tolerance === null ? null : drop.tolerance;\n  drop.mode = opts.mode || drop.mode || 'intersect';\n}; // local refs (increase compression)\n\n\nvar $event = $.event,\n    $special = $event.special,\n    // configure the drop special event\ndrop = $.event.special.drop = {\n  // these are the default settings\n  multi: 1,\n  // allow multiple drop winners per dragged element\n  delay: 20,\n  // async timeout delay\n  mode: 'overlap',\n  // drop tolerance mode\n  // internal cache\n  targets: [],\n  // the key name for stored drop data\n  datakey: \"dropdata\",\n  // prevent bubbling for better performance\n  noBubble: true,\n  // count bound related events\n  add: function (obj) {\n    // read the interaction data\n    var data = $.data(this, drop.datakey); // count another realted event\n\n    data.related += 1;\n  },\n  // forget unbound related events\n  remove: function () {\n    $.data(this, drop.datakey).related -= 1;\n  },\n  // configure the interactions\n  setup: function () {\n    // check for related events\n    if ($.data(this, drop.datakey)) return; // initialize the drop element data\n\n    var data = {\n      related: 0,\n      active: [],\n      anyactive: 0,\n      winner: 0,\n      location: {}\n    }; // store the drop data on the element\n\n    $.data(this, drop.datakey, data); // store the drop target in internal cache\n\n    drop.targets.push(this);\n  },\n  // destroy the configure interaction\n  teardown: function () {\n    var data = $.data(this, drop.datakey) || {}; // check for related events\n\n    if (data.related) return; // remove the stored data\n\n    $.removeData(this, drop.datakey); // reference the targeted element\n\n    var element = this; // remove from the internal cache\n\n    drop.targets = $.grep(drop.targets, function (target) {\n      return target !== element;\n    });\n  },\n  // shared event handler\n  handler: function (event, dd) {\n    // local vars\n    var results, $targets; // make sure the right data is available\n\n    if (!dd) return; // handle various events\n\n    switch (event.type) {\n      // draginit, from $.event.special.drag\n      case 'mousedown': // DROPINIT >>\n\n      case 'touchstart':\n        // DROPINIT >>\n        // collect and assign the drop targets\n        $targets = $(drop.targets);\n        if (typeof dd.drop == \"string\") $targets = $targets.filter(dd.drop); // reset drop data winner properties\n\n        $targets.each(function () {\n          var data = $.data(this, drop.datakey);\n          data.active = [];\n          data.anyactive = 0;\n          data.winner = 0;\n        }); // set available target elements\n\n        dd.droppable = $targets; // activate drop targets for the initial element being dragged\n\n        $special.drag.hijack(event, \"dropinit\", dd);\n        break;\n      // drag, from $.event.special.drag\n\n      case 'mousemove': // TOLERATE >>\n\n      case 'touchmove':\n        // TOLERATE >>\n        drop.event = event; // store the mousemove event\n\n        if (!drop.timer) // monitor drop targets\n          drop.tolerate(dd);\n        break;\n      // dragend, from $.event.special.drag\n\n      case 'mouseup': // DROP >> DROPEND >>\n\n      case 'touchend':\n        // DROP >> DROPEND >>\n        drop.timer = clearTimeout(drop.timer); // delete timer\n\n        if (dd.propagates) {\n          $special.drag.hijack(event, \"drop\", dd);\n          $special.drag.hijack(event, \"dropend\", dd);\n        }\n\n        break;\n    }\n  },\n  // returns the location positions of an element\n  locate: function (elem, index) {\n    var data = $.data(elem, drop.datakey),\n        $elem = $(elem),\n        posi = $elem.offset() || {},\n        height = $elem.outerHeight(),\n        width = $elem.outerWidth(),\n        location = {\n      elem: elem,\n      width: width,\n      height: height,\n      top: posi.top,\n      left: posi.left,\n      right: posi.left + width,\n      bottom: posi.top + height\n    }; // drag elements might not have dropdata\n\n    if (data) {\n      data.location = location;\n      data.index = index;\n      data.elem = elem;\n    }\n\n    return location;\n  },\n  // test the location positions of an element against another OR an X,Y coord\n  contains: function (target, test) {\n    // target { location } contains test [x,y] or { location }\n    return (test[0] || test.left) >= target.left && (test[0] || test.right) <= target.right && (test[1] || test.top) >= target.top && (test[1] || test.bottom) <= target.bottom;\n  },\n  // stored tolerance modes\n  modes: {\n    // fn scope: \"$.event.special.drop\" object\n    // target with mouse wins, else target with most overlap wins\n    'intersect': function (event, proxy, target) {\n      return this.contains(target, [event.pageX, event.pageY]) ? // check cursor\n      1e9 : this.modes.overlap.apply(this, arguments); // check overlap\n    },\n    // target with most overlap wins\n    'overlap': function (event, proxy, target) {\n      // calculate the area of overlap...\n      return Math.max(0, Math.min(target.bottom, proxy.bottom) - Math.max(target.top, proxy.top)) * Math.max(0, Math.min(target.right, proxy.right) - Math.max(target.left, proxy.left));\n    },\n    // proxy is completely contained within target bounds\n    'fit': function (event, proxy, target) {\n      return this.contains(target, proxy) ? 1 : 0;\n    },\n    // center of the proxy is contained within target bounds\n    'middle': function (event, proxy, target) {\n      return this.contains(target, [proxy.left + proxy.width * .5, proxy.top + proxy.height * .5]) ? 1 : 0;\n    }\n  },\n  // sort drop target cache by by winner (dsc), then index (asc)\n  sort: function (a, b) {\n    return b.winner - a.winner || a.index - b.index;\n  },\n  // async, recursive tolerance execution\n  tolerate: function (dd) {\n    // declare local refs\n    var i,\n        drp,\n        drg,\n        data,\n        arr,\n        len,\n        elem,\n        // interaction iteration variables\n    x = 0,\n        ia,\n        end = dd.interactions.length,\n        // determine the mouse coords\n    xy = [drop.event.pageX, drop.event.pageY],\n        // custom or stored tolerance fn\n    tolerance = drop.tolerance || drop.modes[drop.mode]; // go through each passed interaction...\n\n    do if (ia = dd.interactions[x]) {\n      // check valid interaction\n      if (!ia) return; // initialize or clear the drop data\n\n      ia.drop = []; // holds the drop elements\n\n      arr = [];\n      len = ia.droppable.length; // determine the proxy location, if needed\n\n      if (tolerance) drg = drop.locate(ia.proxy); // reset the loop\n\n      i = 0; // loop each stored drop target\n\n      do if (elem = ia.droppable[i]) {\n        data = $.data(elem, drop.datakey);\n        drp = data.location;\n        if (!drp) continue; // find a winner: tolerance function is defined, call it\n\n        data.winner = tolerance ? tolerance.call(drop, drop.event, drg, drp) // mouse position is always the fallback\n        : drop.contains(drp, xy) ? 1 : 0;\n        arr.push(data);\n      } while (++i < len); // loop\n      // sort the drop targets\n\n\n      arr.sort(drop.sort); // reset the loop\n\n      i = 0; // loop through all of the targets again\n\n      do if (data = arr[i]) {\n        // winners...\n        if (data.winner && ia.drop.length < drop.multi) {\n          // new winner... dropstart\n          if (!data.active[x] && !data.anyactive) {\n            // check to make sure that this is not prevented\n            if ($special.drag.hijack(drop.event, \"dropstart\", dd, x, data.elem)[0] !== false) {\n              data.active[x] = 1;\n              data.anyactive += 1;\n            } // if false, it is not a winner\n            else data.winner = 0;\n          } // if it is still a winner\n\n\n          if (data.winner) ia.drop.push(data.elem);\n        } // losers...\n        else if (data.active[x] && data.anyactive == 1) {\n            // former winner... dropend\n            $special.drag.hijack(drop.event, \"dropend\", dd, x, data.elem);\n            data.active[x] = 0;\n            data.anyactive -= 1;\n          }\n      } while (++i < len); // loop\n\n    } while (++x < end); // loop\n    // check if the mouse is still moving or is idle\n\n\n    if (drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY) delete drop.timer; // idle, don't recurse\n    else // recurse\n      drop.timer = setTimeout(function () {\n        drop.tolerate(dd);\n      }, drop.delay); // remember event, to compare idleness\n\n    drop.last = drop.event;\n  }\n}; // share the same special event configuration with related events...\n\n$special.dropinit = $special.dropstart = $special.dropend = drop;","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/slickgrid/lib/jquery.event.drop-2.3.0.js"],"names":["$","require","fn","drop","str","arg","opts","type","isFunction","indexOf","on","trigger","multi","Infinity","isNaN","delay","tolerance","mode","$event","event","$special","special","targets","datakey","noBubble","add","obj","data","related","remove","setup","active","anyactive","winner","location","push","teardown","removeData","element","grep","target","handler","dd","results","$targets","filter","each","droppable","drag","hijack","timer","tolerate","clearTimeout","propagates","locate","elem","index","$elem","posi","offset","height","outerHeight","width","outerWidth","top","left","right","bottom","contains","test","modes","proxy","pageX","pageY","overlap","apply","arguments","Math","max","min","sort","a","b","i","drp","drg","arr","len","x","ia","end","interactions","length","xy","call","last","setTimeout","dropinit","dropstart","dropend"],"mappings":"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","sourcesContent":["/*!\n * jquery.event.drop - v 2.3.0\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04\n// Updated: 2012-05-21\n// Updated: 2016-08-16   Luiz Gonzaga dos Santos Filho\n// REQUIRES: jquery 1.8 +, , event.drag 2.3.0\n// TESTED WITH: jQuery 1.8.3, 1.11.2, 2.2.4, and 3.1.0\n\nvar $ = require(\"../slick.jquery\");\n\n// Events: drop, dropstart, dropend\n\n// add the jquery instance method\n$.fn.drop = function( str, arg, opts ){\n\t// figure out the event type\n\tvar type = typeof str == \"string\" ? str : \"\",\n\t// figure out the event handler...\n\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n\t// fix the event type\n\tif ( type.indexOf(\"drop\") !== 0 )\n\t\ttype = \"drop\"+ type;\n\t// were options passed\n\topts = ( str == fn ? arg : opts ) || {};\n\t// trigger or bind event handler\n\treturn fn ? this.on( type, opts, fn ) : this.trigger( type );\n};\n\n// DROP MANAGEMENT UTILITY\n// returns filtered drop target elements, caches their positions\n$.drop = function( opts ){\n\topts = opts || {};\n\t// safely set new options...\n\tdrop.multi = opts.multi === true ? Infinity :\n\t\topts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;\n\tdrop.delay = opts.delay || drop.delay;\n\tdrop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance :\n\t\topts.tolerance === null ? null : drop.tolerance;\n\tdrop.mode = opts.mode || drop.mode || 'intersect';\n};\n\n// local refs (increase compression)\nvar $event = $.event,\n$special = $event.special,\n// configure the drop special event\ndrop = $.event.special.drop = {\n\n\t// these are the default settings\n\tmulti: 1, // allow multiple drop winners per dragged element\n\tdelay: 20, // async timeout delay\n\tmode: 'overlap', // drop tolerance mode\n\n\t// internal cache\n\ttargets: [],\n\n\t// the key name for stored drop data\n\tdatakey: \"dropdata\",\n\n\t// prevent bubbling for better performance\n\tnoBubble: true,\n\n\t// count bound related events\n\tadd: function( obj ){\n\t\t// read the interaction data\n\t\tvar data = $.data( this, drop.datakey );\n\t\t// count another realted event\n\t\tdata.related += 1;\n\t},\n\n\t// forget unbound related events\n\tremove: function(){\n\t\t$.data( this, drop.datakey ).related -= 1;\n\t},\n\n\t// configure the interactions\n\tsetup: function(){\n\t\t// check for related events\n\t\tif ( $.data( this, drop.datakey ) )\n\t\t\treturn;\n\t\t// initialize the drop element data\n\t\tvar data = {\n\t\t\trelated: 0,\n\t\t\tactive: [],\n\t\t\tanyactive: 0,\n\t\t\twinner: 0,\n\t\t\tlocation: {}\n\t\t};\n\t\t// store the drop data on the element\n\t\t$.data( this, drop.datakey, data );\n\t\t// store the drop target in internal cache\n\t\tdrop.targets.push( this );\n\t},\n\n\t// destroy the configure interaction\n\tteardown: function(){\n\t\tvar data = $.data( this, drop.datakey ) || {};\n\t\t// check for related events\n\t\tif ( data.related )\n\t\t\treturn;\n\t\t// remove the stored data\n\t\t$.removeData( this, drop.datakey );\n\t\t// reference the targeted element\n\t\tvar element = this;\n\t\t// remove from the internal cache\n\t\tdrop.targets = $.grep( drop.targets, function( target ){\n\t\t\treturn ( target !== element );\n\t\t});\n\t},\n\n\t// shared event handler\n\thandler: function( event, dd ){\n\t\t// local vars\n\t\tvar results, $targets;\n\t\t// make sure the right data is available\n\t\tif ( !dd )\n\t\t\treturn;\n\t\t// handle various events\n\t\tswitch ( event.type ){\n\t\t\t// draginit, from $.event.special.drag\n\t\t\tcase 'mousedown': // DROPINIT >>\n\t\t\tcase 'touchstart': // DROPINIT >>\n\t\t\t\t// collect and assign the drop targets\n\t\t\t\t$targets =  $( drop.targets );\n\t\t\t\tif ( typeof dd.drop == \"string\" )\n\t\t\t\t\t$targets = $targets.filter( dd.drop );\n\t\t\t\t// reset drop data winner properties\n\t\t\t\t$targets.each(function(){\n\t\t\t\t\tvar data = $.data( this, drop.datakey );\n\t\t\t\t\tdata.active = [];\n\t\t\t\t\tdata.anyactive = 0;\n\t\t\t\t\tdata.winner = 0;\n\t\t\t\t});\n\t\t\t\t// set available target elements\n\t\t\t\tdd.droppable = $targets;\n\t\t\t\t// activate drop targets for the initial element being dragged\n\t\t\t\t$special.drag.hijack( event, \"dropinit\", dd );\n\t\t\t\tbreak;\n\t\t\t// drag, from $.event.special.drag\n\t\t\tcase 'mousemove': // TOLERATE >>\n\t\t\tcase 'touchmove': // TOLERATE >>\n\t\t\t\tdrop.event = event; // store the mousemove event\n\t\t\t\tif ( !drop.timer )\n\t\t\t\t\t// monitor drop targets\n\t\t\t\t\tdrop.tolerate( dd );\n\t\t\t\tbreak;\n\t\t\t// dragend, from $.event.special.drag\n\t\t\tcase 'mouseup': // DROP >> DROPEND >>\n\t\t\tcase 'touchend': // DROP >> DROPEND >>\n\t\t\t\tdrop.timer = clearTimeout( drop.timer ); // delete timer\n\t\t\t\tif ( dd.propagates ){\n\t\t\t\t\t$special.drag.hijack( event, \"drop\", dd );\n\t\t\t\t\t$special.drag.hijack( event, \"dropend\", dd );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t}\n\t},\n\n\t// returns the location positions of an element\n\tlocate: function( elem, index ){\n\t\tvar data = $.data( elem, drop.datakey ),\n\t\t$elem = $( elem ),\n\t\tposi = $elem.offset() || {},\n\t\theight = $elem.outerHeight(),\n\t\twidth = $elem.outerWidth(),\n\t\tlocation = {\n\t\t\telem: elem,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\ttop: posi.top,\n\t\t\tleft: posi.left,\n\t\t\tright: posi.left + width,\n\t\t\tbottom: posi.top + height\n\t\t};\n\t\t// drag elements might not have dropdata\n\t\tif ( data ){\n\t\t\tdata.location = location;\n\t\t\tdata.index = index;\n\t\t\tdata.elem = elem;\n\t\t}\n\t\treturn location;\n\t},\n\n\t// test the location positions of an element against another OR an X,Y coord\n\tcontains: function( target, test ){ // target { location } contains test [x,y] or { location }\n\t\treturn ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right\n\t\t\t&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom );\n\t},\n\n\t// stored tolerance modes\n\tmodes: { // fn scope: \"$.event.special.drop\" object\n\t\t// target with mouse wins, else target with most overlap wins\n\t\t'intersect': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor\n\t\t\t\t1e9 : this.modes.overlap.apply( this, arguments ); // check overlap\n\t\t},\n\t\t// target with most overlap wins\n\t\t'overlap': function( event, proxy, target ){\n\t\t\t// calculate the area of overlap...\n\t\t\treturn Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )\n\t\t\t\t* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );\n\t\t},\n\t\t// proxy is completely contained within target bounds\n\t\t'fit': function( event, proxy, target ){\n\t\t\treturn this.contains( target, proxy ) ? 1 : 0;\n\t\t},\n\t\t// center of the proxy is contained within target bounds\n\t\t'middle': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;\n\t\t}\n\t},\n\n\t// sort drop target cache by by winner (dsc), then index (asc)\n\tsort: function( a, b ){\n\t\treturn ( b.winner - a.winner ) || ( a.index - b.index );\n\t},\n\n\t// async, recursive tolerance execution\n\ttolerate: function( dd ){\n\t\t// declare local refs\n\t\tvar i, drp, drg, data, arr, len, elem,\n\t\t// interaction iteration variables\n\t\tx = 0, ia, end = dd.interactions.length,\n\t\t// determine the mouse coords\n\t\txy = [ drop.event.pageX, drop.event.pageY ],\n\t\t// custom or stored tolerance fn\n\t\ttolerance = drop.tolerance || drop.modes[ drop.mode ];\n\t\t// go through each passed interaction...\n\t\tdo if ( ia = dd.interactions[x] ){\n\t\t\t// check valid interaction\n\t\t\tif ( !ia )\n\t\t\t\treturn;\n\t\t\t// initialize or clear the drop data\n\t\t\tia.drop = [];\n\t\t\t// holds the drop elements\n\t\t\tarr = [];\n\t\t\tlen = ia.droppable.length;\n\t\t\t// determine the proxy location, if needed\n\t\t\tif ( tolerance )\n\t\t\t\tdrg = drop.locate( ia.proxy );\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop each stored drop target\n\t\t\tdo if ( elem = ia.droppable[i] ){\n\t\t\t\tdata = $.data( elem, drop.datakey );\n\t\t\t\tdrp = data.location;\n\t\t\t\tif ( !drp ) continue;\n\t\t\t\t// find a winner: tolerance function is defined, call it\n\t\t\t\tdata.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp )\n\t\t\t\t\t// mouse position is always the fallback\n\t\t\t\t\t: drop.contains( drp, xy ) ? 1 : 0;\n\t\t\t\tarr.push( data );\n\t\t\t} while ( ++i < len ); // loop\n\t\t\t// sort the drop targets\n\t\t\tarr.sort( drop.sort );\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop through all of the targets again\n\t\t\tdo if ( data = arr[ i ] ){\n\t\t\t\t// winners...\n\t\t\t\tif ( data.winner && ia.drop.length < drop.multi ){\n\t\t\t\t\t// new winner... dropstart\n\t\t\t\t\tif ( !data.active[x] && !data.anyactive ){\n\t\t\t\t\t\t// check to make sure that this is not prevented\n\t\t\t\t\t\tif ( $special.drag.hijack( drop.event, \"dropstart\", dd, x, data.elem )[0] !== false ){\n\t\t\t\t\t\t\tdata.active[x] = 1;\n\t\t\t\t\t\t\tdata.anyactive += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if false, it is not a winner\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdata.winner = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// if it is still a winner\n\t\t\t\t\tif ( data.winner )\n\t\t\t\t\t\tia.drop.push( data.elem );\n\t\t\t\t}\n\t\t\t\t// losers...\n\t\t\t\telse if ( data.active[x] && data.anyactive == 1 ){\n\t\t\t\t\t// former winner... dropend\n\t\t\t\t\t$special.drag.hijack( drop.event, \"dropend\", dd, x, data.elem );\n\t\t\t\t\tdata.active[x] = 0;\n\t\t\t\t\tdata.anyactive -= 1;\n\t\t\t\t}\n\t\t\t} while ( ++i < len ); // loop\n\t\t} while ( ++x < end ) // loop\n\t\t// check if the mouse is still moving or is idle\n\t\tif ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY )\n\t\t\tdelete drop.timer; // idle, don't recurse\n\t\telse  // recurse\n\t\t\tdrop.timer = setTimeout(function(){\n\t\t\t\tdrop.tolerate( dd );\n\t\t\t}, drop.delay );\n\t\t// remember event, to compare idleness\n\t\tdrop.last = drop.event;\n\t}\n\n};\n\n// share the same special event configuration with related events...\n$special.dropinit = $special.dropstart = $special.dropend = drop;\n"]},"metadata":{},"sourceType":"script"}