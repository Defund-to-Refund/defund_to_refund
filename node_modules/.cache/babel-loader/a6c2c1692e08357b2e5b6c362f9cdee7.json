{"ast":null,"code":"import { InspectTool, InspectToolView } from \"./inspect_tool\";\nimport { Tooltip } from \"../../annotations/tooltip\";\nimport { GlyphRenderer, GlyphRendererView } from \"../../renderers/glyph_renderer\";\nimport { GraphRenderer, GraphRendererView } from \"../../renderers/graph_renderer\";\nimport { compute_renderers } from \"../util\";\nimport * as hittest from \"../../../core/hittest\";\nimport { replace_placeholders } from \"../../../core/util/templating\";\nimport { div, span } from \"../../../core/dom\";\nimport * as p from \"../../../core/properties\";\nimport { color2hex } from \"../../../core/util/color\";\nimport { values, isEmpty } from \"../../../core/util/object\";\nimport { isString, isFunction, isNumber } from \"../../../core/util/types\";\nimport { build_views, remove_views } from \"../../../core/build_views\";\nimport { bk_tool_icon_hover } from \"../../../styles/icons\";\nimport { bk_tooltip_row_label, bk_tooltip_row_value, bk_tooltip_color_block } from \"../../../styles/tooltips\";\nexport function _nearest_line_hit(i, geometry, sx, sy, dx, dy) {\n  const d1 = {\n    x: dx[i],\n    y: dy[i]\n  };\n  const d2 = {\n    x: dx[i + 1],\n    y: dy[i + 1]\n  };\n  let dist1;\n  let dist2;\n\n  if (geometry.type == \"span\") {\n    if (geometry.direction == \"h\") {\n      dist1 = Math.abs(d1.x - sx);\n      dist2 = Math.abs(d2.x - sx);\n    } else {\n      dist1 = Math.abs(d1.y - sy);\n      dist2 = Math.abs(d2.y - sy);\n    }\n  } else {\n    const s = {\n      x: sx,\n      y: sy\n    };\n    dist1 = hittest.dist_2_pts(d1, s);\n    dist2 = hittest.dist_2_pts(d2, s);\n  }\n\n  if (dist1 < dist2) return [[d1.x, d1.y], i];else return [[d2.x, d2.y], i + 1];\n}\nexport function _line_hit(xs, ys, ind) {\n  return [[xs[ind], ys[ind]], ind];\n}\nexport class HoverToolView extends InspectToolView {\n  initialize() {\n    super.initialize();\n    this.ttviews = {};\n  }\n\n  remove() {\n    remove_views(this.ttviews);\n    super.remove();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n\n    for (const r of this.computed_renderers) {\n      if (r instanceof GlyphRenderer) this.connect(r.data_source.inspect, this._update);else if (r instanceof GraphRenderer) {\n        this.connect(r.node_renderer.data_source.inspect, this._update);\n        this.connect(r.edge_renderer.data_source.inspect, this._update);\n      }\n    } // TODO: this.connect(this.plot_model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null)\n\n\n    this.connect(this.model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null);\n    this.connect(this.model.properties.names.change, () => this._computed_renderers = this._ttmodels = null);\n    this.connect(this.model.properties.tooltips.change, () => this._ttmodels = null);\n  }\n\n  _compute_ttmodels() {\n    const ttmodels = {};\n    const tooltips = this.model.tooltips;\n\n    if (tooltips != null) {\n      for (const r of this.computed_renderers) {\n        if (r instanceof GlyphRenderer) {\n          const tooltip = new Tooltip({\n            custom: isString(tooltips) || isFunction(tooltips),\n            attachment: this.model.attachment,\n            show_arrow: this.model.show_arrow\n          });\n          ttmodels[r.id] = tooltip;\n        } else if (r instanceof GraphRenderer) {\n          const tooltip = new Tooltip({\n            custom: isString(tooltips) || isFunction(tooltips),\n            attachment: this.model.attachment,\n            show_arrow: this.model.show_arrow\n          });\n          ttmodels[r.node_renderer.id] = tooltip;\n          ttmodels[r.edge_renderer.id] = tooltip;\n        }\n      }\n    }\n\n    build_views(this.ttviews, values(ttmodels), {\n      parent: this.plot_view\n    });\n    return ttmodels;\n  }\n\n  get computed_renderers() {\n    if (this._computed_renderers == null) {\n      const renderers = this.model.renderers;\n      const all_renderers = this.plot_model.renderers;\n      const names = this.model.names;\n      this._computed_renderers = compute_renderers(renderers, all_renderers, names);\n    }\n\n    return this._computed_renderers;\n  }\n\n  get ttmodels() {\n    if (this._ttmodels == null) this._ttmodels = this._compute_ttmodels();\n    return this._ttmodels;\n  }\n\n  _clear() {\n    this._inspect(Infinity, Infinity);\n\n    for (const rid in this.ttmodels) {\n      const tt = this.ttmodels[rid];\n      tt.clear();\n    }\n  }\n\n  _move(ev) {\n    if (!this.model.active) return;\n    const {\n      sx,\n      sy\n    } = ev;\n    if (!this.plot_view.frame.bbox.contains(sx, sy)) this._clear();else this._inspect(sx, sy);\n  }\n\n  _move_exit() {\n    this._clear();\n  }\n\n  _inspect(sx, sy) {\n    let geometry;\n    if (this.model.mode == 'mouse') geometry = {\n      type: 'point',\n      sx,\n      sy\n    };else {\n      const direction = this.model.mode == 'vline' ? 'h' : 'v';\n      geometry = {\n        type: 'span',\n        direction,\n        sx,\n        sy\n      };\n    }\n\n    for (const r of this.computed_renderers) {\n      const sm = r.get_selection_manager();\n      sm.inspect(this.plot_view.renderer_views[r.id], geometry);\n    }\n\n    if (this.model.callback != null) this._emit_callback(geometry);\n  }\n\n  _update([renderer_view, {\n    geometry\n  }]) {\n    if (!this.model.active) return;\n    if (!(renderer_view instanceof GlyphRendererView || renderer_view instanceof GraphRendererView)) return;\n    const {\n      model: renderer\n    } = renderer_view;\n    if (this.model.muted_policy == 'ignore' && renderer instanceof GlyphRenderer && renderer.muted) return;\n    const tooltip = this.ttmodels[renderer.id];\n    if (tooltip == null) return;\n    tooltip.clear();\n    const selection_manager = renderer.get_selection_manager();\n    let indices = selection_manager.inspectors[renderer.id];\n    if (renderer instanceof GlyphRenderer) indices = renderer.view.convert_selection_to_subset(indices);\n    if (indices.is_empty()) return;\n    const ds = selection_manager.source;\n    const {\n      frame\n    } = this.plot_view;\n    const {\n      sx,\n      sy\n    } = geometry;\n    const xscale = frame.xscales[renderer.x_range_name];\n    const yscale = frame.yscales[renderer.y_range_name];\n    const x = xscale.invert(sx);\n    const y = yscale.invert(sy);\n    const glyph = renderer_view.glyph; // XXX\n\n    for (const i of indices.line_indices) {\n      let data_x = glyph._x[i + 1];\n      let data_y = glyph._y[i + 1];\n      let ii = i;\n      let rx;\n      let ry;\n\n      switch (this.model.line_policy) {\n        case \"interp\":\n          {\n            // and renderer.get_interpolation_hit?\n            [data_x, data_y] = glyph.get_interpolation_hit(i, geometry);\n            rx = xscale.compute(data_x);\n            ry = yscale.compute(data_y);\n            break;\n          }\n\n        case \"prev\":\n          {\n            [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i);\n            break;\n          }\n\n        case \"next\":\n          {\n            [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i + 1);\n            break;\n          }\n\n        case \"nearest\":\n          {\n            [[rx, ry], ii] = _nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy);\n            data_x = glyph._x[ii];\n            data_y = glyph._y[ii];\n            break;\n          }\n\n        default:\n          {\n            [rx, ry] = [sx, sy];\n          }\n      }\n\n      const vars = {\n        index: ii,\n        x,\n        y,\n        sx,\n        sy,\n        data_x,\n        data_y,\n        rx,\n        ry,\n        indices: indices.line_indices,\n        name: renderer_view.model.name\n      };\n      tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));\n    }\n\n    for (const struct of indices.image_indices) {\n      const vars = {\n        index: struct.index,\n        x,\n        y,\n        sx,\n        sy\n      };\n\n      const rendered = this._render_tooltips(ds, struct, vars);\n\n      tooltip.add(sx, sy, rendered);\n    }\n\n    for (const i of indices.indices) {\n      // multiglyphs set additional indices, e.g. multiline_indices for different tooltips\n      if (!isEmpty(indices.multiline_indices)) {\n        for (const j of indices.multiline_indices[i.toString()]) {\n          let data_x = glyph._xs[i][j];\n          let data_y = glyph._ys[i][j];\n          let jj = j;\n          let rx;\n          let ry;\n\n          switch (this.model.line_policy) {\n            case \"interp\":\n              {\n                // and renderer.get_interpolation_hit?\n                [data_x, data_y] = glyph.get_interpolation_hit(i, j, geometry);\n                rx = xscale.compute(data_x);\n                ry = yscale.compute(data_y);\n                break;\n              }\n\n            case \"prev\":\n              {\n                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j);\n                break;\n              }\n\n            case \"next\":\n              {\n                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j + 1);\n                break;\n              }\n\n            case \"nearest\":\n              {\n                [[rx, ry], jj] = _nearest_line_hit(j, geometry, sx, sy, glyph.sxs[i], glyph.sys[i]);\n                data_x = glyph._xs[i][jj];\n                data_y = glyph._ys[i][jj];\n                break;\n              }\n\n            default:\n              throw new Error(\"should't have happened\");\n          }\n\n          let index;\n          if (renderer instanceof GlyphRenderer) index = renderer.view.convert_indices_from_subset([i])[0];else index = i;\n          const vars = {\n            index,\n            x,\n            y,\n            sx,\n            sy,\n            data_x,\n            data_y,\n            segment_index: jj,\n            indices: indices.multiline_indices,\n            name: renderer_view.model.name\n          };\n          tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n        }\n      } else {\n        // handle non-multiglyphs\n        const data_x = glyph._x != null ? glyph._x[i] : undefined;\n        const data_y = glyph._y != null ? glyph._y[i] : undefined;\n        let rx;\n        let ry;\n\n        if (this.model.point_policy == 'snap_to_data') {\n          // and renderer.glyph.sx? and renderer.glyph.sy?\n          // Pass in our screen position so we can determine which patch we're\n          // over if there are discontinuous patches.\n          let pt = glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\n          if (pt == null) pt = glyph.get_anchor_point(\"center\", i, [sx, sy]);\n          rx = pt.x;\n          ry = pt.y;\n        } else [rx, ry] = [sx, sy];\n\n        let index;\n        if (renderer instanceof GlyphRenderer) index = renderer.view.convert_indices_from_subset([i])[0];else index = i;\n        const vars = {\n          index,\n          x,\n          y,\n          sx,\n          sy,\n          data_x,\n          data_y,\n          indices: indices.indices,\n          name: renderer_view.model.name\n        };\n        tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n      }\n    }\n  }\n\n  _emit_callback(geometry) {\n    for (const r of this.computed_renderers) {\n      const index = r.data_source.inspected;\n      const {\n        frame\n      } = this.plot_view;\n      const xscale = frame.xscales[r.x_range_name];\n      const yscale = frame.yscales[r.y_range_name];\n      const x = xscale.invert(geometry.sx);\n      const y = yscale.invert(geometry.sy);\n      const g = Object.assign({\n        x,\n        y\n      }, geometry);\n      this.model.callback.execute(this.model, {\n        index,\n        geometry: g,\n        renderer: r\n      });\n    }\n  }\n\n  _render_tooltips(ds, i, vars) {\n    const tooltips = this.model.tooltips;\n\n    if (isString(tooltips)) {\n      const el = div();\n      el.innerHTML = replace_placeholders(tooltips, ds, i, this.model.formatters, vars);\n      return el;\n    } else if (isFunction(tooltips)) {\n      return tooltips(ds, vars);\n    } else {\n      const rows = div({\n        style: {\n          display: \"table\",\n          borderSpacing: \"2px\"\n        }\n      });\n\n      for (const [label, value] of tooltips) {\n        const row = div({\n          style: {\n            display: \"table-row\"\n          }\n        });\n        rows.appendChild(row);\n        let cell;\n        cell = div({\n          style: {\n            display: \"table-cell\"\n          },\n          class: bk_tooltip_row_label\n        }, label.length != 0 ? `${label}: ` : \"\");\n        row.appendChild(cell);\n        cell = div({\n          style: {\n            display: \"table-cell\"\n          },\n          class: bk_tooltip_row_value\n        });\n        row.appendChild(cell);\n\n        if (value.indexOf(\"$color\") >= 0) {\n          const [, opts = \"\", colname] = value.match(/\\$color(\\[.*\\])?:(\\w*)/); // XXX!\n\n          const column = ds.get_column(colname); // XXX: change to columnar ds\n\n          if (column == null) {\n            const el = span({}, `${colname} unknown`);\n            cell.appendChild(el);\n            continue;\n          }\n\n          const hex = opts.indexOf(\"hex\") >= 0;\n          const swatch = opts.indexOf(\"swatch\") >= 0;\n          let color = isNumber(i) ? column[i] : null;\n\n          if (color == null) {\n            const el = span({}, \"(null)\");\n            cell.appendChild(el);\n            continue;\n          }\n\n          if (hex) color = color2hex(color);\n          let el = span({}, color);\n          cell.appendChild(el);\n\n          if (swatch) {\n            el = span({\n              class: bk_tooltip_color_block,\n              style: {\n                backgroundColor: color\n              }\n            }, \" \");\n            cell.appendChild(el);\n          }\n        } else {\n          const el = span();\n          el.innerHTML = replace_placeholders(value.replace(\"$~\", \"$data_\"), ds, i, this.model.formatters, vars);\n          cell.appendChild(el);\n        }\n      }\n\n      return rows;\n    }\n  }\n\n}\nHoverToolView.__name__ = \"HoverToolView\";\nexport class HoverTool extends InspectTool {\n  constructor(attrs) {\n    super(attrs);\n    this.tool_name = \"Hover\";\n    this.icon = bk_tool_icon_hover;\n  }\n\n  static init_HoverTool() {\n    this.prototype.default_view = HoverToolView;\n    this.define({\n      tooltips: [p.Any, [[\"index\", \"$index\"], [\"data (x, y)\", \"($x, $y)\"], [\"screen (x, y)\", \"($sx, $sy)\"]]],\n      formatters: [p.Any, {}],\n      renderers: [p.Any, 'auto'],\n      names: [p.Array, []],\n      mode: [p.HoverMode, 'mouse'],\n      muted_policy: [p.MutedPolicy, 'show'],\n      point_policy: [p.PointPolicy, 'snap_to_data'],\n      line_policy: [p.LinePolicy, 'nearest'],\n      show_arrow: [p.Boolean, true],\n      anchor: [p.Anchor, 'center'],\n      attachment: [p.TooltipAttachment, 'horizontal'],\n      callback: [p.Any]\n    });\n    this.register_alias(\"hover\", () => new HoverTool());\n  }\n\n}\nHoverTool.__name__ = \"HoverTool\";\nHoverTool.init_HoverTool();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/hover_tool.js"],"names":["InspectTool","InspectToolView","Tooltip","GlyphRenderer","GlyphRendererView","GraphRenderer","GraphRendererView","compute_renderers","hittest","replace_placeholders","div","span","p","color2hex","values","isEmpty","isString","isFunction","isNumber","build_views","remove_views","bk_tool_icon_hover","bk_tooltip_row_label","bk_tooltip_row_value","bk_tooltip_color_block","_nearest_line_hit","i","geometry","sx","sy","dx","dy","d1","x","y","d2","dist1","dist2","type","direction","Math","abs","s","dist_2_pts","_line_hit","xs","ys","ind","HoverToolView","initialize","ttviews","remove","connect_signals","r","computed_renderers","connect","data_source","inspect","_update","node_renderer","edge_renderer","model","properties","renderers","change","_computed_renderers","_ttmodels","names","tooltips","_compute_ttmodels","ttmodels","tooltip","custom","attachment","show_arrow","id","parent","plot_view","all_renderers","plot_model","_clear","_inspect","Infinity","rid","tt","clear","_move","ev","active","frame","bbox","contains","_move_exit","mode","sm","get_selection_manager","renderer_views","callback","_emit_callback","renderer_view","renderer","muted_policy","muted","selection_manager","indices","inspectors","view","convert_selection_to_subset","is_empty","ds","source","xscale","xscales","x_range_name","yscale","yscales","y_range_name","invert","glyph","line_indices","data_x","_x","data_y","_y","ii","rx","ry","line_policy","get_interpolation_hit","compute","vars","index","name","add","_render_tooltips","struct","image_indices","rendered","multiline_indices","j","toString","_xs","_ys","jj","sxs","sys","Error","convert_indices_from_subset","segment_index","undefined","point_policy","pt","get_anchor_point","anchor","inspected","g","Object","assign","execute","el","innerHTML","formatters","rows","style","display","borderSpacing","label","value","row","appendChild","cell","class","length","indexOf","opts","colname","match","column","get_column","hex","swatch","color","backgroundColor","replace","__name__","HoverTool","constructor","attrs","tool_name","icon","init_HoverTool","prototype","default_view","define","Any","Array","HoverMode","MutedPolicy","PointPolicy","LinePolicy","Boolean","Anchor","TooltipAttachment","register_alias"],"mappings":"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","sourcesContent":["import { InspectTool, InspectToolView } from \"./inspect_tool\";\nimport { Tooltip } from \"../../annotations/tooltip\";\nimport { GlyphRenderer, GlyphRendererView } from \"../../renderers/glyph_renderer\";\nimport { GraphRenderer, GraphRendererView } from \"../../renderers/graph_renderer\";\nimport { compute_renderers } from \"../util\";\nimport * as hittest from \"../../../core/hittest\";\nimport { replace_placeholders } from \"../../../core/util/templating\";\nimport { div, span } from \"../../../core/dom\";\nimport * as p from \"../../../core/properties\";\nimport { color2hex } from \"../../../core/util/color\";\nimport { values, isEmpty } from \"../../../core/util/object\";\nimport { isString, isFunction, isNumber } from \"../../../core/util/types\";\nimport { build_views, remove_views } from \"../../../core/build_views\";\nimport { bk_tool_icon_hover } from \"../../../styles/icons\";\nimport { bk_tooltip_row_label, bk_tooltip_row_value, bk_tooltip_color_block } from \"../../../styles/tooltips\";\nexport function _nearest_line_hit(i, geometry, sx, sy, dx, dy) {\n    const d1 = { x: dx[i], y: dy[i] };\n    const d2 = { x: dx[i + 1], y: dy[i + 1] };\n    let dist1;\n    let dist2;\n    if (geometry.type == \"span\") {\n        if (geometry.direction == \"h\") {\n            dist1 = Math.abs(d1.x - sx);\n            dist2 = Math.abs(d2.x - sx);\n        }\n        else {\n            dist1 = Math.abs(d1.y - sy);\n            dist2 = Math.abs(d2.y - sy);\n        }\n    }\n    else {\n        const s = { x: sx, y: sy };\n        dist1 = hittest.dist_2_pts(d1, s);\n        dist2 = hittest.dist_2_pts(d2, s);\n    }\n    if (dist1 < dist2)\n        return [[d1.x, d1.y], i];\n    else\n        return [[d2.x, d2.y], i + 1];\n}\nexport function _line_hit(xs, ys, ind) {\n    return [[xs[ind], ys[ind]], ind];\n}\nexport class HoverToolView extends InspectToolView {\n    initialize() {\n        super.initialize();\n        this.ttviews = {};\n    }\n    remove() {\n        remove_views(this.ttviews);\n        super.remove();\n    }\n    connect_signals() {\n        super.connect_signals();\n        for (const r of this.computed_renderers) {\n            if (r instanceof GlyphRenderer)\n                this.connect(r.data_source.inspect, this._update);\n            else if (r instanceof GraphRenderer) {\n                this.connect(r.node_renderer.data_source.inspect, this._update);\n                this.connect(r.edge_renderer.data_source.inspect, this._update);\n            }\n        }\n        // TODO: this.connect(this.plot_model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null)\n        this.connect(this.model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null);\n        this.connect(this.model.properties.names.change, () => this._computed_renderers = this._ttmodels = null);\n        this.connect(this.model.properties.tooltips.change, () => this._ttmodels = null);\n    }\n    _compute_ttmodels() {\n        const ttmodels = {};\n        const tooltips = this.model.tooltips;\n        if (tooltips != null) {\n            for (const r of this.computed_renderers) {\n                if (r instanceof GlyphRenderer) {\n                    const tooltip = new Tooltip({\n                        custom: isString(tooltips) || isFunction(tooltips),\n                        attachment: this.model.attachment,\n                        show_arrow: this.model.show_arrow,\n                    });\n                    ttmodels[r.id] = tooltip;\n                }\n                else if (r instanceof GraphRenderer) {\n                    const tooltip = new Tooltip({\n                        custom: isString(tooltips) || isFunction(tooltips),\n                        attachment: this.model.attachment,\n                        show_arrow: this.model.show_arrow,\n                    });\n                    ttmodels[r.node_renderer.id] = tooltip;\n                    ttmodels[r.edge_renderer.id] = tooltip;\n                }\n            }\n        }\n        build_views(this.ttviews, values(ttmodels), { parent: this.plot_view });\n        return ttmodels;\n    }\n    get computed_renderers() {\n        if (this._computed_renderers == null) {\n            const renderers = this.model.renderers;\n            const all_renderers = this.plot_model.renderers;\n            const names = this.model.names;\n            this._computed_renderers = compute_renderers(renderers, all_renderers, names);\n        }\n        return this._computed_renderers;\n    }\n    get ttmodels() {\n        if (this._ttmodels == null)\n            this._ttmodels = this._compute_ttmodels();\n        return this._ttmodels;\n    }\n    _clear() {\n        this._inspect(Infinity, Infinity);\n        for (const rid in this.ttmodels) {\n            const tt = this.ttmodels[rid];\n            tt.clear();\n        }\n    }\n    _move(ev) {\n        if (!this.model.active)\n            return;\n        const { sx, sy } = ev;\n        if (!this.plot_view.frame.bbox.contains(sx, sy))\n            this._clear();\n        else\n            this._inspect(sx, sy);\n    }\n    _move_exit() {\n        this._clear();\n    }\n    _inspect(sx, sy) {\n        let geometry;\n        if (this.model.mode == 'mouse')\n            geometry = { type: 'point', sx, sy };\n        else {\n            const direction = this.model.mode == 'vline' ? 'h' : 'v';\n            geometry = { type: 'span', direction, sx, sy };\n        }\n        for (const r of this.computed_renderers) {\n            const sm = r.get_selection_manager();\n            sm.inspect(this.plot_view.renderer_views[r.id], geometry);\n        }\n        if (this.model.callback != null)\n            this._emit_callback(geometry);\n    }\n    _update([renderer_view, { geometry }]) {\n        if (!this.model.active)\n            return;\n        if (!(renderer_view instanceof GlyphRendererView || renderer_view instanceof GraphRendererView))\n            return;\n        const { model: renderer } = renderer_view;\n        if (this.model.muted_policy == 'ignore' && renderer instanceof GlyphRenderer && renderer.muted)\n            return;\n        const tooltip = this.ttmodels[renderer.id];\n        if (tooltip == null)\n            return;\n        tooltip.clear();\n        const selection_manager = renderer.get_selection_manager();\n        let indices = selection_manager.inspectors[renderer.id];\n        if (renderer instanceof GlyphRenderer)\n            indices = renderer.view.convert_selection_to_subset(indices);\n        if (indices.is_empty())\n            return;\n        const ds = selection_manager.source;\n        const { frame } = this.plot_view;\n        const { sx, sy } = geometry;\n        const xscale = frame.xscales[renderer.x_range_name];\n        const yscale = frame.yscales[renderer.y_range_name];\n        const x = xscale.invert(sx);\n        const y = yscale.invert(sy);\n        const glyph = renderer_view.glyph; // XXX\n        for (const i of indices.line_indices) {\n            let data_x = glyph._x[i + 1];\n            let data_y = glyph._y[i + 1];\n            let ii = i;\n            let rx;\n            let ry;\n            switch (this.model.line_policy) {\n                case \"interp\": { // and renderer.get_interpolation_hit?\n                    [data_x, data_y] = glyph.get_interpolation_hit(i, geometry);\n                    rx = xscale.compute(data_x);\n                    ry = yscale.compute(data_y);\n                    break;\n                }\n                case \"prev\": {\n                    [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i);\n                    break;\n                }\n                case \"next\": {\n                    [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i + 1);\n                    break;\n                }\n                case \"nearest\": {\n                    [[rx, ry], ii] = _nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy);\n                    data_x = glyph._x[ii];\n                    data_y = glyph._y[ii];\n                    break;\n                }\n                default: {\n                    [rx, ry] = [sx, sy];\n                }\n            }\n            const vars = {\n                index: ii,\n                x, y, sx, sy, data_x, data_y, rx, ry,\n                indices: indices.line_indices,\n                name: renderer_view.model.name,\n            };\n            tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));\n        }\n        for (const struct of indices.image_indices) {\n            const vars = { index: struct.index, x, y, sx, sy };\n            const rendered = this._render_tooltips(ds, struct, vars);\n            tooltip.add(sx, sy, rendered);\n        }\n        for (const i of indices.indices) {\n            // multiglyphs set additional indices, e.g. multiline_indices for different tooltips\n            if (!isEmpty(indices.multiline_indices)) {\n                for (const j of indices.multiline_indices[i.toString()]) {\n                    let data_x = glyph._xs[i][j];\n                    let data_y = glyph._ys[i][j];\n                    let jj = j;\n                    let rx;\n                    let ry;\n                    switch (this.model.line_policy) {\n                        case \"interp\": { // and renderer.get_interpolation_hit?\n                            [data_x, data_y] = glyph.get_interpolation_hit(i, j, geometry);\n                            rx = xscale.compute(data_x);\n                            ry = yscale.compute(data_y);\n                            break;\n                        }\n                        case \"prev\": {\n                            [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j);\n                            break;\n                        }\n                        case \"next\": {\n                            [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j + 1);\n                            break;\n                        }\n                        case \"nearest\": {\n                            [[rx, ry], jj] = _nearest_line_hit(j, geometry, sx, sy, glyph.sxs[i], glyph.sys[i]);\n                            data_x = glyph._xs[i][jj];\n                            data_y = glyph._ys[i][jj];\n                            break;\n                        }\n                        default:\n                            throw new Error(\"should't have happened\");\n                    }\n                    let index;\n                    if (renderer instanceof GlyphRenderer)\n                        index = renderer.view.convert_indices_from_subset([i])[0];\n                    else\n                        index = i;\n                    const vars = {\n                        index, x, y, sx, sy, data_x, data_y,\n                        segment_index: jj,\n                        indices: indices.multiline_indices,\n                        name: renderer_view.model.name,\n                    };\n                    tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n                }\n            }\n            else {\n                // handle non-multiglyphs\n                const data_x = glyph._x != null ? glyph._x[i] : undefined;\n                const data_y = glyph._y != null ? glyph._y[i] : undefined;\n                let rx;\n                let ry;\n                if (this.model.point_policy == 'snap_to_data') { // and renderer.glyph.sx? and renderer.glyph.sy?\n                    // Pass in our screen position so we can determine which patch we're\n                    // over if there are discontinuous patches.\n                    let pt = glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\n                    if (pt == null)\n                        pt = glyph.get_anchor_point(\"center\", i, [sx, sy]);\n                    rx = pt.x;\n                    ry = pt.y;\n                }\n                else\n                    [rx, ry] = [sx, sy];\n                let index;\n                if (renderer instanceof GlyphRenderer)\n                    index = renderer.view.convert_indices_from_subset([i])[0];\n                else\n                    index = i;\n                const vars = {\n                    index, x, y, sx, sy, data_x, data_y,\n                    indices: indices.indices,\n                    name: renderer_view.model.name,\n                };\n                tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n            }\n        }\n    }\n    _emit_callback(geometry) {\n        for (const r of this.computed_renderers) {\n            const index = r.data_source.inspected;\n            const { frame } = this.plot_view;\n            const xscale = frame.xscales[r.x_range_name];\n            const yscale = frame.yscales[r.y_range_name];\n            const x = xscale.invert(geometry.sx);\n            const y = yscale.invert(geometry.sy);\n            const g = Object.assign({ x, y }, geometry);\n            this.model.callback.execute(this.model, { index, geometry: g, renderer: r });\n        }\n    }\n    _render_tooltips(ds, i, vars) {\n        const tooltips = this.model.tooltips;\n        if (isString(tooltips)) {\n            const el = div();\n            el.innerHTML = replace_placeholders(tooltips, ds, i, this.model.formatters, vars);\n            return el;\n        }\n        else if (isFunction(tooltips)) {\n            return tooltips(ds, vars);\n        }\n        else {\n            const rows = div({ style: { display: \"table\", borderSpacing: \"2px\" } });\n            for (const [label, value] of tooltips) {\n                const row = div({ style: { display: \"table-row\" } });\n                rows.appendChild(row);\n                let cell;\n                cell = div({ style: { display: \"table-cell\" }, class: bk_tooltip_row_label }, label.length != 0 ? `${label}: ` : \"\");\n                row.appendChild(cell);\n                cell = div({ style: { display: \"table-cell\" }, class: bk_tooltip_row_value });\n                row.appendChild(cell);\n                if (value.indexOf(\"$color\") >= 0) {\n                    const [, opts = \"\", colname] = value.match(/\\$color(\\[.*\\])?:(\\w*)/); // XXX!\n                    const column = ds.get_column(colname); // XXX: change to columnar ds\n                    if (column == null) {\n                        const el = span({}, `${colname} unknown`);\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    const hex = opts.indexOf(\"hex\") >= 0;\n                    const swatch = opts.indexOf(\"swatch\") >= 0;\n                    let color = isNumber(i) ? column[i] : null;\n                    if (color == null) {\n                        const el = span({}, \"(null)\");\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    if (hex)\n                        color = color2hex(color);\n                    let el = span({}, color);\n                    cell.appendChild(el);\n                    if (swatch) {\n                        el = span({ class: bk_tooltip_color_block, style: { backgroundColor: color } }, \" \");\n                        cell.appendChild(el);\n                    }\n                }\n                else {\n                    const el = span();\n                    el.innerHTML = replace_placeholders(value.replace(\"$~\", \"$data_\"), ds, i, this.model.formatters, vars);\n                    cell.appendChild(el);\n                }\n            }\n            return rows;\n        }\n    }\n}\nHoverToolView.__name__ = \"HoverToolView\";\nexport class HoverTool extends InspectTool {\n    constructor(attrs) {\n        super(attrs);\n        this.tool_name = \"Hover\";\n        this.icon = bk_tool_icon_hover;\n    }\n    static init_HoverTool() {\n        this.prototype.default_view = HoverToolView;\n        this.define({\n            tooltips: [p.Any, [\n                    [\"index\", \"$index\"],\n                    [\"data (x, y)\", \"($x, $y)\"],\n                    [\"screen (x, y)\", \"($sx, $sy)\"],\n                ]],\n            formatters: [p.Any, {}],\n            renderers: [p.Any, 'auto'],\n            names: [p.Array, []],\n            mode: [p.HoverMode, 'mouse'],\n            muted_policy: [p.MutedPolicy, 'show'],\n            point_policy: [p.PointPolicy, 'snap_to_data'],\n            line_policy: [p.LinePolicy, 'nearest'],\n            show_arrow: [p.Boolean, true],\n            anchor: [p.Anchor, 'center'],\n            attachment: [p.TooltipAttachment, 'horizontal'],\n            callback: [p.Any],\n        });\n        this.register_alias(\"hover\", () => new HoverTool());\n    }\n}\nHoverTool.__name__ = \"HoverTool\";\nHoverTool.init_HoverTool();\n//# sourceMappingURL=hover_tool.js.map"]},"metadata":{},"sourceType":"module"}