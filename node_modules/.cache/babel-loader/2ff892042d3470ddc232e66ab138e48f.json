{"ast":null,"code":"import { Program, VertexBuffer, IndexBuffer } from \"@bokeh/gloo2\";\nimport { BaseGLGlyph, attach_float, attach_color } from \"./base\";\nimport { vertex_shader } from \"./markers.vert\";\nimport { fragment_shader } from \"./markers.frag\";\nimport { CircleView } from \"../circle\";\nimport { map } from \"../../../core/util/arrayable\";\nimport { logger } from \"../../../core/logging\"; // Base class for markers. All markers share the same GLSL, except for one\n// function that defines the marker geometry.\n\nexport class MarkerGLGlyph extends BaseGLGlyph {\n  init() {\n    const {\n      gl\n    } = this;\n    const vert = vertex_shader;\n    const frag = fragment_shader(this._marker_code); // The program\n\n    this.prog = new Program(gl);\n    this.prog.set_shaders(vert, frag); // Real attributes\n\n    this.vbo_x = new VertexBuffer(gl);\n    this.prog.set_attribute('a_x', 'float', this.vbo_x);\n    this.vbo_y = new VertexBuffer(gl);\n    this.prog.set_attribute('a_y', 'float', this.vbo_y);\n    this.vbo_s = new VertexBuffer(gl);\n    this.prog.set_attribute('a_size', 'float', this.vbo_s);\n    this.vbo_a = new VertexBuffer(gl);\n    this.prog.set_attribute('a_angle', 'float', this.vbo_a); // VBO's for attributes (they may not be used if value is singleton)\n\n    this.vbo_linewidth = new VertexBuffer(gl);\n    this.vbo_fg_color = new VertexBuffer(gl);\n    this.vbo_bg_color = new VertexBuffer(gl);\n    this.index_buffer = new IndexBuffer(gl);\n  }\n\n  draw(indices, mainGlyph, trans) {\n    // The main glyph has the data, *this* glyph has the visuals.\n    const mainGlGlyph = mainGlyph.glglyph;\n    const {\n      nvertices\n    } = mainGlGlyph; // Upload data if we must. Only happens for main glyph.\n\n    if (mainGlGlyph.data_changed) {\n      if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n        return; // not sure why, but it happens on init sometimes (#4367)\n      }\n\n      mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _set_data() and below\n\n      mainGlGlyph._set_data(nvertices);\n\n      mainGlGlyph.data_changed = false;\n    } else if (this.glyph instanceof CircleView && this.glyph._radius != null && (this.last_trans == null || trans.sx != this.last_trans.sx || trans.sy != this.last_trans.sy)) {\n      // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n      this.last_trans = trans;\n      this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, s => s * 2)));\n    } // Update visuals if we must. Can happen for all glyphs.\n\n\n    if (this.visuals_changed) {\n      this._set_visuals(nvertices);\n\n      this.visuals_changed = false;\n    } // Handle transformation to device coordinates\n    // Note the baked-in offset to avoid float32 precision problems\n\n\n    const baked_offset = mainGlGlyph._baked_offset;\n    this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n    this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n    this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n    this.prog.set_uniform('u_scale', 'vec2', [trans.sx, trans.sy]); // Select buffers from main glyph\n    // (which may be this glyph but maybe not if this is a (non)selection glyph)\n\n    this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n    this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n    this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n    this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a); // Draw directly or using indices. Do not handle indices if they do not\n    // fit in a uint16; WebGL 1.0 does not support uint32.\n\n    if (indices.length == 0) return;else if (indices.length === nvertices) this.prog.draw(this.gl.POINTS, [0, nvertices]);else if (nvertices < 65535) {\n      // On IE the marker size is reduced to 1 px when using an index buffer\n      // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n      // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n      // next renderer update.\n      const ua = window.navigator.userAgent;\n\n      if (ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\") > 0) {\n        logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n      }\n\n      this.index_buffer.set_size(indices.length * 2);\n      this.index_buffer.set_data(0, new Uint16Array(indices));\n      this.prog.draw(this.gl.POINTS, this.index_buffer);\n    } else {\n      // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n      // First collect indices in chunks\n      const chunksize = 64000; // 65536\n\n      const chunks = [];\n\n      for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n        chunks.push([]);\n      }\n\n      for (let i = 0, end = indices.length; i < end; i++) {\n        const uint16_index = indices[i] % chunksize;\n        const chunk = Math.floor(indices[i] / chunksize);\n        chunks[chunk].push(uint16_index);\n      } // Then draw each chunk\n\n\n      for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n        const these_indices = new Uint16Array(chunks[chunk]);\n        const offset = chunk * chunksize * 4;\n\n        if (these_indices.length === 0) {\n          continue;\n        }\n\n        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n\n        if (this.vbo_linewidth.used) {\n          this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n        }\n\n        if (this.vbo_fg_color.used) {\n          this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n        }\n\n        if (this.vbo_bg_color.used) {\n          this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n        } // The actual drawing\n\n\n        this.index_buffer.set_size(these_indices.length * 2);\n        this.index_buffer.set_data(0, these_indices);\n        this.prog.draw(this.gl.POINTS, this.index_buffer);\n      }\n    }\n  }\n\n  _set_data(nvertices) {\n    const n = nvertices * 4; // in bytes\n    // Set buffer size\n\n    this.vbo_x.set_size(n);\n    this.vbo_y.set_size(n);\n    this.vbo_a.set_size(n);\n    this.vbo_s.set_size(n); // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n    // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n\n    const xx = new Float64Array(this.glyph._x);\n    const yy = new Float64Array(this.glyph._y);\n\n    for (let i = 0, end = nvertices; i < end; i++) {\n      xx[i] += this._baked_offset[0];\n      yy[i] += this._baked_offset[1];\n    }\n\n    this.vbo_x.set_data(0, new Float32Array(xx));\n    this.vbo_y.set_data(0, new Float32Array(yy)); // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n\n    if (this.glyph._angle != null) {\n      this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n    } // Radius is special; some markers allow radius in data-coords instead of screen coords\n    // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n\n\n    if (this.glyph instanceof CircleView && this.glyph._radius != null) this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, s => s * 2)));else this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n  }\n\n  _set_visuals(nvertices) {\n    attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n    attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n    attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill'); // Static value for antialias. Smaller aa-region to obtain crisper images\n\n    this.prog.set_uniform('u_antialias', 'float', [0.8]);\n  }\n\n}\nMarkerGLGlyph.__name__ = \"MarkerGLGlyph\";\n\nfunction mk_marker(code) {\n  return class extends MarkerGLGlyph {\n    get _marker_code() {\n      return code;\n    }\n\n  };\n}\n\nimport * as glsl from \"./markers.frag\";\nexport const CircleGLGlyph = mk_marker(glsl.circle);\nexport const SquareGLGlyph = mk_marker(glsl.square);\nexport const DiamondGLGlyph = mk_marker(glsl.diamond);\nexport const TriangleGLGlyph = mk_marker(glsl.triangle);\nexport const InvertedTriangleGLGlyph = mk_marker(glsl.invertedtriangle);\nexport const HexGLGlyph = mk_marker(glsl.hex);\nexport const CrossGLGlyph = mk_marker(glsl.cross);\nexport const CircleCrossGLGlyph = mk_marker(glsl.circlecross);\nexport const SquareCrossGLGlyph = mk_marker(glsl.squarecross);\nexport const DiamondCrossGLGlyph = mk_marker(glsl.diamondcross);\nexport const XGLGlyph = mk_marker(glsl.x);\nexport const CircleXGLGlyph = mk_marker(glsl.circlex);\nexport const SquareXGLGlyph = mk_marker(glsl.squarex);\nexport const AsteriskGLGlyph = mk_marker(glsl.asterisk);","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/markers.js"],"names":["Program","VertexBuffer","IndexBuffer","BaseGLGlyph","attach_float","attach_color","vertex_shader","fragment_shader","CircleView","map","logger","MarkerGLGlyph","init","gl","vert","frag","_marker_code","prog","set_shaders","vbo_x","set_attribute","vbo_y","vbo_s","vbo_a","vbo_linewidth","vbo_fg_color","vbo_bg_color","index_buffer","draw","indices","mainGlyph","trans","mainGlGlyph","glglyph","nvertices","data_changed","isFinite","dx","dy","_baked_offset","_set_data","glyph","_radius","last_trans","sx","sy","set_data","Float32Array","sradius","s","visuals_changed","_set_visuals","baked_offset","set_uniform","pixel_ratio","width","height","length","POINTS","ua","window","navigator","userAgent","indexOf","warn","set_size","Uint16Array","chunksize","chunks","i","end","Math","ceil","push","uint16_index","chunk","floor","these_indices","offset","used","n","xx","Float64Array","_x","yy","_y","_angle","_size","visuals","line","fill","__name__","mk_marker","code","glsl","CircleGLGlyph","circle","SquareGLGlyph","square","DiamondGLGlyph","diamond","TriangleGLGlyph","triangle","InvertedTriangleGLGlyph","invertedtriangle","HexGLGlyph","hex","CrossGLGlyph","cross","CircleCrossGLGlyph","circlecross","SquareCrossGLGlyph","squarecross","DiamondCrossGLGlyph","diamondcross","XGLGlyph","x","CircleXGLGlyph","circlex","SquareXGLGlyph","squarex","AsteriskGLGlyph","asterisk"],"mappings":"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","sourcesContent":["import { Program, VertexBuffer, IndexBuffer } from \"@bokeh/gloo2\";\nimport { BaseGLGlyph, attach_float, attach_color } from \"./base\";\nimport { vertex_shader } from \"./markers.vert\";\nimport { fragment_shader } from \"./markers.frag\";\nimport { CircleView } from \"../circle\";\nimport { map } from \"../../../core/util/arrayable\";\nimport { logger } from \"../../../core/logging\";\n// Base class for markers. All markers share the same GLSL, except for one\n// function that defines the marker geometry.\nexport class MarkerGLGlyph extends BaseGLGlyph {\n    init() {\n        const { gl } = this;\n        const vert = vertex_shader;\n        const frag = fragment_shader(this._marker_code);\n        // The program\n        this.prog = new Program(gl);\n        this.prog.set_shaders(vert, frag);\n        // Real attributes\n        this.vbo_x = new VertexBuffer(gl);\n        this.prog.set_attribute('a_x', 'float', this.vbo_x);\n        this.vbo_y = new VertexBuffer(gl);\n        this.prog.set_attribute('a_y', 'float', this.vbo_y);\n        this.vbo_s = new VertexBuffer(gl);\n        this.prog.set_attribute('a_size', 'float', this.vbo_s);\n        this.vbo_a = new VertexBuffer(gl);\n        this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n        // VBO's for attributes (they may not be used if value is singleton)\n        this.vbo_linewidth = new VertexBuffer(gl);\n        this.vbo_fg_color = new VertexBuffer(gl);\n        this.vbo_bg_color = new VertexBuffer(gl);\n        this.index_buffer = new IndexBuffer(gl);\n    }\n    draw(indices, mainGlyph, trans) {\n        // The main glyph has the data, *this* glyph has the visuals.\n        const mainGlGlyph = mainGlyph.glglyph;\n        const { nvertices } = mainGlGlyph;\n        // Upload data if we must. Only happens for main glyph.\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return; // not sure why, but it happens on init sometimes (#4367)\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _set_data() and below\n            mainGlGlyph._set_data(nvertices);\n            mainGlGlyph.data_changed = false;\n        }\n        else if (this.glyph instanceof CircleView && this.glyph._radius != null &&\n            (this.last_trans == null || trans.sx != this.last_trans.sx || trans.sy != this.last_trans.sy)) {\n            // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n            this.last_trans = trans;\n            this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, (s) => s * 2)));\n        }\n        // Update visuals if we must. Can happen for all glyphs.\n        if (this.visuals_changed) {\n            this._set_visuals(nvertices);\n            this.visuals_changed = false;\n        }\n        // Handle transformation to device coordinates\n        // Note the baked-in offset to avoid float32 precision problems\n        const baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale', 'vec2', [trans.sx, trans.sy]);\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n        // Draw directly or using indices. Do not handle indices if they do not\n        // fit in a uint16; WebGL 1.0 does not support uint32.\n        if (indices.length == 0)\n            return;\n        else if (indices.length === nvertices)\n            this.prog.draw(this.gl.POINTS, [0, nvertices]);\n        else if (nvertices < 65535) {\n            // On IE the marker size is reduced to 1 px when using an index buffer\n            // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n            // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n            // next renderer update.\n            const ua = window.navigator.userAgent;\n            if ((ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\")) > 0) {\n                logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n            }\n            this.index_buffer.set_size(indices.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(indices));\n            this.prog.draw(this.gl.POINTS, this.index_buffer);\n        }\n        else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            const chunksize = 64000; // 65536\n            const chunks = [];\n            for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n                chunks.push([]);\n            }\n            for (let i = 0, end = indices.length; i < end; i++) {\n                const uint16_index = indices[i] % chunksize;\n                const chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            // Then draw each chunk\n            for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n                const these_indices = new Uint16Array(chunks[chunk]);\n                const offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                if (this.vbo_linewidth.used) {\n                    this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                }\n                if (this.vbo_fg_color.used) {\n                    this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                }\n                if (this.vbo_bg_color.used) {\n                    this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                }\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                this.prog.draw(this.gl.POINTS, this.index_buffer);\n            }\n        }\n    }\n    _set_data(nvertices) {\n        const n = nvertices * 4; // in bytes\n        // Set buffer size\n        this.vbo_x.set_size(n);\n        this.vbo_y.set_size(n);\n        this.vbo_a.set_size(n);\n        this.vbo_s.set_size(n);\n        // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n        // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n        const xx = new Float64Array(this.glyph._x);\n        const yy = new Float64Array(this.glyph._y);\n        for (let i = 0, end = nvertices; i < end; i++) {\n            xx[i] += this._baked_offset[0];\n            yy[i] += this._baked_offset[1];\n        }\n        this.vbo_x.set_data(0, new Float32Array(xx));\n        this.vbo_y.set_data(0, new Float32Array(yy));\n        // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n        if (this.glyph._angle != null) {\n            this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n        }\n        // Radius is special; some markers allow radius in data-coords instead of screen coords\n        // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n        if (this.glyph instanceof CircleView && this.glyph._radius != null)\n            this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, (s) => s * 2)));\n        else\n            this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n    }\n    _set_visuals(nvertices) {\n        attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n        attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n        attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n        // Static value for antialias. Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_antialias', 'float', [0.8]);\n    }\n}\nMarkerGLGlyph.__name__ = \"MarkerGLGlyph\";\nfunction mk_marker(code) {\n    return class extends MarkerGLGlyph {\n        get _marker_code() {\n            return code;\n        }\n    };\n}\nimport * as glsl from \"./markers.frag\";\nexport const CircleGLGlyph = mk_marker(glsl.circle);\nexport const SquareGLGlyph = mk_marker(glsl.square);\nexport const DiamondGLGlyph = mk_marker(glsl.diamond);\nexport const TriangleGLGlyph = mk_marker(glsl.triangle);\nexport const InvertedTriangleGLGlyph = mk_marker(glsl.invertedtriangle);\nexport const HexGLGlyph = mk_marker(glsl.hex);\nexport const CrossGLGlyph = mk_marker(glsl.cross);\nexport const CircleCrossGLGlyph = mk_marker(glsl.circlecross);\nexport const SquareCrossGLGlyph = mk_marker(glsl.squarecross);\nexport const DiamondCrossGLGlyph = mk_marker(glsl.diamondcross);\nexport const XGLGlyph = mk_marker(glsl.x);\nexport const CircleXGLGlyph = mk_marker(glsl.circlex);\nexport const SquareXGLGlyph = mk_marker(glsl.squarex);\nexport const AsteriskGLGlyph = mk_marker(glsl.asterisk);\n//# sourceMappingURL=markers.js.map"]},"metadata":{},"sourceType":"module"}