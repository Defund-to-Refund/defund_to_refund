{"ast":null,"code":"import { ContinuousColorMapper } from \"./continuous_color_mapper\";\nimport { min, max } from \"../../core/util/arrayable\";\nexport class LinearColorMapper extends ContinuousColorMapper {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  _v_compute(data, values, palette, colors) {\n    const {\n      nan_color,\n      low_color,\n      high_color\n    } = colors;\n    const low = this.low != null ? this.low : min(data);\n    const high = this.high != null ? this.high : max(data);\n    const max_key = palette.length - 1;\n    const norm_factor = 1 / (high - low);\n    const normed_interval = 1 / palette.length;\n\n    for (let i = 0, end = data.length; i < end; i++) {\n      const d = data[i];\n\n      if (isNaN(d)) {\n        values[i] = nan_color;\n        continue;\n      } // This handles the edge case where d == high, since the code below maps\n      // values exactly equal to high to palette.length, which is greater than\n      // max_key\n\n\n      if (d == high) {\n        values[i] = palette[max_key];\n        continue;\n      }\n\n      const normed_d = (d - low) * norm_factor;\n      const key = Math.floor(normed_d / normed_interval);\n      if (key < 0) values[i] = low_color != null ? low_color : palette[0];else if (key > max_key) values[i] = high_color != null ? high_color : palette[max_key];else values[i] = palette[key];\n    }\n  }\n\n}\nLinearColorMapper.__name__ = \"LinearColorMapper\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/linear_color_mapper.js"],"names":["ContinuousColorMapper","min","max","LinearColorMapper","constructor","attrs","_v_compute","data","values","palette","colors","nan_color","low_color","high_color","low","high","max_key","length","norm_factor","normed_interval","i","end","d","isNaN","normed_d","key","Math","floor","__name__"],"mappings":"AAAA,SAASA,qBAAT,QAAsC,2BAAtC;AACA,SAASC,GAAT,EAAcC,GAAd,QAAyB,2BAAzB;AACA,OAAO,MAAMC,iBAAN,SAAgCH,qBAAhC,CAAsD;AACzDI,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACDC,EAAAA,UAAU,CAACC,IAAD,EAAOC,MAAP,EAAeC,OAAf,EAAwBC,MAAxB,EAAgC;AACtC,UAAM;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA;AAAxB,QAAuCH,MAA7C;AACA,UAAMI,GAAG,GAAG,KAAKA,GAAL,IAAY,IAAZ,GAAmB,KAAKA,GAAxB,GAA8Bb,GAAG,CAACM,IAAD,CAA7C;AACA,UAAMQ,IAAI,GAAG,KAAKA,IAAL,IAAa,IAAb,GAAoB,KAAKA,IAAzB,GAAgCb,GAAG,CAACK,IAAD,CAAhD;AACA,UAAMS,OAAO,GAAGP,OAAO,CAACQ,MAAR,GAAiB,CAAjC;AACA,UAAMC,WAAW,GAAG,KAAKH,IAAI,GAAGD,GAAZ,CAApB;AACA,UAAMK,eAAe,GAAG,IAAIV,OAAO,CAACQ,MAApC;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGd,IAAI,CAACU,MAA3B,EAAmCG,CAAC,GAAGC,GAAvC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,YAAME,CAAC,GAAGf,IAAI,CAACa,CAAD,CAAd;;AACA,UAAIG,KAAK,CAACD,CAAD,CAAT,EAAc;AACVd,QAAAA,MAAM,CAACY,CAAD,CAAN,GAAYT,SAAZ;AACA;AACH,OAL4C,CAM7C;AACA;AACA;;;AACA,UAAIW,CAAC,IAAIP,IAAT,EAAe;AACXP,QAAAA,MAAM,CAACY,CAAD,CAAN,GAAYX,OAAO,CAACO,OAAD,CAAnB;AACA;AACH;;AACD,YAAMQ,QAAQ,GAAG,CAACF,CAAC,GAAGR,GAAL,IAAYI,WAA7B;AACA,YAAMO,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAWH,QAAQ,GAAGL,eAAtB,CAAZ;AACA,UAAIM,GAAG,GAAG,CAAV,EACIjB,MAAM,CAACY,CAAD,CAAN,GAAYR,SAAS,IAAI,IAAb,GAAoBA,SAApB,GAAgCH,OAAO,CAAC,CAAD,CAAnD,CADJ,KAEK,IAAIgB,GAAG,GAAGT,OAAV,EACDR,MAAM,CAACY,CAAD,CAAN,GAAYP,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCJ,OAAO,CAACO,OAAD,CAArD,CADC,KAGDR,MAAM,CAACY,CAAD,CAAN,GAAYX,OAAO,CAACgB,GAAD,CAAnB;AACP;AACJ;;AAjCwD;AAmC7DtB,iBAAiB,CAACyB,QAAlB,GAA6B,mBAA7B","sourcesContent":["import { ContinuousColorMapper } from \"./continuous_color_mapper\";\nimport { min, max } from \"../../core/util/arrayable\";\nexport class LinearColorMapper extends ContinuousColorMapper {\n    constructor(attrs) {\n        super(attrs);\n    }\n    _v_compute(data, values, palette, colors) {\n        const { nan_color, low_color, high_color } = colors;\n        const low = this.low != null ? this.low : min(data);\n        const high = this.high != null ? this.high : max(data);\n        const max_key = palette.length - 1;\n        const norm_factor = 1 / (high - low);\n        const normed_interval = 1 / palette.length;\n        for (let i = 0, end = data.length; i < end; i++) {\n            const d = data[i];\n            if (isNaN(d)) {\n                values[i] = nan_color;\n                continue;\n            }\n            // This handles the edge case where d == high, since the code below maps\n            // values exactly equal to high to palette.length, which is greater than\n            // max_key\n            if (d == high) {\n                values[i] = palette[max_key];\n                continue;\n            }\n            const normed_d = (d - low) * norm_factor;\n            const key = Math.floor(normed_d / normed_interval);\n            if (key < 0)\n                values[i] = low_color != null ? low_color : palette[0];\n            else if (key > max_key)\n                values[i] = high_color != null ? high_color : palette[max_key];\n            else\n                values[i] = palette[key];\n        }\n    }\n}\nLinearColorMapper.__name__ = \"LinearColorMapper\";\n//# sourceMappingURL=linear_color_mapper.js.map"]},"metadata":{},"sourceType":"module"}