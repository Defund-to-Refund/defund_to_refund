{"ast":null,"code":"import { ColumnarDataSource } from \"./columnar_data_source\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\n\nfunction orNaN(v) {\n  return v != null ? v : NaN;\n}\n\nexport class GeoJSONDataSource extends ColumnarDataSource {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_GeoJSONDataSource() {\n    this.define({\n      geojson: [p.Any]\n    });\n    this.internal({\n      data: [p.Any, {}]\n    });\n  }\n\n  initialize() {\n    super.initialize();\n\n    this._update_data();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.properties.geojson.change, () => this._update_data());\n  }\n\n  _update_data() {\n    this.data = this.geojson_to_column_data();\n  }\n\n  _get_new_list_array(length) {\n    return range(0, length).map(_i => []);\n  }\n\n  _get_new_nan_array(length) {\n    return range(0, length).map(_i => NaN);\n  }\n\n  _add_properties(item, data, i, item_count) {\n    const properties = item.properties || {};\n\n    for (const property in properties) {\n      if (!data.hasOwnProperty(property)) data[property] = this._get_new_nan_array(item_count); // orNaN necessary here to prevent null values from ending up in the column\n\n      data[property][i] = orNaN(properties[property]);\n    }\n  }\n\n  _add_geometry(geometry, data, i) {\n    function flatten(acc, item) {\n      return acc.concat([[NaN, NaN, NaN]]).concat(item);\n    }\n\n    switch (geometry.type) {\n      case \"Point\":\n        {\n          const [x, y, z] = geometry.coordinates;\n          data.x[i] = x;\n          data.y[i] = y;\n          data.z[i] = orNaN(z);\n          break;\n        }\n\n      case \"LineString\":\n        {\n          const {\n            coordinates\n          } = geometry;\n\n          for (let j = 0; j < coordinates.length; j++) {\n            const [x, y, z] = coordinates[j];\n            data.xs[i][j] = x;\n            data.ys[i][j] = y;\n            data.zs[i][j] = orNaN(z);\n          }\n\n          break;\n        }\n\n      case \"Polygon\":\n        {\n          if (geometry.coordinates.length > 1) logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n          const exterior_ring = geometry.coordinates[0];\n\n          for (let j = 0; j < exterior_ring.length; j++) {\n            const [x, y, z] = exterior_ring[j];\n            data.xs[i][j] = x;\n            data.ys[i][j] = y;\n            data.zs[i][j] = orNaN(z);\n          }\n\n          break;\n        }\n\n      case \"MultiPoint\":\n        {\n          logger.warn('MultiPoint not supported in Bokeh');\n          break;\n        }\n\n      case \"MultiLineString\":\n        {\n          const coordinates = geometry.coordinates.reduce(flatten);\n\n          for (let j = 0; j < coordinates.length; j++) {\n            const [x, y, z] = coordinates[j];\n            data.xs[i][j] = x;\n            data.ys[i][j] = y;\n            data.zs[i][j] = orNaN(z);\n          }\n\n          break;\n        }\n\n      case \"MultiPolygon\":\n        {\n          const exterior_rings = [];\n\n          for (const polygon of geometry.coordinates) {\n            if (polygon.length > 1) logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n            exterior_rings.push(polygon[0]);\n          }\n\n          const coordinates = exterior_rings.reduce(flatten);\n\n          for (let j = 0; j < coordinates.length; j++) {\n            const [x, y, z] = coordinates[j];\n            data.xs[i][j] = x;\n            data.ys[i][j] = y;\n            data.zs[i][j] = orNaN(z);\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error(`Invalid GeoJSON geometry type: ${geometry.type}`);\n    }\n  }\n\n  geojson_to_column_data() {\n    const geojson = JSON.parse(this.geojson);\n    let items;\n\n    switch (geojson.type) {\n      case \"GeometryCollection\":\n        {\n          if (geojson.geometries == null) throw new Error('No geometries found in GeometryCollection');\n          if (geojson.geometries.length === 0) throw new Error('geojson.geometries must have one or more items');\n          items = geojson.geometries;\n          break;\n        }\n\n      case \"FeatureCollection\":\n        {\n          if (geojson.features == null) throw new Error('No features found in FeaturesCollection');\n          if (geojson.features.length == 0) throw new Error('geojson.features must have one or more items');\n          items = geojson.features;\n          break;\n        }\n\n      default:\n        throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\n    }\n\n    let item_count = 0;\n\n    for (const item of items) {\n      const geometry = item.type === 'Feature' ? item.geometry : item;\n      if (geometry.type == 'GeometryCollection') item_count += geometry.geometries.length;else item_count += 1;\n    }\n\n    const data = {\n      x: this._get_new_nan_array(item_count),\n      y: this._get_new_nan_array(item_count),\n      z: this._get_new_nan_array(item_count),\n      xs: this._get_new_list_array(item_count),\n      ys: this._get_new_list_array(item_count),\n      zs: this._get_new_list_array(item_count)\n    };\n    let arr_index = 0;\n\n    for (const item of items) {\n      const geometry = item.type == 'Feature' ? item.geometry : item;\n\n      if (geometry.type == \"GeometryCollection\") {\n        for (const g of geometry.geometries) {\n          this._add_geometry(g, data, arr_index);\n\n          if (item.type === 'Feature') this._add_properties(item, data, arr_index, item_count);\n          arr_index += 1;\n        }\n      } else {\n        this._add_geometry(geometry, data, arr_index);\n\n        if (item.type === 'Feature') this._add_properties(item, data, arr_index, item_count);\n        arr_index += 1;\n      }\n    }\n\n    return data;\n  }\n\n}\nGeoJSONDataSource.__name__ = \"GeoJSONDataSource\";\nGeoJSONDataSource.init_GeoJSONDataSource();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/sources/geojson_data_source.js"],"names":["ColumnarDataSource","logger","p","range","orNaN","v","NaN","GeoJSONDataSource","constructor","attrs","init_GeoJSONDataSource","define","geojson","Any","internal","data","initialize","_update_data","connect_signals","connect","properties","change","geojson_to_column_data","_get_new_list_array","length","map","_i","_get_new_nan_array","_add_properties","item","i","item_count","property","hasOwnProperty","_add_geometry","geometry","flatten","acc","concat","type","x","y","z","coordinates","j","xs","ys","zs","warn","exterior_ring","reduce","exterior_rings","polygon","push","Error","JSON","parse","items","geometries","features","arr_index","g","__name__"],"mappings":"AAAA,SAASA,kBAAT,QAAmC,wBAAnC;AACA,SAASC,MAAT,QAAuB,oBAAvB;AACA,OAAO,KAAKC,CAAZ,MAAmB,uBAAnB;AACA,SAASC,KAAT,QAAsB,uBAAtB;;AACA,SAASC,KAAT,CAAeC,CAAf,EAAkB;AACd,SAAOA,CAAC,IAAI,IAAL,GAAYA,CAAZ,GAAgBC,GAAvB;AACH;;AACD,OAAO,MAAMC,iBAAN,SAAgCP,kBAAhC,CAAmD;AACtDQ,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,sBAAP,GAAgC;AAC5B,SAAKC,MAAL,CAAY;AACRC,MAAAA,OAAO,EAAE,CAACV,CAAC,CAACW,GAAH;AADD,KAAZ;AAGA,SAAKC,QAAL,CAAc;AACVC,MAAAA,IAAI,EAAE,CAACb,CAAC,CAACW,GAAH,EAAQ,EAAR;AADI,KAAd;AAGH;;AACDG,EAAAA,UAAU,GAAG;AACT,UAAMA,UAAN;;AACA,SAAKC,YAAL;AACH;;AACDC,EAAAA,eAAe,GAAG;AACd,UAAMA,eAAN;AACA,SAAKC,OAAL,CAAa,KAAKC,UAAL,CAAgBR,OAAhB,CAAwBS,MAArC,EAA6C,MAAM,KAAKJ,YAAL,EAAnD;AACH;;AACDA,EAAAA,YAAY,GAAG;AACX,SAAKF,IAAL,GAAY,KAAKO,sBAAL,EAAZ;AACH;;AACDC,EAAAA,mBAAmB,CAACC,MAAD,EAAS;AACxB,WAAOrB,KAAK,CAAC,CAAD,EAAIqB,MAAJ,CAAL,CAAiBC,GAAjB,CAAsBC,EAAD,IAAQ,EAA7B,CAAP;AACH;;AACDC,EAAAA,kBAAkB,CAACH,MAAD,EAAS;AACvB,WAAOrB,KAAK,CAAC,CAAD,EAAIqB,MAAJ,CAAL,CAAiBC,GAAjB,CAAsBC,EAAD,IAAQpB,GAA7B,CAAP;AACH;;AACDsB,EAAAA,eAAe,CAACC,IAAD,EAAOd,IAAP,EAAae,CAAb,EAAgBC,UAAhB,EAA4B;AACvC,UAAMX,UAAU,GAAGS,IAAI,CAACT,UAAL,IAAmB,EAAtC;;AACA,SAAK,MAAMY,QAAX,IAAuBZ,UAAvB,EAAmC;AAC/B,UAAI,CAACL,IAAI,CAACkB,cAAL,CAAoBD,QAApB,CAAL,EACIjB,IAAI,CAACiB,QAAD,CAAJ,GAAiB,KAAKL,kBAAL,CAAwBI,UAAxB,CAAjB,CAF2B,CAG/B;;AACAhB,MAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeF,CAAf,IAAoB1B,KAAK,CAACgB,UAAU,CAACY,QAAD,CAAX,CAAzB;AACH;AACJ;;AACDE,EAAAA,aAAa,CAACC,QAAD,EAAWpB,IAAX,EAAiBe,CAAjB,EAAoB;AAC7B,aAASM,OAAT,CAAiBC,GAAjB,EAAsBR,IAAtB,EAA4B;AACxB,aAAOQ,GAAG,CAACC,MAAJ,CAAW,CAAC,CAAChC,GAAD,EAAMA,GAAN,EAAWA,GAAX,CAAD,CAAX,EAA8BgC,MAA9B,CAAqCT,IAArC,CAAP;AACH;;AACD,YAAQM,QAAQ,CAACI,IAAjB;AACI,WAAK,OAAL;AAAc;AACV,gBAAM,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAYP,QAAQ,CAACQ,WAA3B;AACA5B,UAAAA,IAAI,CAACyB,CAAL,CAAOV,CAAP,IAAYU,CAAZ;AACAzB,UAAAA,IAAI,CAAC0B,CAAL,CAAOX,CAAP,IAAYW,CAAZ;AACA1B,UAAAA,IAAI,CAAC2B,CAAL,CAAOZ,CAAP,IAAY1B,KAAK,CAACsC,CAAD,CAAjB;AACA;AACH;;AACD,WAAK,YAAL;AAAmB;AACf,gBAAM;AAAEC,YAAAA;AAAF,cAAkBR,QAAxB;;AACA,eAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACnB,MAAhC,EAAwCoB,CAAC,EAAzC,EAA6C;AACzC,kBAAM,CAACJ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAYC,WAAW,CAACC,CAAD,CAA7B;AACA7B,YAAAA,IAAI,CAAC8B,EAAL,CAAQf,CAAR,EAAWc,CAAX,IAAgBJ,CAAhB;AACAzB,YAAAA,IAAI,CAAC+B,EAAL,CAAQhB,CAAR,EAAWc,CAAX,IAAgBH,CAAhB;AACA1B,YAAAA,IAAI,CAACgC,EAAL,CAAQjB,CAAR,EAAWc,CAAX,IAAgBxC,KAAK,CAACsC,CAAD,CAArB;AACH;;AACD;AACH;;AACD,WAAK,SAAL;AAAgB;AACZ,cAAIP,QAAQ,CAACQ,WAAT,CAAqBnB,MAArB,GAA8B,CAAlC,EACIvB,MAAM,CAAC+C,IAAP,CAAY,yEAAZ;AACJ,gBAAMC,aAAa,GAAGd,QAAQ,CAACQ,WAAT,CAAqB,CAArB,CAAtB;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,aAAa,CAACzB,MAAlC,EAA0CoB,CAAC,EAA3C,EAA+C;AAC3C,kBAAM,CAACJ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAYO,aAAa,CAACL,CAAD,CAA/B;AACA7B,YAAAA,IAAI,CAAC8B,EAAL,CAAQf,CAAR,EAAWc,CAAX,IAAgBJ,CAAhB;AACAzB,YAAAA,IAAI,CAAC+B,EAAL,CAAQhB,CAAR,EAAWc,CAAX,IAAgBH,CAAhB;AACA1B,YAAAA,IAAI,CAACgC,EAAL,CAAQjB,CAAR,EAAWc,CAAX,IAAgBxC,KAAK,CAACsC,CAAD,CAArB;AACH;;AACD;AACH;;AACD,WAAK,YAAL;AAAmB;AACfzC,UAAAA,MAAM,CAAC+C,IAAP,CAAY,mCAAZ;AACA;AACH;;AACD,WAAK,iBAAL;AAAwB;AACpB,gBAAML,WAAW,GAAGR,QAAQ,CAACQ,WAAT,CAAqBO,MAArB,CAA4Bd,OAA5B,CAApB;;AACA,eAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACnB,MAAhC,EAAwCoB,CAAC,EAAzC,EAA6C;AACzC,kBAAM,CAACJ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAYC,WAAW,CAACC,CAAD,CAA7B;AACA7B,YAAAA,IAAI,CAAC8B,EAAL,CAAQf,CAAR,EAAWc,CAAX,IAAgBJ,CAAhB;AACAzB,YAAAA,IAAI,CAAC+B,EAAL,CAAQhB,CAAR,EAAWc,CAAX,IAAgBH,CAAhB;AACA1B,YAAAA,IAAI,CAACgC,EAAL,CAAQjB,CAAR,EAAWc,CAAX,IAAgBxC,KAAK,CAACsC,CAAD,CAArB;AACH;;AACD;AACH;;AACD,WAAK,cAAL;AAAqB;AACjB,gBAAMS,cAAc,GAAG,EAAvB;;AACA,eAAK,MAAMC,OAAX,IAAsBjB,QAAQ,CAACQ,WAA/B,EAA4C;AACxC,gBAAIS,OAAO,CAAC5B,MAAR,GAAiB,CAArB,EACIvB,MAAM,CAAC+C,IAAP,CAAY,yEAAZ;AACJG,YAAAA,cAAc,CAACE,IAAf,CAAoBD,OAAO,CAAC,CAAD,CAA3B;AACH;;AACD,gBAAMT,WAAW,GAAGQ,cAAc,CAACD,MAAf,CAAsBd,OAAtB,CAApB;;AACA,eAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACnB,MAAhC,EAAwCoB,CAAC,EAAzC,EAA6C;AACzC,kBAAM,CAACJ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAYC,WAAW,CAACC,CAAD,CAA7B;AACA7B,YAAAA,IAAI,CAAC8B,EAAL,CAAQf,CAAR,EAAWc,CAAX,IAAgBJ,CAAhB;AACAzB,YAAAA,IAAI,CAAC+B,EAAL,CAAQhB,CAAR,EAAWc,CAAX,IAAgBH,CAAhB;AACA1B,YAAAA,IAAI,CAACgC,EAAL,CAAQjB,CAAR,EAAWc,CAAX,IAAgBxC,KAAK,CAACsC,CAAD,CAArB;AACH;;AACD;AACH;;AACD;AACI,cAAM,IAAIY,KAAJ,CAAW,kCAAiCnB,QAAQ,CAACI,IAAK,EAA1D,CAAN;AA7DR;AA+DH;;AACDjB,EAAAA,sBAAsB,GAAG;AACrB,UAAMV,OAAO,GAAG2C,IAAI,CAACC,KAAL,CAAW,KAAK5C,OAAhB,CAAhB;AACA,QAAI6C,KAAJ;;AACA,YAAQ7C,OAAO,CAAC2B,IAAhB;AACI,WAAK,oBAAL;AAA2B;AACvB,cAAI3B,OAAO,CAAC8C,UAAR,IAAsB,IAA1B,EACI,MAAM,IAAIJ,KAAJ,CAAU,2CAAV,CAAN;AACJ,cAAI1C,OAAO,CAAC8C,UAAR,CAAmBlC,MAAnB,KAA8B,CAAlC,EACI,MAAM,IAAI8B,KAAJ,CAAU,gDAAV,CAAN;AACJG,UAAAA,KAAK,GAAG7C,OAAO,CAAC8C,UAAhB;AACA;AACH;;AACD,WAAK,mBAAL;AAA0B;AACtB,cAAI9C,OAAO,CAAC+C,QAAR,IAAoB,IAAxB,EACI,MAAM,IAAIL,KAAJ,CAAU,yCAAV,CAAN;AACJ,cAAI1C,OAAO,CAAC+C,QAAR,CAAiBnC,MAAjB,IAA2B,CAA/B,EACI,MAAM,IAAI8B,KAAJ,CAAU,8CAAV,CAAN;AACJG,UAAAA,KAAK,GAAG7C,OAAO,CAAC+C,QAAhB;AACA;AACH;;AACD;AACI,cAAM,IAAIL,KAAJ,CAAU,gFAAV,CAAN;AAlBR;;AAoBA,QAAIvB,UAAU,GAAG,CAAjB;;AACA,SAAK,MAAMF,IAAX,IAAmB4B,KAAnB,EAA0B;AACtB,YAAMtB,QAAQ,GAAGN,IAAI,CAACU,IAAL,KAAc,SAAd,GAA0BV,IAAI,CAACM,QAA/B,GAA0CN,IAA3D;AACA,UAAIM,QAAQ,CAACI,IAAT,IAAiB,oBAArB,EACIR,UAAU,IAAII,QAAQ,CAACuB,UAAT,CAAoBlC,MAAlC,CADJ,KAGIO,UAAU,IAAI,CAAd;AACP;;AACD,UAAMhB,IAAI,GAAG;AACTyB,MAAAA,CAAC,EAAE,KAAKb,kBAAL,CAAwBI,UAAxB,CADM;AAETU,MAAAA,CAAC,EAAE,KAAKd,kBAAL,CAAwBI,UAAxB,CAFM;AAGTW,MAAAA,CAAC,EAAE,KAAKf,kBAAL,CAAwBI,UAAxB,CAHM;AAITc,MAAAA,EAAE,EAAE,KAAKtB,mBAAL,CAAyBQ,UAAzB,CAJK;AAKTe,MAAAA,EAAE,EAAE,KAAKvB,mBAAL,CAAyBQ,UAAzB,CALK;AAMTgB,MAAAA,EAAE,EAAE,KAAKxB,mBAAL,CAAyBQ,UAAzB;AANK,KAAb;AAQA,QAAI6B,SAAS,GAAG,CAAhB;;AACA,SAAK,MAAM/B,IAAX,IAAmB4B,KAAnB,EAA0B;AACtB,YAAMtB,QAAQ,GAAGN,IAAI,CAACU,IAAL,IAAa,SAAb,GAAyBV,IAAI,CAACM,QAA9B,GAAyCN,IAA1D;;AACA,UAAIM,QAAQ,CAACI,IAAT,IAAiB,oBAArB,EAA2C;AACvC,aAAK,MAAMsB,CAAX,IAAgB1B,QAAQ,CAACuB,UAAzB,EAAqC;AACjC,eAAKxB,aAAL,CAAmB2B,CAAnB,EAAsB9C,IAAtB,EAA4B6C,SAA5B;;AACA,cAAI/B,IAAI,CAACU,IAAL,KAAc,SAAlB,EACI,KAAKX,eAAL,CAAqBC,IAArB,EAA2Bd,IAA3B,EAAiC6C,SAAjC,EAA4C7B,UAA5C;AACJ6B,UAAAA,SAAS,IAAI,CAAb;AACH;AACJ,OAPD,MAQK;AACD,aAAK1B,aAAL,CAAmBC,QAAnB,EAA6BpB,IAA7B,EAAmC6C,SAAnC;;AACA,YAAI/B,IAAI,CAACU,IAAL,KAAc,SAAlB,EACI,KAAKX,eAAL,CAAqBC,IAArB,EAA2Bd,IAA3B,EAAiC6C,SAAjC,EAA4C7B,UAA5C;AACJ6B,QAAAA,SAAS,IAAI,CAAb;AACH;AACJ;;AACD,WAAO7C,IAAP;AACH;;AApKqD;AAsK1DR,iBAAiB,CAACuD,QAAlB,GAA6B,mBAA7B;AACAvD,iBAAiB,CAACG,sBAAlB","sourcesContent":["import { ColumnarDataSource } from \"./columnar_data_source\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nfunction orNaN(v) {\n    return v != null ? v : NaN;\n}\nexport class GeoJSONDataSource extends ColumnarDataSource {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_GeoJSONDataSource() {\n        this.define({\n            geojson: [p.Any],\n        });\n        this.internal({\n            data: [p.Any, {}],\n        });\n    }\n    initialize() {\n        super.initialize();\n        this._update_data();\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.properties.geojson.change, () => this._update_data());\n    }\n    _update_data() {\n        this.data = this.geojson_to_column_data();\n    }\n    _get_new_list_array(length) {\n        return range(0, length).map((_i) => []);\n    }\n    _get_new_nan_array(length) {\n        return range(0, length).map((_i) => NaN);\n    }\n    _add_properties(item, data, i, item_count) {\n        const properties = item.properties || {};\n        for (const property in properties) {\n            if (!data.hasOwnProperty(property))\n                data[property] = this._get_new_nan_array(item_count);\n            // orNaN necessary here to prevent null values from ending up in the column\n            data[property][i] = orNaN(properties[property]);\n        }\n    }\n    _add_geometry(geometry, data, i) {\n        function flatten(acc, item) {\n            return acc.concat([[NaN, NaN, NaN]]).concat(item);\n        }\n        switch (geometry.type) {\n            case \"Point\": {\n                const [x, y, z] = geometry.coordinates;\n                data.x[i] = x;\n                data.y[i] = y;\n                data.z[i] = orNaN(z);\n                break;\n            }\n            case \"LineString\": {\n                const { coordinates } = geometry;\n                for (let j = 0; j < coordinates.length; j++) {\n                    const [x, y, z] = coordinates[j];\n                    data.xs[i][j] = x;\n                    data.ys[i][j] = y;\n                    data.zs[i][j] = orNaN(z);\n                }\n                break;\n            }\n            case \"Polygon\": {\n                if (geometry.coordinates.length > 1)\n                    logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                const exterior_ring = geometry.coordinates[0];\n                for (let j = 0; j < exterior_ring.length; j++) {\n                    const [x, y, z] = exterior_ring[j];\n                    data.xs[i][j] = x;\n                    data.ys[i][j] = y;\n                    data.zs[i][j] = orNaN(z);\n                }\n                break;\n            }\n            case \"MultiPoint\": {\n                logger.warn('MultiPoint not supported in Bokeh');\n                break;\n            }\n            case \"MultiLineString\": {\n                const coordinates = geometry.coordinates.reduce(flatten);\n                for (let j = 0; j < coordinates.length; j++) {\n                    const [x, y, z] = coordinates[j];\n                    data.xs[i][j] = x;\n                    data.ys[i][j] = y;\n                    data.zs[i][j] = orNaN(z);\n                }\n                break;\n            }\n            case \"MultiPolygon\": {\n                const exterior_rings = [];\n                for (const polygon of geometry.coordinates) {\n                    if (polygon.length > 1)\n                        logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                    exterior_rings.push(polygon[0]);\n                }\n                const coordinates = exterior_rings.reduce(flatten);\n                for (let j = 0; j < coordinates.length; j++) {\n                    const [x, y, z] = coordinates[j];\n                    data.xs[i][j] = x;\n                    data.ys[i][j] = y;\n                    data.zs[i][j] = orNaN(z);\n                }\n                break;\n            }\n            default:\n                throw new Error(`Invalid GeoJSON geometry type: ${geometry.type}`);\n        }\n    }\n    geojson_to_column_data() {\n        const geojson = JSON.parse(this.geojson);\n        let items;\n        switch (geojson.type) {\n            case \"GeometryCollection\": {\n                if (geojson.geometries == null)\n                    throw new Error('No geometries found in GeometryCollection');\n                if (geojson.geometries.length === 0)\n                    throw new Error('geojson.geometries must have one or more items');\n                items = geojson.geometries;\n                break;\n            }\n            case \"FeatureCollection\": {\n                if (geojson.features == null)\n                    throw new Error('No features found in FeaturesCollection');\n                if (geojson.features.length == 0)\n                    throw new Error('geojson.features must have one or more items');\n                items = geojson.features;\n                break;\n            }\n            default:\n                throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\n        }\n        let item_count = 0;\n        for (const item of items) {\n            const geometry = item.type === 'Feature' ? item.geometry : item;\n            if (geometry.type == 'GeometryCollection')\n                item_count += geometry.geometries.length;\n            else\n                item_count += 1;\n        }\n        const data = {\n            x: this._get_new_nan_array(item_count),\n            y: this._get_new_nan_array(item_count),\n            z: this._get_new_nan_array(item_count),\n            xs: this._get_new_list_array(item_count),\n            ys: this._get_new_list_array(item_count),\n            zs: this._get_new_list_array(item_count),\n        };\n        let arr_index = 0;\n        for (const item of items) {\n            const geometry = item.type == 'Feature' ? item.geometry : item;\n            if (geometry.type == \"GeometryCollection\") {\n                for (const g of geometry.geometries) {\n                    this._add_geometry(g, data, arr_index);\n                    if (item.type === 'Feature')\n                        this._add_properties(item, data, arr_index, item_count);\n                    arr_index += 1;\n                }\n            }\n            else {\n                this._add_geometry(geometry, data, arr_index);\n                if (item.type === 'Feature')\n                    this._add_properties(item, data, arr_index, item_count);\n                arr_index += 1;\n            }\n        }\n        return data;\n    }\n}\nGeoJSONDataSource.__name__ = \"GeoJSONDataSource\";\nGeoJSONDataSource.init_GeoJSONDataSource();\n//# sourceMappingURL=geojson_data_source.js.map"]},"metadata":{},"sourceType":"module"}