{"ast":null,"code":"\"use strict\";\n\nvar $ = require(\"./slick.jquery\");\n\nvar Slick = require(\"./slick.core\");\n/***\n * A sample Model implementation.\n * Provides a filtered view of the underlying data.\n *\n * Relies on the data item having an \"id\" property uniquely identifying it.\n */\n\n\nfunction DataView(options) {\n  var self = this;\n  var defaults = {\n    groupItemMetadataProvider: null,\n    inlineFilters: false\n  }; // private\n\n  var idProperty = \"id\"; // property holding a unique row id\n\n  var items = []; // data by index\n\n  var rows = []; // data by row\n\n  var idxById = {}; // indexes by id\n\n  var rowsById = null; // rows by id; lazy-calculated\n\n  var filter = null; // filter function\n\n  var updated = null; // updated item ids\n\n  var suspend = false; // suspends the recalculation\n\n  var sortAsc = true;\n  var fastSortField;\n  var sortComparer;\n  var refreshHints = {};\n  var prevRefreshHints = {};\n  var filterArgs;\n  var filteredItems = [];\n  var compiledFilter;\n  var compiledFilterWithCaching;\n  var filterCache = []; // grouping\n\n  var groupingInfoDefaults = {\n    getter: null,\n    formatter: null,\n    comparer: function (a, b) {\n      return a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n    },\n    predefinedValues: [],\n    aggregators: [],\n    aggregateEmpty: false,\n    aggregateCollapsed: false,\n    aggregateChildGroups: false,\n    collapsed: false,\n    displayTotalsRow: true,\n    lazyTotalsCalculation: false\n  };\n  var groupingInfos = [];\n  var groups = [];\n  var toggledGroupsByLevel = [];\n  var groupingDelimiter = ':|:';\n  var pagesize = 0;\n  var pagenum = 0;\n  var totalRows = 0; // events\n\n  var onRowCountChanged = new Slick.Event();\n  var onRowsChanged = new Slick.Event();\n  var onPagingInfoChanged = new Slick.Event();\n  options = $.extend(true, {}, defaults, options);\n\n  function beginUpdate() {\n    suspend = true;\n  }\n\n  function endUpdate() {\n    suspend = false;\n    refresh();\n  }\n\n  function setRefreshHints(hints) {\n    refreshHints = hints;\n  }\n\n  function setFilterArgs(args) {\n    filterArgs = args;\n  }\n\n  function updateIdxById(startingIndex) {\n    startingIndex = startingIndex || 0;\n    var id;\n\n    for (var i = startingIndex, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n\n      if (id === undefined) {\n        throw new Error(\"Each data element must implement a unique 'id' property\");\n      }\n\n      idxById[id] = i;\n    }\n  }\n\n  function ensureIdUniqueness() {\n    var id;\n\n    for (var i = 0, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n\n      if (id === undefined || idxById[id] !== i) {\n        throw new Error(\"Each data element must implement a unique 'id' property\");\n      }\n    }\n  }\n\n  function getItems() {\n    return items;\n  }\n\n  function setItems(data, objectIdProperty) {\n    if (objectIdProperty !== undefined) {\n      idProperty = objectIdProperty;\n    }\n\n    items = filteredItems = data;\n    idxById = {};\n    updateIdxById();\n    ensureIdUniqueness();\n    refresh();\n  }\n\n  function setPagingOptions(args) {\n    if (args.pageSize != undefined) {\n      pagesize = args.pageSize;\n      pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n    }\n\n    if (args.pageNum != undefined) {\n      pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n    }\n\n    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n    refresh();\n  }\n\n  function getPagingInfo() {\n    var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n    return {\n      pageSize: pagesize,\n      pageNum: pagenum,\n      totalRows: totalRows,\n      totalPages: totalPages,\n      dataView: self\n    };\n  }\n\n  function sort(comparer, ascending) {\n    sortAsc = ascending;\n    sortComparer = comparer;\n    fastSortField = null;\n\n    if (ascending === false) {\n      items.reverse();\n    }\n\n    items.sort(comparer);\n\n    if (ascending === false) {\n      items.reverse();\n    }\n\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n  /***\n   * Provides a workaround for the extremely slow sorting in IE.\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n   * to return the value of that field and then doing a native Array.sort().\n   */\n\n\n  function fastSort(field, ascending) {\n    sortAsc = ascending;\n    fastSortField = field;\n    sortComparer = null;\n    var oldToString = Object.prototype.toString;\n    Object.prototype.toString = typeof field == \"function\" ? field : function () {\n      return this[field];\n    }; // an extra reversal for descending sort keeps the sort stable\n    // (assuming a stable native sort implementation, which isn't true in some cases)\n\n    if (ascending === false) {\n      items.reverse();\n    }\n\n    items.sort();\n    Object.prototype.toString = oldToString;\n\n    if (ascending === false) {\n      items.reverse();\n    }\n\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  function reSort() {\n    if (sortComparer) {\n      sort(sortComparer, sortAsc);\n    } else if (fastSortField) {\n      fastSort(fastSortField, sortAsc);\n    }\n  }\n\n  function getFilteredItems() {\n    return filteredItems;\n  }\n\n  function getFilter() {\n    return filter;\n  }\n\n  function setFilter(filterFn) {\n    filter = filterFn;\n\n    if (options.inlineFilters) {\n      compiledFilter = compileFilter();\n      compiledFilterWithCaching = compileFilterWithCaching();\n    }\n\n    refresh();\n  }\n\n  function getGrouping() {\n    return groupingInfos;\n  }\n\n  function setGrouping(groupingInfo) {\n    if (!options.groupItemMetadataProvider) {\n      options.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider();\n    }\n\n    groups = [];\n    toggledGroupsByLevel = [];\n    groupingInfo = groupingInfo || [];\n    groupingInfos = groupingInfo instanceof Array ? groupingInfo : [groupingInfo];\n\n    for (var i = 0; i < groupingInfos.length; i++) {\n      var gi = groupingInfos[i] = $.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n      gi.getterIsAFn = typeof gi.getter === \"function\"; // pre-compile accumulator loops\n\n      gi.compiledAccumulators = [];\n      var idx = gi.aggregators.length;\n\n      while (idx--) {\n        gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n      }\n\n      toggledGroupsByLevel[i] = {};\n    }\n\n    refresh();\n  }\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n\n\n  function groupBy(valueGetter, valueFormatter, sortComparer) {\n    if (valueGetter == null) {\n      setGrouping([]);\n      return;\n    }\n\n    setGrouping({\n      getter: valueGetter,\n      formatter: valueFormatter,\n      comparer: sortComparer\n    });\n  }\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n\n\n  function setAggregators(groupAggregators, includeCollapsed) {\n    if (!groupingInfos.length) {\n      throw new Error(\"At least one grouping must be specified before calling setAggregators().\");\n    }\n\n    groupingInfos[0].aggregators = groupAggregators;\n    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n    setGrouping(groupingInfos);\n  }\n\n  function getItemByIdx(i) {\n    return items[i];\n  }\n\n  function getIdxById(id) {\n    return idxById[id];\n  }\n\n  function ensureRowsByIdCache() {\n    if (!rowsById) {\n      rowsById = {};\n\n      for (var i = 0, l = rows.length; i < l; i++) {\n        rowsById[rows[i][idProperty]] = i;\n      }\n    }\n  }\n\n  function getRowByItem(item) {\n    ensureRowsByIdCache();\n    return rowsById[item[idProperty]];\n  }\n\n  function getRowById(id) {\n    ensureRowsByIdCache();\n    return rowsById[id];\n  }\n\n  function getItemById(id) {\n    return items[idxById[id]];\n  }\n\n  function mapItemsToRows(itemArray) {\n    var rows = [];\n    ensureRowsByIdCache();\n\n    for (var i = 0, l = itemArray.length; i < l; i++) {\n      var row = rowsById[itemArray[i][idProperty]];\n\n      if (row != null) {\n        rows[rows.length] = row;\n      }\n    }\n\n    return rows;\n  }\n\n  function mapIdsToRows(idArray) {\n    var rows = [];\n    ensureRowsByIdCache();\n\n    for (var i = 0, l = idArray.length; i < l; i++) {\n      var row = rowsById[idArray[i]];\n\n      if (row != null) {\n        rows[rows.length] = row;\n      }\n    }\n\n    return rows;\n  }\n\n  function mapRowsToIds(rowArray) {\n    var ids = [];\n\n    for (var i = 0, l = rowArray.length; i < l; i++) {\n      if (rowArray[i] < rows.length) {\n        ids[ids.length] = rows[rowArray[i]][idProperty];\n      }\n    }\n\n    return ids;\n  }\n\n  function updateItem(id, item) {\n    if (idxById[id] === undefined || id !== item[idProperty]) {\n      throw new Error(\"Invalid or non-matching id\");\n    }\n\n    items[idxById[id]] = item;\n\n    if (!updated) {\n      updated = {};\n    }\n\n    updated[id] = true;\n    refresh();\n  }\n\n  function insertItem(insertBefore, item) {\n    items.splice(insertBefore, 0, item);\n    updateIdxById(insertBefore);\n    refresh();\n  }\n\n  function addItem(item) {\n    items.push(item);\n    updateIdxById(items.length - 1);\n    refresh();\n  }\n\n  function deleteItem(id) {\n    var idx = idxById[id];\n\n    if (idx === undefined) {\n      throw new Error(\"Invalid id\");\n    }\n\n    delete idxById[id];\n    items.splice(idx, 1);\n    updateIdxById(idx);\n    refresh();\n  }\n\n  function sortedAddItem(item) {\n    if (!sortComparer) {\n      throw new Error(\"sortedAddItem() requires a sort comparer, use sort()\");\n    }\n\n    insertItem(sortedIndex(item), item);\n  }\n\n  function sortedUpdateItem(id, item) {\n    if (idxById[id] === undefined || id !== item[idProperty]) {\n      throw new Error(\"Invalid or non-matching id \" + idxById[id]);\n    }\n\n    if (!sortComparer) {\n      throw new Error(\"sortedUpdateItem() requires a sort comparer, use sort()\");\n    }\n\n    var oldItem = getItemById(id);\n\n    if (sortComparer(oldItem, item) !== 0) {\n      // item affects sorting -> must use sorted add\n      deleteItem(id);\n      sortedAddItem(item);\n    } else {\n      // update does not affect sorting -> regular update works fine\n      updateItem(id, item);\n    }\n  }\n\n  function sortedIndex(searchItem) {\n    var low = 0,\n        high = items.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1;\n\n      if (sortComparer(items[mid], searchItem) === -1) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n\n    return low;\n  }\n\n  function getLength() {\n    return rows.length;\n  }\n\n  function getItem(i) {\n    var item = rows[i]; // if this is a group row, make sure totals are calculated and update the title\n\n    if (item && item.__group && item.totals && !item.totals.initialized) {\n      var gi = groupingInfos[item.level];\n\n      if (!gi.displayTotalsRow) {\n        calculateTotals(item.totals);\n        item.title = gi.formatter ? gi.formatter(item) : item.value;\n      }\n    } // if this is a totals row, make sure it's calculated\n    else if (item && item.__groupTotals && !item.initialized) {\n        calculateTotals(item);\n      }\n\n    return item;\n  }\n\n  function getItemMetadata(i) {\n    var item = rows[i];\n\n    if (item === undefined) {\n      return null;\n    } // overrides for grouping rows\n\n\n    if (item.__group) {\n      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n    } // overrides for totals rows\n\n\n    if (item.__groupTotals) {\n      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n    }\n\n    return null;\n  }\n\n  function expandCollapseAllGroups(level, collapse) {\n    if (level == null) {\n      for (var i = 0; i < groupingInfos.length; i++) {\n        toggledGroupsByLevel[i] = {};\n        groupingInfos[i].collapsed = collapse;\n      }\n    } else {\n      toggledGroupsByLevel[level] = {};\n      groupingInfos[level].collapsed = collapse;\n    }\n\n    refresh();\n  }\n  /**\n   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n   */\n\n\n  function collapseAllGroups(level) {\n    expandCollapseAllGroups(level, true);\n  }\n  /**\n   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n   */\n\n\n  function expandAllGroups(level) {\n    expandCollapseAllGroups(level, false);\n  }\n\n  function expandCollapseGroup(level, groupingKey, collapse) {\n    toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n    refresh();\n  }\n  /**\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     variable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n   *     the 'high' group.\n   */\n\n\n  function collapseGroup(varArgs) {\n    var args = Array.prototype.slice.call(arguments);\n    var arg0 = args[0];\n\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n    }\n  }\n  /**\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     variable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n   *     the 'high' group.\n   */\n\n\n  function expandGroup(varArgs) {\n    var args = Array.prototype.slice.call(arguments);\n    var arg0 = args[0];\n\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n    }\n  }\n\n  function getGroups() {\n    return groups;\n  }\n\n  function extractGroups(rows, parentGroup) {\n    var group;\n    var val;\n    var groups = [];\n    var groupsByVal = {};\n    var r;\n    var level = parentGroup ? parentGroup.level + 1 : 0;\n    var gi = groupingInfos[level];\n\n    for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n      val = gi.predefinedValues[i];\n      group = groupsByVal[val];\n\n      if (!group) {\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n    }\n\n    for (var i = 0, l = rows.length; i < l; i++) {\n      r = rows[i];\n      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n      group = groupsByVal[val];\n\n      if (!group) {\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n\n      group.rows[group.count++] = r;\n    }\n\n    if (level < groupingInfos.length - 1) {\n      for (var i = 0; i < groups.length; i++) {\n        group = groups[i];\n        group.groups = extractGroups(group.rows, group);\n      }\n    }\n\n    groups.sort(groupingInfos[level].comparer);\n    return groups;\n  }\n\n  function calculateTotals(totals) {\n    var group = totals.group;\n    var gi = groupingInfos[group.level];\n    var isLeafLevel = group.level == groupingInfos.length;\n    var agg,\n        idx = gi.aggregators.length;\n\n    if (!isLeafLevel && gi.aggregateChildGroups) {\n      // make sure all the subgroups are calculated\n      var i = group.groups.length;\n\n      while (i--) {\n        if (!group.groups[i].totals.initialized) {\n          calculateTotals(group.groups[i].totals);\n        }\n      }\n    }\n\n    while (idx--) {\n      agg = gi.aggregators[idx];\n      agg.init();\n\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        gi.compiledAccumulators[idx].call(agg, group.groups);\n      } else {\n        gi.compiledAccumulators[idx].call(agg, group.rows);\n      }\n\n      agg.storeResult(totals);\n    }\n\n    totals.initialized = true;\n  }\n\n  function addGroupTotals(group) {\n    var gi = groupingInfos[group.level];\n    var totals = new Slick.GroupTotals();\n    totals.group = group;\n    group.totals = totals;\n\n    if (!gi.lazyTotalsCalculation) {\n      calculateTotals(totals);\n    }\n  }\n\n  function addTotals(groups, level) {\n    level = level || 0;\n    var gi = groupingInfos[level];\n    var groupCollapsed = gi.collapsed;\n    var toggledGroups = toggledGroupsByLevel[level];\n    var idx = groups.length,\n        g;\n\n    while (idx--) {\n      g = groups[idx];\n\n      if (g.collapsed && !gi.aggregateCollapsed) {\n        continue;\n      } // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n\n\n      if (g.groups) {\n        addTotals(g.groups, level + 1);\n      }\n\n      if (gi.aggregators.length && (gi.aggregateEmpty || g.rows.length || g.groups && g.groups.length)) {\n        addGroupTotals(g);\n      }\n\n      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\n    }\n  }\n\n  function flattenGroupedRows(groups, level) {\n    level = level || 0;\n    var gi = groupingInfos[level];\n    var groupedRows = [],\n        rows,\n        gl = 0,\n        g;\n\n    for (var i = 0, l = groups.length; i < l; i++) {\n      g = groups[i];\n      groupedRows[gl++] = g;\n\n      if (!g.collapsed) {\n        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n\n        for (var j = 0, jj = rows.length; j < jj; j++) {\n          groupedRows[gl++] = rows[j];\n        }\n      }\n\n      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n        groupedRows[gl++] = g.totals;\n      }\n    }\n\n    return groupedRows;\n  }\n\n  function getFunctionInfo(fn) {\n    var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n    var matches = fn.toString().match(fnRegex);\n    return {\n      params: matches[1].split(\",\"),\n      body: matches[2]\n    };\n  }\n\n  function compileAccumulatorLoop(aggregator) {\n    var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n    var fn = new Function(\"_items\", \"for (var \" + accumulatorInfo.params[0] + \", _i=0, _il=_items.length; _i<_il; _i++) {\" + accumulatorInfo.params[0] + \" = _items[_i]; \" + accumulatorInfo.body + \"}\");\n    fn.displayName = fn.name = \"compiledAccumulatorLoop\";\n    return fn;\n  }\n\n  function compileFilter() {\n    var filterInfo = getFunctionInfo(filter);\n    var filterPath1 = \"{ continue _coreloop; }$1\";\n    var filterPath2 = \"{ _retval[_idx++] = $item$; continue _coreloop; }$1\"; // make some allowances for minification - there's only so far we can go with RegEx\n\n    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, \"{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\"); // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n\n    var tpl = [//\"function(_items, _args) { \",\n    \"var _retval = [], _idx = 0; \", \"var $item$, $args$ = _args; \", \"_coreloop: \", \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \", \"$item$ = _items[_i]; \", \"$filter$; \", \"} \", \"return _retval; \" //\"}\"\n    ].join(\"\");\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n    var fn = new Function(\"_items,_args\", tpl);\n    fn.displayName = fn.name = \"compiledFilter\";\n    return fn;\n  }\n\n  function compileFilterWithCaching() {\n    var filterInfo = getFunctionInfo(filter);\n    var filterPath1 = \"{ continue _coreloop; }$1\";\n    var filterPath2 = \"{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1\"; // make some allowances for minification - there's only so far we can go with RegEx\n\n    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, \"{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\"); // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n\n    var tpl = [//\"function(_items, _args, _cache) { \",\n    \"var _retval = [], _idx = 0; \", \"var $item$, $args$ = _args; \", \"_coreloop: \", \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \", \"$item$ = _items[_i]; \", \"if (_cache[_i]) { \", \"_retval[_idx++] = $item$; \", \"continue _coreloop; \", \"} \", \"$filter$; \", \"} \", \"return _retval; \" //\"}\"\n    ].join(\"\");\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n    var fn = new Function(\"_items,_args,_cache\", tpl);\n    fn.displayName = fn.name = \"compiledFilterWithCaching\";\n    return fn;\n  }\n\n  function uncompiledFilter(items, args) {\n    var retval = [],\n        idx = 0;\n\n    for (var i = 0, ii = items.length; i < ii; i++) {\n      if (filter(items[i], args)) {\n        retval[idx++] = items[i];\n      }\n    }\n\n    return retval;\n  }\n\n  function uncompiledFilterWithCaching(items, args, cache) {\n    var retval = [],\n        idx = 0,\n        item;\n\n    for (var i = 0, ii = items.length; i < ii; i++) {\n      item = items[i];\n\n      if (cache[i]) {\n        retval[idx++] = item;\n      } else if (filter(item, args)) {\n        retval[idx++] = item;\n        cache[i] = true;\n      }\n    }\n\n    return retval;\n  }\n\n  function getFilteredAndPagedItems(items) {\n    if (filter) {\n      var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n      var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\n      if (refreshHints.isFilterNarrowing) {\n        filteredItems = batchFilter(filteredItems, filterArgs);\n      } else if (refreshHints.isFilterExpanding) {\n        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n      } else if (!refreshHints.isFilterUnchanged) {\n        filteredItems = batchFilter(items, filterArgs);\n      }\n    } else {\n      // special case:  if not filtering and not paging, the resulting\n      // rows collection needs to be a copy so that changes due to sort\n      // can be caught\n      filteredItems = pagesize ? items : items.concat();\n    } // get the current page\n\n\n    var paged;\n\n    if (pagesize) {\n      if (filteredItems.length <= pagenum * pagesize) {\n        if (filteredItems.length === 0) {\n          pagenum = 0;\n        } else {\n          pagenum = Math.floor((filteredItems.length - 1) / pagesize);\n        }\n      }\n\n      paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n    } else {\n      paged = filteredItems;\n    }\n\n    return {\n      totalRows: filteredItems.length,\n      rows: paged\n    };\n  }\n\n  function getRowDiffs(rows, newRows) {\n    var item,\n        r,\n        eitherIsNonData,\n        diff = [];\n    var from = 0,\n        to = newRows.length;\n\n    if (refreshHints && refreshHints.ignoreDiffsBefore) {\n      from = Math.max(0, Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n    }\n\n    if (refreshHints && refreshHints.ignoreDiffsAfter) {\n      to = Math.min(newRows.length, Math.max(0, refreshHints.ignoreDiffsAfter));\n    }\n\n    for (var i = from, rl = rows.length; i < to; i++) {\n      if (i >= rl) {\n        diff[diff.length] = i;\n      } else {\n        item = newRows[i];\n        r = rows[i];\n\n        if (groupingInfos.length && (eitherIsNonData = item.__nonDataRow || r.__nonDataRow) && item.__group !== r.__group || item.__group && !item.equals(r) || eitherIsNonData && ( // no good way to compare totals since they are arbitrary DTOs\n        // deep object comparison is pretty expensive\n        // always considering them 'dirty' seems easier for the time being\n        item.__groupTotals || r.__groupTotals) || item[idProperty] != r[idProperty] || updated && updated[item[idProperty]]) {\n          diff[diff.length] = i;\n        }\n      }\n    }\n\n    return diff;\n  }\n\n  function recalc(_items) {\n    rowsById = null;\n\n    if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing || refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n      filterCache = [];\n    }\n\n    var filteredItems = getFilteredAndPagedItems(_items);\n    totalRows = filteredItems.totalRows;\n    var newRows = filteredItems.rows;\n    groups = [];\n\n    if (groupingInfos.length) {\n      groups = extractGroups(newRows);\n\n      if (groups.length) {\n        addTotals(groups);\n        newRows = flattenGroupedRows(groups);\n      }\n    }\n\n    var diff = getRowDiffs(rows, newRows);\n    rows = newRows;\n    return diff;\n  }\n\n  function refresh() {\n    if (suspend) {\n      return;\n    }\n\n    var countBefore = rows.length;\n    var totalRowsBefore = totalRows;\n    var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n    // if the current page is no longer valid, go to last page and recalc\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n\n    if (pagesize && totalRows < pagenum * pagesize) {\n      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n      diff = recalc(items, filter);\n    }\n\n    updated = null;\n    prevRefreshHints = refreshHints;\n    refreshHints = {};\n\n    if (totalRowsBefore !== totalRows) {\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n    }\n\n    if (countBefore !== rows.length) {\n      onRowCountChanged.notify({\n        previous: countBefore,\n        current: rows.length,\n        dataView: self\n      }, null, self);\n    }\n\n    if (diff.length > 0) {\n      onRowsChanged.notify({\n        rows: diff,\n        dataView: self\n      }, null, self);\n    }\n  }\n  /***\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\n   * This is useful since, without it, the grid only knows about rows, so if the items\n   * move around, the same rows stay selected instead of the selection moving along\n   * with the items.\n   *\n   * NOTE:  This doesn't work with cell selection model.\n   *\n   * @param grid {Slick.Grid} The grid to sync selection with.\n   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n   *     view due to them getting filtered out.\n   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n   *     that are currently out of the view (see preserveHidden) as selected when selection\n   *     changes.\n   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n   *     changes.  This is useful since, in combination with the above two options, it allows\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\n   * @method syncGridSelection\n   */\n\n\n  function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n    var self = this;\n    var inHandler;\n    var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n    var onSelectedRowIdsChanged = new Slick.Event();\n\n    function setSelectedRowIds(rowIds) {\n      if (selectedRowIds.join(\",\") == rowIds.join(\",\")) {\n        return;\n      }\n\n      selectedRowIds = rowIds;\n      onSelectedRowIdsChanged.notify({\n        \"grid\": grid,\n        \"ids\": selectedRowIds,\n        \"dataView\": self\n      }, new Slick.EventData(), self);\n    }\n\n    function update() {\n      if (selectedRowIds.length > 0) {\n        inHandler = true;\n        var selectedRows = self.mapIdsToRows(selectedRowIds);\n\n        if (!preserveHidden) {\n          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n        }\n\n        grid.setSelectedRows(selectedRows);\n        inHandler = false;\n      }\n    }\n\n    grid.onSelectedRowsChanged.subscribe(function (e, args) {\n      if (inHandler) {\n        return;\n      }\n\n      var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n\n      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n        setSelectedRowIds(newSelectedRowIds);\n      } else {\n        // keep the ones that are hidden\n        var existing = $.grep(selectedRowIds, function (id) {\n          return self.getRowById(id) === undefined;\n        }); // add the newly selected ones\n\n        setSelectedRowIds(existing.concat(newSelectedRowIds));\n      }\n    });\n    this.onRowsChanged.subscribe(update);\n    this.onRowCountChanged.subscribe(update);\n    return onSelectedRowIdsChanged;\n  }\n\n  function syncGridCellCssStyles(grid, key) {\n    var hashById;\n    var inHandler; // since this method can be called after the cell styles have been set,\n    // get the existing ones right away\n\n    storeCellCssStyles(grid.getCellCssStyles(key));\n\n    function storeCellCssStyles(hash) {\n      hashById = {};\n\n      for (var row in hash) {\n        var id = rows[row][idProperty];\n        hashById[id] = hash[row];\n      }\n    }\n\n    function update() {\n      if (hashById) {\n        inHandler = true;\n        ensureRowsByIdCache();\n        var newHash = {};\n\n        for (var id in hashById) {\n          var row = rowsById[id];\n\n          if (row != undefined) {\n            newHash[row] = hashById[id];\n          }\n        }\n\n        grid.setCellCssStyles(key, newHash);\n        inHandler = false;\n      }\n    }\n\n    grid.onCellCssStylesChanged.subscribe(function (e, args) {\n      if (inHandler) {\n        return;\n      }\n\n      if (key != args.key) {\n        return;\n      }\n\n      if (args.hash) {\n        storeCellCssStyles(args.hash);\n      } else {\n        grid.onCellCssStylesChanged.unsubscribe(styleChanged);\n        self.onRowsChanged.unsubscribe(update);\n        self.onRowCountChanged.unsubscribe(update);\n      }\n    });\n    this.onRowsChanged.subscribe(update);\n    this.onRowCountChanged.subscribe(update);\n  }\n\n  $.extend(this, {\n    // methods\n    \"beginUpdate\": beginUpdate,\n    \"endUpdate\": endUpdate,\n    \"setPagingOptions\": setPagingOptions,\n    \"getPagingInfo\": getPagingInfo,\n    \"getItems\": getItems,\n    \"setItems\": setItems,\n    \"setFilter\": setFilter,\n    \"getFilter\": getFilter,\n    \"getFilteredItems\": getFilteredItems,\n    \"sort\": sort,\n    \"fastSort\": fastSort,\n    \"reSort\": reSort,\n    \"setGrouping\": setGrouping,\n    \"getGrouping\": getGrouping,\n    \"groupBy\": groupBy,\n    \"setAggregators\": setAggregators,\n    \"collapseAllGroups\": collapseAllGroups,\n    \"expandAllGroups\": expandAllGroups,\n    \"collapseGroup\": collapseGroup,\n    \"expandGroup\": expandGroup,\n    \"getGroups\": getGroups,\n    \"getIdxById\": getIdxById,\n    \"getRowByItem\": getRowByItem,\n    \"getRowById\": getRowById,\n    \"getItemById\": getItemById,\n    \"getItemByIdx\": getItemByIdx,\n    \"mapItemsToRows\": mapItemsToRows,\n    \"mapRowsToIds\": mapRowsToIds,\n    \"mapIdsToRows\": mapIdsToRows,\n    \"setRefreshHints\": setRefreshHints,\n    \"setFilterArgs\": setFilterArgs,\n    \"refresh\": refresh,\n    \"updateItem\": updateItem,\n    \"insertItem\": insertItem,\n    \"addItem\": addItem,\n    \"deleteItem\": deleteItem,\n    \"sortedAddItem\": sortedAddItem,\n    \"sortedUpdateItem\": sortedUpdateItem,\n    \"syncGridSelection\": syncGridSelection,\n    \"syncGridCellCssStyles\": syncGridCellCssStyles,\n    // data provider methods\n    \"getLength\": getLength,\n    \"getItem\": getItem,\n    \"getItemMetadata\": getItemMetadata,\n    // events\n    \"onRowCountChanged\": onRowCountChanged,\n    \"onRowsChanged\": onRowsChanged,\n    \"onPagingInfoChanged\": onPagingInfoChanged\n  });\n}\n\nfunction AvgAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.count_ = 0;\n    this.nonNullCount_ = 0;\n    this.sum_ = 0;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n    this.count_++;\n\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      this.nonNullCount_++;\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.avg) {\n      groupTotals.avg = {};\n    }\n\n    if (this.nonNullCount_ != 0) {\n      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n    }\n  };\n}\n\nfunction MinAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.min_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      if (this.min_ == null || val < this.min_) {\n        this.min_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.min) {\n      groupTotals.min = {};\n    }\n\n    groupTotals.min[this.field_] = this.min_;\n  };\n}\n\nfunction MaxAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.max_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      if (this.max_ == null || val > this.max_) {\n        this.max_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.max) {\n      groupTotals.max = {};\n    }\n\n    groupTotals.max[this.field_] = this.max_;\n  };\n}\n\nfunction SumAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.sum_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.sum) {\n      groupTotals.sum = {};\n    }\n\n    groupTotals.sum[this.field_] = this.sum_;\n  };\n} // TODO:  add more built-in aggregators\n// TODO:  merge common aggregators in one to prevent needles iterating\n\n\nvar Aggregators = {\n  Avg: AvgAggregator,\n  Min: MinAggregator,\n  Max: MaxAggregator,\n  Sum: SumAggregator\n};\nmodule.exports = {\n  DataView: DataView,\n  Aggregators: Aggregators,\n  Data: {\n    Aggregators: Aggregators\n  }\n};","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/slickgrid/slick.dataview.js"],"names":["$","require","Slick","DataView","options","self","defaults","groupItemMetadataProvider","inlineFilters","idProperty","items","rows","idxById","rowsById","filter","updated","suspend","sortAsc","fastSortField","sortComparer","refreshHints","prevRefreshHints","filterArgs","filteredItems","compiledFilter","compiledFilterWithCaching","filterCache","groupingInfoDefaults","getter","formatter","comparer","a","b","value","predefinedValues","aggregators","aggregateEmpty","aggregateCollapsed","aggregateChildGroups","collapsed","displayTotalsRow","lazyTotalsCalculation","groupingInfos","groups","toggledGroupsByLevel","groupingDelimiter","pagesize","pagenum","totalRows","onRowCountChanged","Event","onRowsChanged","onPagingInfoChanged","extend","beginUpdate","endUpdate","refresh","setRefreshHints","hints","setFilterArgs","args","updateIdxById","startingIndex","id","i","l","length","undefined","Error","ensureIdUniqueness","getItems","setItems","data","objectIdProperty","setPagingOptions","pageSize","Math","min","max","ceil","pageNum","notify","getPagingInfo","totalPages","dataView","sort","ascending","reverse","fastSort","field","oldToString","Object","prototype","toString","reSort","getFilteredItems","getFilter","setFilter","filterFn","compileFilter","compileFilterWithCaching","getGrouping","setGrouping","groupingInfo","Data","GroupItemMetadataProvider","Array","gi","getterIsAFn","compiledAccumulators","idx","compileAccumulatorLoop","groupBy","valueGetter","valueFormatter","setAggregators","groupAggregators","includeCollapsed","getItemByIdx","getIdxById","ensureRowsByIdCache","getRowByItem","item","getRowById","getItemById","mapItemsToRows","itemArray","row","mapIdsToRows","idArray","mapRowsToIds","rowArray","ids","updateItem","insertItem","insertBefore","splice","addItem","push","deleteItem","sortedAddItem","sortedIndex","sortedUpdateItem","oldItem","searchItem","low","high","mid","getLength","getItem","__group","totals","initialized","level","calculateTotals","title","__groupTotals","getItemMetadata","getGroupRowMetadata","getTotalsRowMetadata","expandCollapseAllGroups","collapse","collapseAllGroups","expandAllGroups","expandCollapseGroup","groupingKey","collapseGroup","varArgs","slice","call","arguments","arg0","indexOf","split","join","expandGroup","getGroups","extractGroups","parentGroup","group","val","groupsByVal","r","Group","count","isLeafLevel","agg","init","storeResult","addGroupTotals","GroupTotals","addTotals","groupCollapsed","toggledGroups","g","flattenGroupedRows","groupedRows","gl","j","jj","getFunctionInfo","fn","fnRegex","matches","match","params","body","aggregator","accumulatorInfo","accumulate","Function","displayName","name","filterInfo","filterPath1","filterPath2","filterBody","replace","tpl","uncompiledFilter","retval","ii","uncompiledFilterWithCaching","cache","getFilteredAndPagedItems","batchFilter","batchFilterWithCaching","isFilterNarrowing","isFilterExpanding","isFilterUnchanged","concat","paged","floor","getRowDiffs","newRows","eitherIsNonData","diff","from","to","ignoreDiffsBefore","ignoreDiffsAfter","rl","__nonDataRow","equals","recalc","_items","countBefore","totalRowsBefore","previous","current","syncGridSelection","grid","preserveHidden","preserveHiddenOnSelectionChange","inHandler","selectedRowIds","getSelectedRows","onSelectedRowIdsChanged","setSelectedRowIds","rowIds","EventData","update","selectedRows","setSelectedRows","onSelectedRowsChanged","subscribe","e","newSelectedRowIds","getOptions","multiSelect","existing","grep","syncGridCellCssStyles","key","hashById","storeCellCssStyles","getCellCssStyles","hash","newHash","setCellCssStyles","onCellCssStylesChanged","unsubscribe","styleChanged","AvgAggregator","field_","count_","nonNullCount_","sum_","isNaN","parseFloat","groupTotals","avg","MinAggregator","min_","MaxAggregator","max_","SumAggregator","sum","Aggregators","Avg","Min","Max","Sum","module","exports"],"mappings":"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","sourcesContent":["  \"use strict\";\n  var $ = require(\"./slick.jquery\");\n  var Slick = require(\"./slick.core\");\n\n  /***\n   * A sample Model implementation.\n   * Provides a filtered view of the underlying data.\n   *\n   * Relies on the data item having an \"id\" property uniquely identifying it.\n   */\n  function DataView(options) {\n    var self = this;\n\n    var defaults = {\n      groupItemMetadataProvider: null,\n      inlineFilters: false\n    };\n\n\n    // private\n    var idProperty = \"id\";  // property holding a unique row id\n    var items = [];         // data by index\n    var rows = [];          // data by row\n    var idxById = {};       // indexes by id\n    var rowsById = null;    // rows by id; lazy-calculated\n    var filter = null;      // filter function\n    var updated = null;     // updated item ids\n    var suspend = false;    // suspends the recalculation\n    var sortAsc = true;\n    var fastSortField;\n    var sortComparer;\n    var refreshHints = {};\n    var prevRefreshHints = {};\n    var filterArgs;\n    var filteredItems = [];\n    var compiledFilter;\n    var compiledFilterWithCaching;\n    var filterCache = [];\n\n    // grouping\n    var groupingInfoDefaults = {\n      getter: null,\n      formatter: null,\n      comparer: function(a, b) {\n        return (a.value === b.value ? 0 :\n          (a.value > b.value ? 1 : -1)\n        );\n      },\n      predefinedValues: [],\n      aggregators: [],\n      aggregateEmpty: false,\n      aggregateCollapsed: false,\n      aggregateChildGroups: false,\n      collapsed: false,\n      displayTotalsRow: true,\n      lazyTotalsCalculation: false\n    };\n    var groupingInfos = [];\n    var groups = [];\n    var toggledGroupsByLevel = [];\n    var groupingDelimiter = ':|:';\n\n    var pagesize = 0;\n    var pagenum = 0;\n    var totalRows = 0;\n\n    // events\n    var onRowCountChanged = new Slick.Event();\n    var onRowsChanged = new Slick.Event();\n    var onPagingInfoChanged = new Slick.Event();\n\n    options = $.extend(true, {}, defaults, options);\n\n\n    function beginUpdate() {\n      suspend = true;\n    }\n\n    function endUpdate() {\n      suspend = false;\n      refresh();\n    }\n\n    function setRefreshHints(hints) {\n      refreshHints = hints;\n    }\n\n    function setFilterArgs(args) {\n      filterArgs = args;\n    }\n\n    function updateIdxById(startingIndex) {\n      startingIndex = startingIndex || 0;\n      var id;\n      for (var i = startingIndex, l = items.length; i < l; i++) {\n        id = items[i][idProperty];\n        if (id === undefined) {\n          throw new Error(\"Each data element must implement a unique 'id' property\");\n        }\n        idxById[id] = i;\n      }\n    }\n\n    function ensureIdUniqueness() {\n      var id;\n      for (var i = 0, l = items.length; i < l; i++) {\n        id = items[i][idProperty];\n        if (id === undefined || idxById[id] !== i) {\n          throw new Error(\"Each data element must implement a unique 'id' property\");\n        }\n      }\n    }\n\n    function getItems() {\n      return items;\n    }\n\n    function setItems(data, objectIdProperty) {\n      if (objectIdProperty !== undefined) {\n        idProperty = objectIdProperty;\n      }\n      items = filteredItems = data;\n      idxById = {};\n      updateIdxById();\n      ensureIdUniqueness();\n      refresh();\n    }\n\n    function setPagingOptions(args) {\n      if (args.pageSize != undefined) {\n        pagesize = args.pageSize;\n        pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n      }\n\n      if (args.pageNum != undefined) {\n        pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n      }\n\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\n      refresh();\n    }\n\n    function getPagingInfo() {\n      var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n      return {pageSize: pagesize, pageNum: pagenum, totalRows: totalRows, totalPages: totalPages, dataView: self};\n    }\n\n    function sort(comparer, ascending) {\n      sortAsc = ascending;\n      sortComparer = comparer;\n      fastSortField = null;\n      if (ascending === false) {\n        items.reverse();\n      }\n      items.sort(comparer);\n      if (ascending === false) {\n        items.reverse();\n      }\n      idxById = {};\n      updateIdxById();\n      refresh();\n    }\n\n    /***\n     * Provides a workaround for the extremely slow sorting in IE.\n     * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n     * to return the value of that field and then doing a native Array.sort().\n     */\n    function fastSort(field, ascending) {\n      sortAsc = ascending;\n      fastSortField = field;\n      sortComparer = null;\n      var oldToString = Object.prototype.toString;\n      Object.prototype.toString = (typeof field == \"function\") ? field : function () {\n        return this[field]\n      };\n      // an extra reversal for descending sort keeps the sort stable\n      // (assuming a stable native sort implementation, which isn't true in some cases)\n      if (ascending === false) {\n        items.reverse();\n      }\n      items.sort();\n      Object.prototype.toString = oldToString;\n      if (ascending === false) {\n        items.reverse();\n      }\n      idxById = {};\n      updateIdxById();\n      refresh();\n    }\n\n    function reSort() {\n      if (sortComparer) {\n        sort(sortComparer, sortAsc);\n      } else if (fastSortField) {\n        fastSort(fastSortField, sortAsc);\n      }\n    }\n\n    function getFilteredItems(){\n      return filteredItems;\n    }\n\n\n    function getFilter(){\n      return filter;\n    }\n\n    function setFilter(filterFn) {\n      filter = filterFn;\n      if (options.inlineFilters) {\n        compiledFilter = compileFilter();\n        compiledFilterWithCaching = compileFilterWithCaching();\n      }\n      refresh();\n    }\n\n    function getGrouping() {\n      return groupingInfos;\n    }\n\n    function setGrouping(groupingInfo) {\n      if (!options.groupItemMetadataProvider) {\n        options.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider();\n      }\n\n      groups = [];\n      toggledGroupsByLevel = [];\n      groupingInfo = groupingInfo || [];\n      groupingInfos = (groupingInfo instanceof Array) ? groupingInfo : [groupingInfo];\n\n      for (var i = 0; i < groupingInfos.length; i++) {\n        var gi = groupingInfos[i] = $.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n        gi.getterIsAFn = typeof gi.getter === \"function\";\n\n        // pre-compile accumulator loops\n        gi.compiledAccumulators = [];\n        var idx = gi.aggregators.length;\n        while (idx--) {\n          gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n        }\n\n        toggledGroupsByLevel[i] = {};\n      }\n\n      refresh();\n    }\n\n    /**\n     * @deprecated Please use {@link setGrouping}.\n     */\n    function groupBy(valueGetter, valueFormatter, sortComparer) {\n      if (valueGetter == null) {\n        setGrouping([]);\n        return;\n      }\n\n      setGrouping({\n        getter: valueGetter,\n        formatter: valueFormatter,\n        comparer: sortComparer\n      });\n    }\n\n    /**\n     * @deprecated Please use {@link setGrouping}.\n     */\n    function setAggregators(groupAggregators, includeCollapsed) {\n      if (!groupingInfos.length) {\n        throw new Error(\"At least one grouping must be specified before calling setAggregators().\");\n      }\n\n      groupingInfos[0].aggregators = groupAggregators;\n      groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\n      setGrouping(groupingInfos);\n    }\n\n    function getItemByIdx(i) {\n      return items[i];\n    }\n\n    function getIdxById(id) {\n      return idxById[id];\n    }\n\n    function ensureRowsByIdCache() {\n      if (!rowsById) {\n        rowsById = {};\n        for (var i = 0, l = rows.length; i < l; i++) {\n          rowsById[rows[i][idProperty]] = i;\n        }\n      }\n    }\n\n    function getRowByItem(item) {\n      ensureRowsByIdCache();\n      return rowsById[item[idProperty]];\n    }\n\n    function getRowById(id) {\n      ensureRowsByIdCache();\n      return rowsById[id];\n    }\n\n    function getItemById(id) {\n      return items[idxById[id]];\n    }\n\n    function mapItemsToRows(itemArray) {\n      var rows = [];\n      ensureRowsByIdCache();\n      for (var i = 0, l = itemArray.length; i < l; i++) {\n        var row = rowsById[itemArray[i][idProperty]];\n        if (row != null) {\n          rows[rows.length] = row;\n        }\n      }\n      return rows;\n    }\n\n    function mapIdsToRows(idArray) {\n      var rows = [];\n      ensureRowsByIdCache();\n      for (var i = 0, l = idArray.length; i < l; i++) {\n        var row = rowsById[idArray[i]];\n        if (row != null) {\n          rows[rows.length] = row;\n        }\n      }\n      return rows;\n    }\n\n    function mapRowsToIds(rowArray) {\n      var ids = [];\n      for (var i = 0, l = rowArray.length; i < l; i++) {\n        if (rowArray[i] < rows.length) {\n          ids[ids.length] = rows[rowArray[i]][idProperty];\n        }\n      }\n      return ids;\n    }\n\n    function updateItem(id, item) {\n      if (idxById[id] === undefined || id !== item[idProperty]) {\n        throw new Error(\"Invalid or non-matching id\");\n      }\n      items[idxById[id]] = item;\n      if (!updated) {\n        updated = {};\n      }\n      updated[id] = true;\n      refresh();\n    }\n\n    function insertItem(insertBefore, item) {\n      items.splice(insertBefore, 0, item);\n      updateIdxById(insertBefore);\n      refresh();\n    }\n\n    function addItem(item) {\n      items.push(item);\n      updateIdxById(items.length - 1);\n      refresh();\n    }\n\n    function deleteItem(id) {\n      var idx = idxById[id];\n      if (idx === undefined) {\n        throw new Error(\"Invalid id\");\n      }\n      delete idxById[id];\n      items.splice(idx, 1);\n      updateIdxById(idx);\n      refresh();\n    }\n\n    function sortedAddItem(item) {\n      if(!sortComparer) {\n        throw new Error(\"sortedAddItem() requires a sort comparer, use sort()\");\n      }\n      insertItem(sortedIndex(item), item);\n    }\n\n    function sortedUpdateItem(id, item) {\n      if (idxById[id] === undefined || id !== item[idProperty]) {\n        throw new Error(\"Invalid or non-matching id \" + idxById[id]);\n      }\n      if(!sortComparer) {\n        throw new Error(\"sortedUpdateItem() requires a sort comparer, use sort()\");\n      }\n      var oldItem = getItemById(id);\n      if(sortComparer(oldItem, item) !== 0) {\n        // item affects sorting -> must use sorted add\n        deleteItem(id);\n        sortedAddItem(item);\n      }\n      else { // update does not affect sorting -> regular update works fine\n        updateItem(id, item);\n      }\n    }\n\n    function sortedIndex(searchItem) {\n      var low = 0, high = items.length;\n\n      while (low < high) {\n        var mid = low + high >>> 1;\n        if (sortComparer(items[mid], searchItem) === -1) {\n          low = mid + 1;\n        }\n        else {\n          high = mid;\n        }\n      }\n      return low;\n    }\n    function getLength() {\n      return rows.length;\n    }\n\n    function getItem(i) {\n      var item = rows[i];\n\n      // if this is a group row, make sure totals are calculated and update the title\n      if (item && item.__group && item.totals && !item.totals.initialized) {\n        var gi = groupingInfos[item.level];\n        if (!gi.displayTotalsRow) {\n          calculateTotals(item.totals);\n          item.title = gi.formatter ? gi.formatter(item) : item.value;\n        }\n      }\n      // if this is a totals row, make sure it's calculated\n      else if (item && item.__groupTotals && !item.initialized) {\n        calculateTotals(item);\n      }\n\n      return item;\n    }\n\n    function getItemMetadata(i) {\n      var item = rows[i];\n      if (item === undefined) {\n        return null;\n      }\n\n      // overrides for grouping rows\n      if (item.__group) {\n        return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n      }\n\n      // overrides for totals rows\n      if (item.__groupTotals) {\n        return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n      }\n\n      return null;\n    }\n\n    function expandCollapseAllGroups(level, collapse) {\n      if (level == null) {\n        for (var i = 0; i < groupingInfos.length; i++) {\n          toggledGroupsByLevel[i] = {};\n          groupingInfos[i].collapsed = collapse;\n        }\n      } else {\n        toggledGroupsByLevel[level] = {};\n        groupingInfos[level].collapsed = collapse;\n      }\n      refresh();\n    }\n\n    /**\n     * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n     */\n    function collapseAllGroups(level) {\n      expandCollapseAllGroups(level, true);\n    }\n\n    /**\n     * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n     */\n    function expandAllGroups(level) {\n      expandCollapseAllGroups(level, false);\n    }\n\n    function expandCollapseGroup(level, groupingKey, collapse) {\n      toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n      refresh();\n    }\n\n    /**\n     * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n     *     variable argument list of grouping values denoting a unique path to the row.  For\n     *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n     *     the 'high' group.\n     */\n    function collapseGroup(varArgs) {\n      var args = Array.prototype.slice.call(arguments);\n      var arg0 = args[0];\n      if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n        expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n      } else {\n        expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n      }\n    }\n\n    /**\n     * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n     *     variable argument list of grouping values denoting a unique path to the row.  For\n     *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n     *     the 'high' group.\n     */\n    function expandGroup(varArgs) {\n      var args = Array.prototype.slice.call(arguments);\n      var arg0 = args[0];\n      if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n        expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n      } else {\n        expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n      }\n    }\n\n    function getGroups() {\n      return groups;\n    }\n\n    function extractGroups(rows, parentGroup) {\n      var group;\n      var val;\n      var groups = [];\n      var groupsByVal = {};\n      var r;\n      var level = parentGroup ? parentGroup.level + 1 : 0;\n      var gi = groupingInfos[level];\n\n      for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n        val = gi.predefinedValues[i];\n        group = groupsByVal[val];\n        if (!group) {\n          group = new Slick.Group();\n          group.value = val;\n          group.level = level;\n          group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n          groups[groups.length] = group;\n          groupsByVal[val] = group;\n        }\n      }\n\n      for (var i = 0, l = rows.length; i < l; i++) {\n        r = rows[i];\n        val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n        group = groupsByVal[val];\n        if (!group) {\n          group = new Slick.Group();\n          group.value = val;\n          group.level = level;\n          group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n          groups[groups.length] = group;\n          groupsByVal[val] = group;\n        }\n\n        group.rows[group.count++] = r;\n      }\n\n      if (level < groupingInfos.length - 1) {\n        for (var i = 0; i < groups.length; i++) {\n          group = groups[i];\n          group.groups = extractGroups(group.rows, group);\n        }\n      }\n\n      groups.sort(groupingInfos[level].comparer);\n\n      return groups;\n    }\n\n    function calculateTotals(totals) {\n      var group = totals.group;\n      var gi = groupingInfos[group.level];\n      var isLeafLevel = (group.level == groupingInfos.length);\n      var agg, idx = gi.aggregators.length;\n\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        // make sure all the subgroups are calculated\n        var i = group.groups.length;\n        while (i--) {\n          if (!group.groups[i].totals.initialized) {\n            calculateTotals(group.groups[i].totals);\n          }\n        }\n      }\n\n      while (idx--) {\n        agg = gi.aggregators[idx];\n        agg.init();\n        if (!isLeafLevel && gi.aggregateChildGroups) {\n          gi.compiledAccumulators[idx].call(agg, group.groups);\n        } else {\n          gi.compiledAccumulators[idx].call(agg, group.rows);\n        }\n        agg.storeResult(totals);\n      }\n      totals.initialized = true;\n    }\n\n    function addGroupTotals(group) {\n      var gi = groupingInfos[group.level];\n      var totals = new Slick.GroupTotals();\n      totals.group = group;\n      group.totals = totals;\n      if (!gi.lazyTotalsCalculation) {\n        calculateTotals(totals);\n      }\n    }\n\n    function addTotals(groups, level) {\n      level = level || 0;\n      var gi = groupingInfos[level];\n      var groupCollapsed = gi.collapsed;\n      var toggledGroups = toggledGroupsByLevel[level];\n      var idx = groups.length, g;\n      while (idx--) {\n        g = groups[idx];\n\n        if (g.collapsed && !gi.aggregateCollapsed) {\n          continue;\n        }\n\n        // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n        if (g.groups) {\n          addTotals(g.groups, level + 1);\n        }\n\n        if (gi.aggregators.length && (\n            gi.aggregateEmpty || g.rows.length || (g.groups && g.groups.length))) {\n          addGroupTotals(g);\n        }\n\n        g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n        g.title = gi.formatter ? gi.formatter(g) : g.value;\n      }\n    }\n\n    function flattenGroupedRows(groups, level) {\n      level = level || 0;\n      var gi = groupingInfos[level];\n      var groupedRows = [], rows, gl = 0, g;\n      for (var i = 0, l = groups.length; i < l; i++) {\n        g = groups[i];\n        groupedRows[gl++] = g;\n\n        if (!g.collapsed) {\n          rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n          for (var j = 0, jj = rows.length; j < jj; j++) {\n            groupedRows[gl++] = rows[j];\n          }\n        }\n\n        if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n          groupedRows[gl++] = g.totals;\n        }\n      }\n      return groupedRows;\n    }\n\n    function getFunctionInfo(fn) {\n      var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n      var matches = fn.toString().match(fnRegex);\n      return {\n        params: matches[1].split(\",\"),\n        body: matches[2]\n      };\n    }\n\n    function compileAccumulatorLoop(aggregator) {\n      var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n      var fn = new Function(\n          \"_items\",\n          \"for (var \" + accumulatorInfo.params[0] + \", _i=0, _il=_items.length; _i<_il; _i++) {\" +\n              accumulatorInfo.params[0] + \" = _items[_i]; \" +\n              accumulatorInfo.body +\n          \"}\"\n      );\n      fn.displayName = fn.name = \"compiledAccumulatorLoop\";\n      return fn;\n    }\n\n    function compileFilter() {\n      var filterInfo = getFunctionInfo(filter);\n\n      var filterPath1 = \"{ continue _coreloop; }$1\";\n      var filterPath2 = \"{ _retval[_idx++] = $item$; continue _coreloop; }$1\";\n      // make some allowances for minification - there's only so far we can go with RegEx\n      var filterBody = filterInfo.body\n          .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n          .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n          .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n          .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n          .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n          \"{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n      // This preserves the function template code after JS compression,\n      // so that replace() commands still work as expected.\n      var tpl = [\n        //\"function(_items, _args) { \",\n        \"var _retval = [], _idx = 0; \",\n        \"var $item$, $args$ = _args; \",\n        \"_coreloop: \",\n        \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \",\n        \"$item$ = _items[_i]; \",\n        \"$filter$; \",\n        \"} \",\n        \"return _retval; \"\n        //\"}\"\n      ].join(\"\");\n      tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n      tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n      tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n      var fn = new Function(\"_items,_args\", tpl);\n      fn.displayName = fn.name = \"compiledFilter\";\n      return fn;\n    }\n\n    function compileFilterWithCaching() {\n      var filterInfo = getFunctionInfo(filter);\n\n      var filterPath1 = \"{ continue _coreloop; }$1\";\n      var filterPath2 = \"{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1\";\n      // make some allowances for minification - there's only so far we can go with RegEx\n      var filterBody = filterInfo.body\n          .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n          .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n          .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n          .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n          .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n          \"{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n      // This preserves the function template code after JS compression,\n      // so that replace() commands still work as expected.\n      var tpl = [\n        //\"function(_items, _args, _cache) { \",\n        \"var _retval = [], _idx = 0; \",\n        \"var $item$, $args$ = _args; \",\n        \"_coreloop: \",\n        \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \",\n        \"$item$ = _items[_i]; \",\n        \"if (_cache[_i]) { \",\n        \"_retval[_idx++] = $item$; \",\n        \"continue _coreloop; \",\n        \"} \",\n        \"$filter$; \",\n        \"} \",\n        \"return _retval; \"\n        //\"}\"\n      ].join(\"\");\n      tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n      tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n      tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n      var fn = new Function(\"_items,_args,_cache\", tpl);\n      fn.displayName = fn.name = \"compiledFilterWithCaching\";\n      return fn;\n    }\n\n    function uncompiledFilter(items, args) {\n      var retval = [], idx = 0;\n\n      for (var i = 0, ii = items.length; i < ii; i++) {\n        if (filter(items[i], args)) {\n          retval[idx++] = items[i];\n        }\n      }\n\n      return retval;\n    }\n\n    function uncompiledFilterWithCaching(items, args, cache) {\n      var retval = [], idx = 0, item;\n\n      for (var i = 0, ii = items.length; i < ii; i++) {\n        item = items[i];\n        if (cache[i]) {\n          retval[idx++] = item;\n        } else if (filter(item, args)) {\n          retval[idx++] = item;\n          cache[i] = true;\n        }\n      }\n\n      return retval;\n    }\n\n    function getFilteredAndPagedItems(items) {\n      if (filter) {\n        var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n        var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\n        if (refreshHints.isFilterNarrowing) {\n          filteredItems = batchFilter(filteredItems, filterArgs);\n        } else if (refreshHints.isFilterExpanding) {\n          filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n        } else if (!refreshHints.isFilterUnchanged) {\n          filteredItems = batchFilter(items, filterArgs);\n        }\n      } else {\n        // special case:  if not filtering and not paging, the resulting\n        // rows collection needs to be a copy so that changes due to sort\n        // can be caught\n        filteredItems = pagesize ? items : items.concat();\n      }\n\n      // get the current page\n      var paged;\n      if (pagesize) {\n        if (filteredItems.length <= pagenum * pagesize) {\n          if (filteredItems.length === 0) {\n            pagenum = 0;\n          } else {\n            pagenum = Math.floor((filteredItems.length - 1) / pagesize);\n          }\n        }\n        paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n      } else {\n        paged = filteredItems;\n      }\n      return {totalRows: filteredItems.length, rows: paged};\n    }\n\n    function getRowDiffs(rows, newRows) {\n      var item, r, eitherIsNonData, diff = [];\n      var from = 0, to = newRows.length;\n\n      if (refreshHints && refreshHints.ignoreDiffsBefore) {\n        from = Math.max(0,\n            Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n      }\n\n      if (refreshHints && refreshHints.ignoreDiffsAfter) {\n        to = Math.min(newRows.length,\n            Math.max(0, refreshHints.ignoreDiffsAfter));\n      }\n\n      for (var i = from, rl = rows.length; i < to; i++) {\n        if (i >= rl) {\n          diff[diff.length] = i;\n        } else {\n          item = newRows[i];\n          r = rows[i];\n\n          if ((groupingInfos.length && (eitherIsNonData = (item.__nonDataRow) || (r.__nonDataRow)) &&\n              item.__group !== r.__group ||\n              item.__group && !item.equals(r))\n              || (eitherIsNonData &&\n              // no good way to compare totals since they are arbitrary DTOs\n              // deep object comparison is pretty expensive\n              // always considering them 'dirty' seems easier for the time being\n              (item.__groupTotals || r.__groupTotals))\n              || item[idProperty] != r[idProperty]\n              || (updated && updated[item[idProperty]])\n              ) {\n            diff[diff.length] = i;\n          }\n        }\n      }\n      return diff;\n    }\n\n    function recalc(_items) {\n      rowsById = null;\n\n      if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing ||\n          refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n        filterCache = [];\n      }\n\n      var filteredItems = getFilteredAndPagedItems(_items);\n      totalRows = filteredItems.totalRows;\n      var newRows = filteredItems.rows;\n\n      groups = [];\n      if (groupingInfos.length) {\n        groups = extractGroups(newRows);\n        if (groups.length) {\n          addTotals(groups);\n          newRows = flattenGroupedRows(groups);\n        }\n      }\n\n      var diff = getRowDiffs(rows, newRows);\n\n      rows = newRows;\n\n      return diff;\n    }\n\n    function refresh() {\n      if (suspend) {\n        return;\n      }\n\n      var countBefore = rows.length;\n      var totalRowsBefore = totalRows;\n\n      var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\n      // if the current page is no longer valid, go to last page and recalc\n      // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n      if (pagesize && totalRows < pagenum * pagesize) {\n        pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n        diff = recalc(items, filter);\n      }\n\n      updated = null;\n      prevRefreshHints = refreshHints;\n      refreshHints = {};\n\n      if (totalRowsBefore !== totalRows) {\n        onPagingInfoChanged.notify(getPagingInfo(), null, self);\n      }\n      if (countBefore !== rows.length) {\n        onRowCountChanged.notify({previous: countBefore, current: rows.length, dataView: self}, null, self);\n      }\n      if (diff.length > 0) {\n        onRowsChanged.notify({rows: diff, dataView: self}, null, self);\n      }\n    }\n\n    /***\n     * Wires the grid and the DataView together to keep row selection tied to item ids.\n     * This is useful since, without it, the grid only knows about rows, so if the items\n     * move around, the same rows stay selected instead of the selection moving along\n     * with the items.\n     *\n     * NOTE:  This doesn't work with cell selection model.\n     *\n     * @param grid {Slick.Grid} The grid to sync selection with.\n     * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n     *     view due to them getting filtered out.\n     * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n     *     that are currently out of the view (see preserveHidden) as selected when selection\n     *     changes.\n     * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n     *     changes.  This is useful since, in combination with the above two options, it allows\n     *     access to the full list selected row ids, and not just the ones visible to the grid.\n     * @method syncGridSelection\n     */\n    function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n      var self = this;\n      var inHandler;\n      var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n      var onSelectedRowIdsChanged = new Slick.Event();\n\n      function setSelectedRowIds(rowIds) {\n        if (selectedRowIds.join(\",\") == rowIds.join(\",\")) {\n          return;\n        }\n\n        selectedRowIds = rowIds;\n\n        onSelectedRowIdsChanged.notify({\n          \"grid\": grid,\n          \"ids\": selectedRowIds,\n          \"dataView\": self\n        }, new Slick.EventData(), self);\n      }\n\n      function update() {\n        if (selectedRowIds.length > 0) {\n          inHandler = true;\n          var selectedRows = self.mapIdsToRows(selectedRowIds);\n          if (!preserveHidden) {\n            setSelectedRowIds(self.mapRowsToIds(selectedRows));\n          }\n          grid.setSelectedRows(selectedRows);\n          inHandler = false;\n        }\n      }\n\n      grid.onSelectedRowsChanged.subscribe(function(e, args) {\n        if (inHandler) { return; }\n        var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n        if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n          setSelectedRowIds(newSelectedRowIds);\n        } else {\n          // keep the ones that are hidden\n          var existing = $.grep(selectedRowIds, function(id) { return self.getRowById(id) === undefined; });\n          // add the newly selected ones\n          setSelectedRowIds(existing.concat(newSelectedRowIds));\n        }\n      });\n\n      this.onRowsChanged.subscribe(update);\n\n      this.onRowCountChanged.subscribe(update);\n\n      return onSelectedRowIdsChanged;\n    }\n\n    function syncGridCellCssStyles(grid, key) {\n      var hashById;\n      var inHandler;\n\n      // since this method can be called after the cell styles have been set,\n      // get the existing ones right away\n      storeCellCssStyles(grid.getCellCssStyles(key));\n\n      function storeCellCssStyles(hash) {\n        hashById = {};\n        for (var row in hash) {\n          var id = rows[row][idProperty];\n          hashById[id] = hash[row];\n        }\n      }\n\n      function update() {\n        if (hashById) {\n          inHandler = true;\n          ensureRowsByIdCache();\n          var newHash = {};\n          for (var id in hashById) {\n            var row = rowsById[id];\n            if (row != undefined) {\n              newHash[row] = hashById[id];\n            }\n          }\n          grid.setCellCssStyles(key, newHash);\n          inHandler = false;\n        }\n      }\n\n      grid.onCellCssStylesChanged.subscribe(function(e, args) {\n        if (inHandler) { return; }\n        if (key != args.key) { return; }\n        if (args.hash) {\n          storeCellCssStyles(args.hash);\n        } else {\n          grid.onCellCssStylesChanged.unsubscribe(styleChanged);\n          self.onRowsChanged.unsubscribe(update);\n          self.onRowCountChanged.unsubscribe(update);\n        }\n      });\n\n      this.onRowsChanged.subscribe(update);\n\n      this.onRowCountChanged.subscribe(update);\n    }\n\n    $.extend(this, {\n      // methods\n      \"beginUpdate\": beginUpdate,\n      \"endUpdate\": endUpdate,\n      \"setPagingOptions\": setPagingOptions,\n      \"getPagingInfo\": getPagingInfo,\n      \"getItems\": getItems,\n      \"setItems\": setItems,\n      \"setFilter\": setFilter,\n      \"getFilter\": getFilter,\n      \"getFilteredItems\": getFilteredItems,\n      \"sort\": sort,\n      \"fastSort\": fastSort,\n      \"reSort\": reSort,\n      \"setGrouping\": setGrouping,\n      \"getGrouping\": getGrouping,\n      \"groupBy\": groupBy,\n      \"setAggregators\": setAggregators,\n      \"collapseAllGroups\": collapseAllGroups,\n      \"expandAllGroups\": expandAllGroups,\n      \"collapseGroup\": collapseGroup,\n      \"expandGroup\": expandGroup,\n      \"getGroups\": getGroups,\n      \"getIdxById\": getIdxById,\n      \"getRowByItem\": getRowByItem,\n      \"getRowById\": getRowById,\n      \"getItemById\": getItemById,\n      \"getItemByIdx\": getItemByIdx,\n      \"mapItemsToRows\": mapItemsToRows,\n      \"mapRowsToIds\": mapRowsToIds,\n      \"mapIdsToRows\": mapIdsToRows,\n      \"setRefreshHints\": setRefreshHints,\n      \"setFilterArgs\": setFilterArgs,\n      \"refresh\": refresh,\n      \"updateItem\": updateItem,\n      \"insertItem\": insertItem,\n      \"addItem\": addItem,\n      \"deleteItem\": deleteItem,\n      \"sortedAddItem\": sortedAddItem,\n      \"sortedUpdateItem\": sortedUpdateItem,\n      \"syncGridSelection\": syncGridSelection,\n      \"syncGridCellCssStyles\": syncGridCellCssStyles,\n\n      // data provider methods\n      \"getLength\": getLength,\n      \"getItem\": getItem,\n      \"getItemMetadata\": getItemMetadata,\n\n      // events\n      \"onRowCountChanged\": onRowCountChanged,\n      \"onRowsChanged\": onRowsChanged,\n      \"onPagingInfoChanged\": onPagingInfoChanged\n    });\n  }\n\n  function AvgAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.count_ = 0;\n      this.nonNullCount_ = 0;\n      this.sum_ = 0;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      this.count_++;\n      if (val != null && val !== \"\" && !isNaN(val)) {\n        this.nonNullCount_++;\n        this.sum_ += parseFloat(val);\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.avg) {\n        groupTotals.avg = {};\n      }\n      if (this.nonNullCount_ != 0) {\n        groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n      }\n    };\n  }\n\n  function MinAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.min_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && !isNaN(val)) {\n        if (this.min_ == null || val < this.min_) {\n          this.min_ = val;\n        }\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.min) {\n        groupTotals.min = {};\n      }\n      groupTotals.min[this.field_] = this.min_;\n    }\n  }\n\n  function MaxAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.max_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && !isNaN(val)) {\n        if (this.max_ == null || val > this.max_) {\n          this.max_ = val;\n        }\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.max) {\n        groupTotals.max = {};\n      }\n      groupTotals.max[this.field_] = this.max_;\n    }\n  }\n\n  function SumAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.sum_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && !isNaN(val)) {\n        this.sum_ += parseFloat(val);\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.sum) {\n        groupTotals.sum = {};\n      }\n      groupTotals.sum[this.field_] = this.sum_;\n    }\n  }\n\n  // TODO:  add more built-in aggregators\n  // TODO:  merge common aggregators in one to prevent needles iterating\n  var Aggregators = {\n    Avg: AvgAggregator,\n    Min: MinAggregator,\n    Max: MaxAggregator,\n    Sum: SumAggregator\n  };\n\n  module.exports = {\n    DataView: DataView,\n    Aggregators: Aggregators,\n    Data: {Aggregators: Aggregators},\n  };\n"]},"metadata":{},"sourceType":"script"}