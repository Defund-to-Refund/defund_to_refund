{"ast":null,"code":"import { Interpolator } from \"./interpolator\";\nimport * as p from \"../../core/properties\";\nimport { min, find_index, find_last_index } from \"../../core/util/array\";\nexport class StepInterpolator extends Interpolator {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_StepInterpolator() {\n    this.define({\n      mode: [p.StepMode, \"after\"]\n    });\n  }\n\n  compute(x) {\n    this.sort(false);\n\n    if (this.clip) {\n      if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) return NaN;\n    } else {\n      if (x < this._x_sorted[0]) return this._y_sorted[0];\n      if (x > this._x_sorted[this._x_sorted.length - 1]) return this._y_sorted[this._y_sorted.length - 1];\n    }\n\n    let ind;\n\n    switch (this.mode) {\n      case \"after\":\n        {\n          ind = find_last_index(this._x_sorted, num => x >= num);\n          break;\n        }\n\n      case \"before\":\n        {\n          ind = find_index(this._x_sorted, num => x <= num);\n          break;\n        }\n\n      case \"center\":\n        {\n          const diffs = this._x_sorted.map(tx => Math.abs(tx - x));\n\n          const mdiff = min(diffs);\n          ind = find_index(diffs, num => mdiff === num);\n          break;\n        }\n\n      default:\n        throw new Error(`unknown mode: ${this.mode}`);\n    }\n\n    return ind != -1 ? this._y_sorted[ind] : NaN;\n  }\n\n}\nStepInterpolator.__name__ = \"StepInterpolator\";\nStepInterpolator.init_StepInterpolator();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/step_interpolator.js"],"names":["Interpolator","p","min","find_index","find_last_index","StepInterpolator","constructor","attrs","init_StepInterpolator","define","mode","StepMode","compute","x","sort","clip","_x_sorted","length","NaN","_y_sorted","ind","num","diffs","map","tx","Math","abs","mdiff","Error","__name__"],"mappings":"AAAA,SAASA,YAAT,QAA6B,gBAA7B;AACA,OAAO,KAAKC,CAAZ,MAAmB,uBAAnB;AACA,SAASC,GAAT,EAAcC,UAAd,EAA0BC,eAA1B,QAAiD,uBAAjD;AACA,OAAO,MAAMC,gBAAN,SAA+BL,YAA/B,CAA4C;AAC/CM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,qBAAP,GAA+B;AAC3B,SAAKC,MAAL,CAAY;AACRC,MAAAA,IAAI,EAAE,CAACT,CAAC,CAACU,QAAH,EAAa,OAAb;AADE,KAAZ;AAGH;;AACDC,EAAAA,OAAO,CAACC,CAAD,EAAI;AACP,SAAKC,IAAL,CAAU,KAAV;;AACA,QAAI,KAAKC,IAAT,EAAe;AACX,UAAIF,CAAC,GAAG,KAAKG,SAAL,CAAe,CAAf,CAAJ,IAAyBH,CAAC,GAAG,KAAKG,SAAL,CAAe,KAAKA,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAjC,EACI,OAAOC,GAAP;AACP,KAHD,MAIK;AACD,UAAIL,CAAC,GAAG,KAAKG,SAAL,CAAe,CAAf,CAAR,EACI,OAAO,KAAKG,SAAL,CAAe,CAAf,CAAP;AACJ,UAAIN,CAAC,GAAG,KAAKG,SAAL,CAAe,KAAKA,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAR,EACI,OAAO,KAAKE,SAAL,CAAe,KAAKA,SAAL,CAAeF,MAAf,GAAwB,CAAvC,CAAP;AACP;;AACD,QAAIG,GAAJ;;AACA,YAAQ,KAAKV,IAAb;AACI,WAAK,OAAL;AAAc;AACVU,UAAAA,GAAG,GAAGhB,eAAe,CAAC,KAAKY,SAAN,EAAiBK,GAAG,IAAIR,CAAC,IAAIQ,GAA7B,CAArB;AACA;AACH;;AACD,WAAK,QAAL;AAAe;AACXD,UAAAA,GAAG,GAAGjB,UAAU,CAAC,KAAKa,SAAN,EAAiBK,GAAG,IAAIR,CAAC,IAAIQ,GAA7B,CAAhB;AACA;AACH;;AACD,WAAK,QAAL;AAAe;AACX,gBAAMC,KAAK,GAAG,KAAKN,SAAL,CAAeO,GAAf,CAAoBC,EAAD,IAAQC,IAAI,CAACC,GAAL,CAASF,EAAE,GAAGX,CAAd,CAA3B,CAAd;;AACA,gBAAMc,KAAK,GAAGzB,GAAG,CAACoB,KAAD,CAAjB;AACAF,UAAAA,GAAG,GAAGjB,UAAU,CAACmB,KAAD,EAAQD,GAAG,IAAIM,KAAK,KAAKN,GAAzB,CAAhB;AACA;AACH;;AACD;AACI,cAAM,IAAIO,KAAJ,CAAW,iBAAgB,KAAKlB,IAAK,EAArC,CAAN;AAhBR;;AAkBA,WAAOU,GAAG,IAAI,CAAC,CAAR,GAAY,KAAKD,SAAL,CAAeC,GAAf,CAAZ,GAAkCF,GAAzC;AACH;;AAzC8C;AA2CnDb,gBAAgB,CAACwB,QAAjB,GAA4B,kBAA5B;AACAxB,gBAAgB,CAACG,qBAAjB","sourcesContent":["import { Interpolator } from \"./interpolator\";\nimport * as p from \"../../core/properties\";\nimport { min, find_index, find_last_index } from \"../../core/util/array\";\nexport class StepInterpolator extends Interpolator {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_StepInterpolator() {\n        this.define({\n            mode: [p.StepMode, \"after\"],\n        });\n    }\n    compute(x) {\n        this.sort(false);\n        if (this.clip) {\n            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1])\n                return NaN;\n        }\n        else {\n            if (x < this._x_sorted[0])\n                return this._y_sorted[0];\n            if (x > this._x_sorted[this._x_sorted.length - 1])\n                return this._y_sorted[this._y_sorted.length - 1];\n        }\n        let ind;\n        switch (this.mode) {\n            case \"after\": {\n                ind = find_last_index(this._x_sorted, num => x >= num);\n                break;\n            }\n            case \"before\": {\n                ind = find_index(this._x_sorted, num => x <= num);\n                break;\n            }\n            case \"center\": {\n                const diffs = this._x_sorted.map((tx) => Math.abs(tx - x));\n                const mdiff = min(diffs);\n                ind = find_index(diffs, num => mdiff === num);\n                break;\n            }\n            default:\n                throw new Error(`unknown mode: ${this.mode}`);\n        }\n        return ind != -1 ? this._y_sorted[ind] : NaN;\n    }\n}\nStepInterpolator.__name__ = \"StepInterpolator\";\nStepInterpolator.init_StepInterpolator();\n//# sourceMappingURL=step_interpolator.js.map"]},"metadata":{},"sourceType":"module"}