{"ast":null,"code":"import { uniqueId } from \"../core/util/string\";\nexport class Message {\n  constructor(header, metadata, content) {\n    this.header = header;\n    this.metadata = metadata;\n    this.content = content;\n    this.buffers = [];\n  }\n\n  static assemble(header_json, metadata_json, content_json) {\n    const header = JSON.parse(header_json);\n    const metadata = JSON.parse(metadata_json);\n    const content = JSON.parse(content_json);\n    return new Message(header, metadata, content);\n  }\n\n  assemble_buffer(buf_header, buf_payload) {\n    const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n    if (nb <= this.buffers.length) throw new Error(\"too many buffers received, expecting #{nb}\");\n    this.buffers.push([buf_header, buf_payload]);\n  } // not defined for BokehJS, only *receiving* buffers is supported\n  // add_buffer: (buf_header, buf_payload) ->\n  // write_buffers: (socket)\n\n\n  static create(msgtype, metadata, content = {}) {\n    const header = Message.create_header(msgtype);\n    return new Message(header, metadata, content);\n  }\n\n  static create_header(msgtype) {\n    return {\n      msgid: uniqueId(),\n      msgtype\n    };\n  }\n\n  complete() {\n    if (this.header != null && this.metadata != null && this.content != null) {\n      if ('num_buffers' in this.header) return this.buffers.length === this.header.num_buffers;else return true;\n    } else return false;\n  }\n\n  send(socket) {\n    const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n    if (nb > 0) throw new Error(\"BokehJS only supports receiving buffers, not sending\");\n    const header_json = JSON.stringify(this.header);\n    const metadata_json = JSON.stringify(this.metadata);\n    const content_json = JSON.stringify(this.content);\n    socket.send(header_json);\n    socket.send(metadata_json);\n    socket.send(content_json);\n  }\n\n  msgid() {\n    return this.header.msgid;\n  }\n\n  msgtype() {\n    return this.header.msgtype;\n  }\n\n  reqid() {\n    return this.header.reqid;\n  } // return the reason we should close on bad protocol, if there is one\n\n\n  problem() {\n    if (!('msgid' in this.header)) return \"No msgid in header\";else if (!('msgtype' in this.header)) return \"No msgtype in header\";else return null;\n  }\n\n}\nMessage.__name__ = \"Message\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/protocol/message.js"],"names":["uniqueId","Message","constructor","header","metadata","content","buffers","assemble","header_json","metadata_json","content_json","JSON","parse","assemble_buffer","buf_header","buf_payload","nb","num_buffers","length","Error","push","create","msgtype","create_header","msgid","complete","send","socket","stringify","reqid","problem","__name__"],"mappings":"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","sourcesContent":["import { uniqueId } from \"../core/util/string\";\nexport class Message {\n    constructor(header, metadata, content) {\n        this.header = header;\n        this.metadata = metadata;\n        this.content = content;\n        this.buffers = [];\n    }\n    static assemble(header_json, metadata_json, content_json) {\n        const header = JSON.parse(header_json);\n        const metadata = JSON.parse(metadata_json);\n        const content = JSON.parse(content_json);\n        return new Message(header, metadata, content);\n    }\n    assemble_buffer(buf_header, buf_payload) {\n        const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n        if (nb <= this.buffers.length)\n            throw new Error(\"too many buffers received, expecting #{nb}\");\n        this.buffers.push([buf_header, buf_payload]);\n    }\n    // not defined for BokehJS, only *receiving* buffers is supported\n    // add_buffer: (buf_header, buf_payload) ->\n    // write_buffers: (socket)\n    static create(msgtype, metadata, content = {}) {\n        const header = Message.create_header(msgtype);\n        return new Message(header, metadata, content);\n    }\n    static create_header(msgtype) {\n        return {\n            msgid: uniqueId(),\n            msgtype,\n        };\n    }\n    complete() {\n        if (this.header != null && this.metadata != null && this.content != null) {\n            if ('num_buffers' in this.header)\n                return this.buffers.length === this.header.num_buffers;\n            else\n                return true;\n        }\n        else\n            return false;\n    }\n    send(socket) {\n        const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n        if (nb > 0)\n            throw new Error(\"BokehJS only supports receiving buffers, not sending\");\n        const header_json = JSON.stringify(this.header);\n        const metadata_json = JSON.stringify(this.metadata);\n        const content_json = JSON.stringify(this.content);\n        socket.send(header_json);\n        socket.send(metadata_json);\n        socket.send(content_json);\n    }\n    msgid() {\n        return this.header.msgid;\n    }\n    msgtype() {\n        return this.header.msgtype;\n    }\n    reqid() {\n        return this.header.reqid;\n    }\n    // return the reason we should close on bad protocol, if there is one\n    problem() {\n        if (!('msgid' in this.header))\n            return \"No msgid in header\";\n        else if (!('msgtype' in this.header))\n            return \"No msgtype in header\";\n        else\n            return null;\n    }\n}\nMessage.__name__ = \"Message\";\n//# sourceMappingURL=message.js.map"]},"metadata":{},"sourceType":"module"}