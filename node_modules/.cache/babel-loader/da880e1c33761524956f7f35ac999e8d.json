{"ast":null,"code":"import { GuideRenderer, GuideRendererView } from \"../renderers/guide_renderer\";\nimport * as p from \"../../core/properties\";\nimport { isArray } from \"../../core/util/types\";\nexport class GridView extends GuideRendererView {\n  render() {\n    if (!this.model.visible) return;\n    const ctx = this.plot_view.canvas_view.ctx;\n    ctx.save();\n\n    this._draw_regions(ctx);\n\n    this._draw_minor_grids(ctx);\n\n    this._draw_grids(ctx);\n\n    ctx.restore();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.model.change, () => this.request_render());\n  }\n\n  _draw_regions(ctx) {\n    if (!this.visuals.band_fill.doit && !this.visuals.band_hatch.doit) return;\n    this.visuals.band_fill.set_value(ctx);\n    const [xs, ys] = this.grid_coords('major', false);\n\n    for (let i = 0; i < xs.length - 1; i++) {\n      if (i % 2 != 1) continue;\n      const [sx0, sy0] = this.plot_view.map_to_screen(xs[i], ys[i], this.model.x_range_name, this.model.y_range_name);\n      const [sx1, sy1] = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this.model.x_range_name, this.model.y_range_name);\n      if (this.visuals.band_fill.doit) ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n      this.visuals.band_hatch.doit2(ctx, i, () => {\n        ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n      }, () => this.request_render());\n    }\n  }\n\n  _draw_grids(ctx) {\n    if (!this.visuals.grid_line.doit) return;\n    const [xs, ys] = this.grid_coords('major');\n\n    this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\n  }\n\n  _draw_minor_grids(ctx) {\n    if (!this.visuals.minor_grid_line.doit) return;\n    const [xs, ys] = this.grid_coords('minor');\n\n    this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\n  }\n\n  _draw_grid_helper(ctx, visuals, xs, ys) {\n    visuals.set_value(ctx);\n\n    for (let i = 0; i < xs.length; i++) {\n      const [sx, sy] = this.plot_view.map_to_screen(xs[i], ys[i], this.model.x_range_name, this.model.y_range_name);\n      ctx.beginPath();\n      ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\n\n      for (let i = 1; i < sx.length; i++) ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\n\n      ctx.stroke();\n    }\n  } // {{{ TODO: state\n\n\n  ranges() {\n    const i = this.model.dimension;\n    const j = (i + 1) % 2;\n    const frame = this.plot_view.frame;\n    const ranges = [frame.x_ranges[this.model.x_range_name], frame.y_ranges[this.model.y_range_name]];\n    return [ranges[i], ranges[j]];\n  }\n\n  computed_bounds() {\n    const [range] = this.ranges();\n    const user_bounds = this.model.bounds;\n    const range_bounds = [range.min, range.max];\n    let start;\n    let end;\n\n    if (isArray(user_bounds)) {\n      start = Math.min(user_bounds[0], user_bounds[1]);\n      end = Math.max(user_bounds[0], user_bounds[1]);\n      if (start < range_bounds[0]) start = range_bounds[0]; // XXX:\n      //else if (start > range_bounds[1])\n      //  start = null\n\n      if (end > range_bounds[1]) end = range_bounds[1]; // XXX:\n      //else if (end < range_bounds[0])\n      //  end = null\n    } else {\n      [start, end] = range_bounds;\n\n      for (const axis_view of this.plot_view.axis_views) {\n        if (axis_view.dimension == this.model.dimension && axis_view.model.x_range_name == this.model.x_range_name && axis_view.model.y_range_name == this.model.y_range_name) {\n          [start, end] = axis_view.computed_bounds;\n        }\n      }\n    }\n\n    return [start, end];\n  }\n\n  grid_coords(location, exclude_ends = true) {\n    const i = this.model.dimension;\n    const j = (i + 1) % 2;\n    const [range, cross_range] = this.ranges();\n    let [start, end] = this.computed_bounds();\n    [start, end] = [Math.min(start, end), Math.max(start, end)];\n    const coords = [[], []]; // TODO: (bev) using cross_range.min for cross_loc is a bit of a cheat. Since we\n    // currently only support \"straight line\" grids, this should be OK for now. If\n    // we ever want to support \"curved\" grids, e.g. for some projections, we may\n    // have to communicate more than just a single cross location.\n\n    const ticker = this.model.get_ticker();\n\n    if (ticker == null) {\n      return coords;\n    }\n\n    const ticks = ticker.get_ticks(start, end, range, cross_range.min, {})[location];\n    const min = range.min;\n    const max = range.max;\n    const cmin = cross_range.min;\n    const cmax = cross_range.max;\n\n    if (!exclude_ends) {\n      if (ticks[0] != min) ticks.splice(0, 0, min);\n      if (ticks[ticks.length - 1] != max) ticks.push(max);\n    }\n\n    for (let ii = 0; ii < ticks.length; ii++) {\n      if ((ticks[ii] == min || ticks[ii] == max) && exclude_ends) continue;\n      const dim_i = [];\n      const dim_j = [];\n      const N = 2;\n\n      for (let n = 0; n < N; n++) {\n        const loc = cmin + (cmax - cmin) / (N - 1) * n;\n        dim_i.push(ticks[ii]);\n        dim_j.push(loc);\n      }\n\n      coords[i].push(dim_i);\n      coords[j].push(dim_j);\n    }\n\n    return coords;\n  }\n\n}\nGridView.__name__ = \"GridView\";\nexport class Grid extends GuideRenderer {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Grid() {\n    this.prototype.default_view = GridView;\n    this.mixins(['line:grid_', 'line:minor_grid_', 'fill:band_', 'hatch:band_']);\n    this.define({\n      bounds: [p.Any, 'auto'],\n      dimension: [p.Any, 0],\n      axis: [p.Instance],\n      ticker: [p.Instance],\n      x_range_name: [p.String, 'default'],\n      y_range_name: [p.String, 'default']\n    });\n    this.override({\n      level: \"underlay\",\n      band_fill_color: null,\n      band_fill_alpha: 0,\n      grid_line_color: '#e5e5e5',\n      minor_grid_line_color: null\n    });\n  }\n\n  get_ticker() {\n    if (this.ticker != null) {\n      return this.ticker;\n    }\n\n    if (this.axis != null) {\n      return this.axis.ticker;\n    }\n\n    return null;\n  }\n\n}\nGrid.__name__ = \"Grid\";\nGrid.init_Grid();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/grids/grid.js"],"names":["GuideRenderer","GuideRendererView","p","isArray","GridView","render","model","visible","ctx","plot_view","canvas_view","save","_draw_regions","_draw_minor_grids","_draw_grids","restore","connect_signals","connect","change","request_render","visuals","band_fill","doit","band_hatch","set_value","xs","ys","grid_coords","i","length","sx0","sy0","map_to_screen","x_range_name","y_range_name","sx1","sy1","fillRect","doit2","grid_line","_draw_grid_helper","minor_grid_line","sx","sy","beginPath","moveTo","Math","round","lineTo","stroke","ranges","dimension","j","frame","x_ranges","y_ranges","computed_bounds","range","user_bounds","bounds","range_bounds","min","max","start","end","axis_view","axis_views","location","exclude_ends","cross_range","coords","ticker","get_ticker","ticks","get_ticks","cmin","cmax","splice","push","ii","dim_i","dim_j","N","n","loc","__name__","Grid","constructor","attrs","init_Grid","prototype","default_view","mixins","define","Any","axis","Instance","String","override","level","band_fill_color","band_fill_alpha","grid_line_color","minor_grid_line_color"],"mappings":"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","sourcesContent":["import { GuideRenderer, GuideRendererView } from \"../renderers/guide_renderer\";\nimport * as p from \"../../core/properties\";\nimport { isArray } from \"../../core/util/types\";\nexport class GridView extends GuideRendererView {\n    render() {\n        if (!this.model.visible)\n            return;\n        const ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_regions(ctx);\n        this._draw_minor_grids(ctx);\n        this._draw_grids(ctx);\n        ctx.restore();\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.change, () => this.request_render());\n    }\n    _draw_regions(ctx) {\n        if (!this.visuals.band_fill.doit && !this.visuals.band_hatch.doit)\n            return;\n        this.visuals.band_fill.set_value(ctx);\n        const [xs, ys] = this.grid_coords('major', false);\n        for (let i = 0; i < xs.length - 1; i++) {\n            if (i % 2 != 1)\n                continue;\n            const [sx0, sy0] = this.plot_view.map_to_screen(xs[i], ys[i], this.model.x_range_name, this.model.y_range_name);\n            const [sx1, sy1] = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this.model.x_range_name, this.model.y_range_name);\n            if (this.visuals.band_fill.doit)\n                ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n            this.visuals.band_hatch.doit2(ctx, i, () => {\n                ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n            }, () => this.request_render());\n        }\n    }\n    _draw_grids(ctx) {\n        if (!this.visuals.grid_line.doit)\n            return;\n        const [xs, ys] = this.grid_coords('major');\n        this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\n    }\n    _draw_minor_grids(ctx) {\n        if (!this.visuals.minor_grid_line.doit)\n            return;\n        const [xs, ys] = this.grid_coords('minor');\n        this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\n    }\n    _draw_grid_helper(ctx, visuals, xs, ys) {\n        visuals.set_value(ctx);\n        for (let i = 0; i < xs.length; i++) {\n            const [sx, sy] = this.plot_view.map_to_screen(xs[i], ys[i], this.model.x_range_name, this.model.y_range_name);\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\n            for (let i = 1; i < sx.length; i++)\n                ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\n            ctx.stroke();\n        }\n    }\n    // {{{ TODO: state\n    ranges() {\n        const i = this.model.dimension;\n        const j = (i + 1) % 2;\n        const frame = this.plot_view.frame;\n        const ranges = [\n            frame.x_ranges[this.model.x_range_name],\n            frame.y_ranges[this.model.y_range_name],\n        ];\n        return [ranges[i], ranges[j]];\n    }\n    computed_bounds() {\n        const [range] = this.ranges();\n        const user_bounds = this.model.bounds;\n        const range_bounds = [range.min, range.max];\n        let start;\n        let end;\n        if (isArray(user_bounds)) {\n            start = Math.min(user_bounds[0], user_bounds[1]);\n            end = Math.max(user_bounds[0], user_bounds[1]);\n            if (start < range_bounds[0])\n                start = range_bounds[0];\n            // XXX:\n            //else if (start > range_bounds[1])\n            //  start = null\n            if (end > range_bounds[1])\n                end = range_bounds[1];\n            // XXX:\n            //else if (end < range_bounds[0])\n            //  end = null\n        }\n        else {\n            [start, end] = range_bounds;\n            for (const axis_view of this.plot_view.axis_views) {\n                if (axis_view.dimension == this.model.dimension\n                    && axis_view.model.x_range_name == this.model.x_range_name\n                    && axis_view.model.y_range_name == this.model.y_range_name) {\n                    [start, end] = axis_view.computed_bounds;\n                }\n            }\n        }\n        return [start, end];\n    }\n    grid_coords(location, exclude_ends = true) {\n        const i = this.model.dimension;\n        const j = (i + 1) % 2;\n        const [range, cross_range] = this.ranges();\n        let [start, end] = this.computed_bounds();\n        [start, end] = [Math.min(start, end), Math.max(start, end)];\n        const coords = [[], []];\n        // TODO: (bev) using cross_range.min for cross_loc is a bit of a cheat. Since we\n        // currently only support \"straight line\" grids, this should be OK for now. If\n        // we ever want to support \"curved\" grids, e.g. for some projections, we may\n        // have to communicate more than just a single cross location.\n        const ticker = this.model.get_ticker();\n        if (ticker == null) {\n            return coords;\n        }\n        const ticks = ticker.get_ticks(start, end, range, cross_range.min, {})[location];\n        const min = range.min;\n        const max = range.max;\n        const cmin = cross_range.min;\n        const cmax = cross_range.max;\n        if (!exclude_ends) {\n            if (ticks[0] != min)\n                ticks.splice(0, 0, min);\n            if (ticks[ticks.length - 1] != max)\n                ticks.push(max);\n        }\n        for (let ii = 0; ii < ticks.length; ii++) {\n            if ((ticks[ii] == min || ticks[ii] == max) && exclude_ends)\n                continue;\n            const dim_i = [];\n            const dim_j = [];\n            const N = 2;\n            for (let n = 0; n < N; n++) {\n                const loc = cmin + (cmax - cmin) / (N - 1) * n;\n                dim_i.push(ticks[ii]);\n                dim_j.push(loc);\n            }\n            coords[i].push(dim_i);\n            coords[j].push(dim_j);\n        }\n        return coords;\n    }\n}\nGridView.__name__ = \"GridView\";\nexport class Grid extends GuideRenderer {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Grid() {\n        this.prototype.default_view = GridView;\n        this.mixins(['line:grid_', 'line:minor_grid_', 'fill:band_', 'hatch:band_']);\n        this.define({\n            bounds: [p.Any, 'auto'],\n            dimension: [p.Any, 0],\n            axis: [p.Instance],\n            ticker: [p.Instance],\n            x_range_name: [p.String, 'default'],\n            y_range_name: [p.String, 'default'],\n        });\n        this.override({\n            level: \"underlay\",\n            band_fill_color: null,\n            band_fill_alpha: 0,\n            grid_line_color: '#e5e5e5',\n            minor_grid_line_color: null,\n        });\n    }\n    get_ticker() {\n        if (this.ticker != null) {\n            return this.ticker;\n        }\n        if (this.axis != null) {\n            return this.axis.ticker;\n        }\n        return null;\n    }\n}\nGrid.__name__ = \"Grid\";\nGrid.init_Grid();\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}