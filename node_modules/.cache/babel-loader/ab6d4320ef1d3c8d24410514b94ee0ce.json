{"ast":null,"code":"import { CenterRotatable, CenterRotatableView } from \"./center_rotatable\";\nimport * as hittest from \"../../core/hittest\";\nexport class EllipseOvalView extends CenterRotatableView {\n  _set_data() {\n    this.max_w2 = 0;\n    if (this.model.properties.width.units == \"data\") this.max_w2 = this.max_width / 2;\n    this.max_h2 = 0;\n    if (this.model.properties.height.units == \"data\") this.max_h2 = this.max_height / 2;\n  }\n\n  _map_data() {\n    if (this.model.properties.width.units == \"data\") this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');else this.sw = this._width;\n    if (this.model.properties.height.units == \"data\") this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');else this.sh = this._height;\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    sw,\n    sh,\n    _angle\n  }) {\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + _angle[i])) continue;\n      ctx.beginPath();\n      ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, _angle[i], 0, 2 * Math.PI);\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n        ctx.fill();\n      }\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    let x0, x1, y0, y1, cond, dist, sx0, sx1, sy0, sy1;\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy);\n\n    if (this.model.properties.width.units == \"data\") {\n      x0 = x - this.max_width;\n      x1 = x + this.max_width;\n    } else {\n      sx0 = sx - this.max_width;\n      sx1 = sx + this.max_width;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    }\n\n    if (this.model.properties.height.units == \"data\") {\n      y0 = y - this.max_height;\n      y1 = y + this.max_height;\n    } else {\n      sy0 = sy - this.max_height;\n      sy1 = sy + this.max_height;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    const candidates = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    const hits = [];\n\n    for (const i of candidates) {\n      cond = hittest.point_in_ellipse(sx, sy, this._angle[i], this.sh[i] / 2, this.sw[i] / 2, this.sx[i], this.sy[i]);\n\n      if (cond) {\n        [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n        [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n        dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n        hits.push([i, dist]);\n      }\n    }\n\n    return hittest.create_hit_test_result_from_hits(hits);\n  }\n\n  draw_legend_for_index(ctx, {\n    x0,\n    y0,\n    x1,\n    y1\n  }, index) {\n    const len = index + 1;\n    const sx = new Array(len);\n    sx[index] = (x0 + x1) / 2;\n    const sy = new Array(len);\n    sy[index] = (y0 + y1) / 2;\n    const scale = this.sw[index] / this.sh[index];\n    const d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n    const sw = new Array(len);\n    const sh = new Array(len);\n\n    if (scale > 1) {\n      sw[index] = d;\n      sh[index] = d / scale;\n    } else {\n      sw[index] = d * scale;\n      sh[index] = d;\n    }\n\n    this._render(ctx, [index], {\n      sx,\n      sy,\n      sw,\n      sh,\n      _angle: [0]\n    }); // XXX\n\n  }\n\n  _bounds({\n    x0,\n    x1,\n    y0,\n    y1\n  }) {\n    return {\n      x0: x0 - this.max_w2,\n      x1: x1 + this.max_w2,\n      y0: y0 - this.max_h2,\n      y1: y1 + this.max_h2\n    };\n  }\n\n}\nEllipseOvalView.__name__ = \"EllipseOvalView\";\nexport class EllipseOval extends CenterRotatable {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n}\nEllipseOval.__name__ = \"EllipseOval\";","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/ellipse_oval.js"],"names":["CenterRotatable","CenterRotatableView","hittest","EllipseOvalView","_set_data","max_w2","model","properties","width","units","max_width","max_h2","height","max_height","_map_data","sw","sdist","renderer","xscale","_x","_width","sh","yscale","_y","_height","_render","ctx","indices","sx","sy","_angle","i","isNaN","beginPath","ellipse","Math","PI","visuals","fill","doit","set_vectorize","line","stroke","_hit_point","geometry","x0","x1","y0","y1","cond","dist","sx0","sx1","sy0","sy1","x","invert","y","r_invert","candidates","index","hits","point_in_ellipse","r_compute","push","create_hit_test_result_from_hits","draw_legend_for_index","len","Array","scale","d","min","abs","_bounds","__name__","EllipseOval","constructor","attrs"],"mappings":"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","sourcesContent":["import { CenterRotatable, CenterRotatableView } from \"./center_rotatable\";\nimport * as hittest from \"../../core/hittest\";\nexport class EllipseOvalView extends CenterRotatableView {\n    _set_data() {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units == \"data\")\n            this.max_w2 = this.max_width / 2;\n        this.max_h2 = 0;\n        if (this.model.properties.height.units == \"data\")\n            this.max_h2 = this.max_height / 2;\n    }\n    _map_data() {\n        if (this.model.properties.width.units == \"data\")\n            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n        else\n            this.sw = this._width;\n        if (this.model.properties.height.units == \"data\")\n            this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n        else\n            this.sh = this._height;\n    }\n    _render(ctx, indices, { sx, sy, sw, sh, _angle }) {\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + _angle[i]))\n                continue;\n            ctx.beginPath();\n            ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, _angle[i], 0, 2 * Math.PI);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        let x0, x1, y0, y1, cond, dist, sx0, sx1, sy0, sy1;\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        if (this.model.properties.width.units == \"data\") {\n            x0 = x - this.max_width;\n            x1 = x + this.max_width;\n        }\n        else {\n            sx0 = sx - this.max_width;\n            sx1 = sx + this.max_width;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        }\n        if (this.model.properties.height.units == \"data\") {\n            y0 = y - this.max_height;\n            y1 = y + this.max_height;\n        }\n        else {\n            sy0 = sy - this.max_height;\n            sy1 = sy + this.max_height;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        const candidates = this.index.indices({ x0, x1, y0, y1 });\n        const hits = [];\n        for (const i of candidates) {\n            cond = hittest.point_in_ellipse(sx, sy, this._angle[i], this.sh[i] / 2, this.sw[i] / 2, this.sx[i], this.sy[i]);\n            if (cond) {\n                [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_hit_test_result_from_hits(hits);\n    }\n    draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\n        const len = index + 1;\n        const sx = new Array(len);\n        sx[index] = (x0 + x1) / 2;\n        const sy = new Array(len);\n        sy[index] = (y0 + y1) / 2;\n        const scale = this.sw[index] / this.sh[index];\n        const d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n        const sw = new Array(len);\n        const sh = new Array(len);\n        if (scale > 1) {\n            sw[index] = d;\n            sh[index] = d / scale;\n        }\n        else {\n            sw[index] = d * scale;\n            sh[index] = d;\n        }\n        this._render(ctx, [index], { sx, sy, sw, sh, _angle: [0] }); // XXX\n    }\n    _bounds({ x0, x1, y0, y1 }) {\n        return {\n            x0: x0 - this.max_w2,\n            x1: x1 + this.max_w2,\n            y0: y0 - this.max_h2,\n            y1: y1 + this.max_h2,\n        };\n    }\n}\nEllipseOvalView.__name__ = \"EllipseOvalView\";\nexport class EllipseOval extends CenterRotatable {\n    constructor(attrs) {\n        super(attrs);\n    }\n}\nEllipseOval.__name__ = \"EllipseOval\";\n//# sourceMappingURL=ellipse_oval.js.map"]},"metadata":{},"sourceType":"module"}