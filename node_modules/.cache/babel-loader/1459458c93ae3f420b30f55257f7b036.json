{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_line_legend, line_interpolation } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nexport class LineView extends XYGlyphView {\n  _render(ctx, indices, {\n    sx,\n    sy\n  }) {\n    let drawing = false;\n    let last_index = null;\n    this.visuals.line.set_value(ctx);\n\n    for (const i of indices) {\n      if (drawing) {\n        if (!isFinite(sx[i] + sy[i])) {\n          ctx.stroke();\n          ctx.beginPath();\n          drawing = false;\n          last_index = i;\n          continue;\n        }\n\n        if (last_index != null && i - last_index > 1) {\n          ctx.stroke();\n          drawing = false;\n        }\n      }\n\n      if (drawing) ctx.lineTo(sx[i], sy[i]);else {\n        ctx.beginPath();\n        ctx.moveTo(sx[i], sy[i]);\n        drawing = true;\n      }\n      last_index = i;\n    }\n\n    if (drawing) ctx.stroke();\n  }\n\n  _hit_point(geometry) {\n    /* Check if the point geometry hits this line glyph and return an object\n    that describes the hit result:\n      Args:\n        * geometry (object): object with the following keys\n          * sx (float): screen x coordinate of the point\n          * sy (float): screen y coordinate of the point\n          * type (str): type of geometry (in this case it's a point)\n    */\n    const result = hittest.create_empty_hit_test_result();\n    const point = {\n      x: geometry.sx,\n      y: geometry.sy\n    };\n    let shortest = 9999;\n    const threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n\n    for (let i = 0, end = this.sx.length - 1; i < end; i++) {\n      const p0 = {\n        x: this.sx[i],\n        y: this.sy[i]\n      };\n      const p1 = {\n        x: this.sx[i + 1],\n        y: this.sy[i + 1]\n      };\n      const dist = hittest.dist_to_segment(point, p0, p1);\n\n      if (dist < threshold && dist < shortest) {\n        shortest = dist;\n        result.add_to_selected_glyphs(this.model);\n\n        result.get_view = () => this;\n\n        result.line_indices = [i];\n      }\n    }\n\n    return result;\n  }\n\n  _hit_span(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const result = hittest.create_empty_hit_test_result();\n    let val;\n    let values;\n\n    if (geometry.direction == 'v') {\n      val = this.renderer.yscale.invert(sy);\n      values = this._y;\n    } else {\n      val = this.renderer.xscale.invert(sx);\n      values = this._x;\n    }\n\n    for (let i = 0, end = values.length - 1; i < end; i++) {\n      if (values[i] <= val && val <= values[i + 1] || values[i + 1] <= val && val <= values[i]) {\n        result.add_to_selected_glyphs(this.model);\n\n        result.get_view = () => this;\n\n        result.line_indices.push(i);\n      }\n    }\n\n    return result;\n  }\n\n  get_interpolation_hit(i, geometry) {\n    const [x2, y2, x3, y3] = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]];\n    return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_line_legend(this.visuals, ctx, bbox, index);\n  }\n\n}\nLineView.__name__ = \"LineView\";\nexport class Line extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Line() {\n    this.prototype.default_view = LineView;\n    this.mixins(['line']);\n  }\n\n}\nLine.__name__ = \"Line\";\nLine.init_Line();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/line.js"],"names":["XYGlyph","XYGlyphView","generic_line_legend","line_interpolation","hittest","LineView","_render","ctx","indices","sx","sy","drawing","last_index","visuals","line","set_value","i","isFinite","stroke","beginPath","lineTo","moveTo","_hit_point","geometry","result","create_empty_hit_test_result","point","x","y","shortest","threshold","Math","max","line_width","value","end","length","p0","p1","dist","dist_to_segment","add_to_selected_glyphs","model","get_view","line_indices","_hit_span","val","values","direction","renderer","yscale","invert","_y","xscale","_x","push","get_interpolation_hit","x2","y2","x3","y3","draw_legend_for_index","bbox","index","__name__","Line","constructor","attrs","init_Line","prototype","default_view","mixins"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_line_legend, line_interpolation } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nexport class LineView extends XYGlyphView {\n    _render(ctx, indices, { sx, sy }) {\n        let drawing = false;\n        let last_index = null;\n        this.visuals.line.set_value(ctx);\n        for (const i of indices) {\n            if (drawing) {\n                if (!isFinite(sx[i] + sy[i])) {\n                    ctx.stroke();\n                    ctx.beginPath();\n                    drawing = false;\n                    last_index = i;\n                    continue;\n                }\n                if (last_index != null && i - last_index > 1) {\n                    ctx.stroke();\n                    drawing = false;\n                }\n            }\n            if (drawing)\n                ctx.lineTo(sx[i], sy[i]);\n            else {\n                ctx.beginPath();\n                ctx.moveTo(sx[i], sy[i]);\n                drawing = true;\n            }\n            last_index = i;\n        }\n        if (drawing)\n            ctx.stroke();\n    }\n    _hit_point(geometry) {\n        /* Check if the point geometry hits this line glyph and return an object\n        that describes the hit result:\n          Args:\n            * geometry (object): object with the following keys\n              * sx (float): screen x coordinate of the point\n              * sy (float): screen y coordinate of the point\n              * type (str): type of geometry (in this case it's a point)\n        */\n        const result = hittest.create_empty_hit_test_result();\n        const point = { x: geometry.sx, y: geometry.sy };\n        let shortest = 9999;\n        const threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n        for (let i = 0, end = this.sx.length - 1; i < end; i++) {\n            const p0 = { x: this.sx[i], y: this.sy[i] };\n            const p1 = { x: this.sx[i + 1], y: this.sy[i + 1] };\n            const dist = hittest.dist_to_segment(point, p0, p1);\n            if (dist < threshold && dist < shortest) {\n                shortest = dist;\n                result.add_to_selected_glyphs(this.model);\n                result.get_view = () => this;\n                result.line_indices = [i];\n            }\n        }\n        return result;\n    }\n    _hit_span(geometry) {\n        const { sx, sy } = geometry;\n        const result = hittest.create_empty_hit_test_result();\n        let val;\n        let values;\n        if (geometry.direction == 'v') {\n            val = this.renderer.yscale.invert(sy);\n            values = this._y;\n        }\n        else {\n            val = this.renderer.xscale.invert(sx);\n            values = this._x;\n        }\n        for (let i = 0, end = values.length - 1; i < end; i++) {\n            if ((values[i] <= val && val <= values[i + 1]) || (values[i + 1] <= val && val <= values[i])) {\n                result.add_to_selected_glyphs(this.model);\n                result.get_view = () => this;\n                result.line_indices.push(i);\n            }\n        }\n        return result;\n    }\n    get_interpolation_hit(i, geometry) {\n        const [x2, y2, x3, y3] = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]];\n        return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_line_legend(this.visuals, ctx, bbox, index);\n    }\n}\nLineView.__name__ = \"LineView\";\nexport class Line extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Line() {\n        this.prototype.default_view = LineView;\n        this.mixins(['line']);\n    }\n}\nLine.__name__ = \"Line\";\nLine.init_Line();\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}