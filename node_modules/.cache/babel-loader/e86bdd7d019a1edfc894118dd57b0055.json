{"ast":null,"code":"import { DataRenderer, DataRendererView } from \"./data_renderer\";\nimport { LineView } from \"../glyphs/line\";\nimport { PatchView } from \"../glyphs/patch\";\nimport { HAreaView } from \"../glyphs/harea\";\nimport { VAreaView } from \"../glyphs/varea\";\nimport { CDSView } from \"../sources/cds_view\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { indexOf, map, filter } from \"../../core/util/arrayable\";\nimport { difference, includes, range } from \"../../core/util/array\";\nimport { extend, clone } from \"../../core/util/object\";\nimport { build_view } from \"../../core/build_views\";\nimport { FactorRange } from '../ranges/factor_range';\nconst selection_defaults = {\n  fill: {},\n  line: {}\n};\nconst decimated_defaults = {\n  fill: {\n    fill_alpha: 0.3,\n    fill_color: \"grey\"\n  },\n  line: {\n    line_alpha: 0.3,\n    line_color: \"grey\"\n  }\n};\nconst nonselection_defaults = {\n  fill: {\n    fill_alpha: 0.2\n  },\n  line: {}\n};\nexport class GlyphRendererView extends DataRendererView {\n  async lazy_initialize() {\n    await super.lazy_initialize();\n    const base_glyph = this.model.glyph;\n    const has_fill = includes(base_glyph.mixins, \"fill\");\n    const has_line = includes(base_glyph.mixins, \"line\");\n    const glyph_attrs = clone(base_glyph.attributes);\n    delete glyph_attrs.id;\n\n    function mk_glyph(defaults) {\n      const attrs = clone(glyph_attrs);\n      if (has_fill) extend(attrs, defaults.fill);\n      if (has_line) extend(attrs, defaults.line);\n      return new base_glyph.constructor(attrs);\n    }\n\n    this.glyph = await this.build_glyph_view(base_glyph);\n    let {\n      selection_glyph\n    } = this.model;\n    if (selection_glyph == null) selection_glyph = mk_glyph({\n      fill: {},\n      line: {}\n    });else if (selection_glyph === \"auto\") selection_glyph = mk_glyph(selection_defaults);\n    this.selection_glyph = await this.build_glyph_view(selection_glyph);\n    let {\n      nonselection_glyph\n    } = this.model;\n    if (nonselection_glyph == null) nonselection_glyph = mk_glyph({\n      fill: {},\n      line: {}\n    });else if (nonselection_glyph === \"auto\") nonselection_glyph = mk_glyph(nonselection_defaults);\n    this.nonselection_glyph = await this.build_glyph_view(nonselection_glyph);\n    const {\n      hover_glyph\n    } = this.model;\n    if (hover_glyph != null) this.hover_glyph = await this.build_glyph_view(hover_glyph);\n    const {\n      muted_glyph\n    } = this.model;\n    if (muted_glyph != null) this.muted_glyph = await this.build_glyph_view(muted_glyph);\n    const decimated_glyph = mk_glyph(decimated_defaults);\n    this.decimated_glyph = await this.build_glyph_view(decimated_glyph);\n    this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n    this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n    this.set_data(false);\n  }\n\n  async build_glyph_view(glyph) {\n    return build_view(glyph, {\n      parent: this\n    });\n  }\n\n  remove() {\n    var _a, _b;\n\n    this.glyph.remove();\n    this.selection_glyph.remove();\n    this.nonselection_glyph.remove();\n    (_a = this.hover_glyph) === null || _a === void 0 ? void 0 : _a.remove();\n    (_b = this.muted_glyph) === null || _b === void 0 ? void 0 : _b.remove();\n    this.decimated_glyph.remove();\n    super.remove();\n  }\n\n  connect_signals() {\n    super.connect_signals();\n    this.connect(this.model.change, () => this.request_render());\n    this.connect(this.model.glyph.change, () => this.set_data());\n    this.connect(this.model.data_source.change, () => this.set_data());\n    this.connect(this.model.data_source.streaming, () => this.set_data());\n    this.connect(this.model.data_source.patching, (indices\n    /* XXX: WHY? */\n    ) => this.set_data(true, indices));\n    this.connect(this.model.data_source.selected.change, () => this.request_render());\n    this.connect(this.model.data_source._select, () => this.request_render());\n    if (this.hover_glyph != null) this.connect(this.model.data_source.inspect, () => this.request_render());\n    this.connect(this.model.properties.view.change, () => this.set_data());\n    this.connect(this.model.view.change, () => this.set_data());\n    this.connect(this.model.properties.visible.change, () => this.plot_view.update_dataranges());\n    const {\n      x_ranges,\n      y_ranges\n    } = this.plot_view.frame;\n\n    for (const name in x_ranges) {\n      const rng = x_ranges[name];\n      if (rng instanceof FactorRange) this.connect(rng.change, () => this.set_data());\n    }\n\n    for (const name in y_ranges) {\n      const rng = y_ranges[name];\n      if (rng instanceof FactorRange) this.connect(rng.change, () => this.set_data());\n    }\n\n    this.connect(this.model.glyph.transformchange, () => this.set_data());\n  }\n\n  have_selection_glyphs() {\n    return this.selection_glyph != null && this.nonselection_glyph != null;\n  } // in case of partial updates like patching, the list of indices that actually\n  // changed may be passed as the \"indices\" parameter to afford any optional optimizations\n\n\n  set_data(request_render = true, indices = null) {\n    const t0 = Date.now();\n    const source = this.model.data_source;\n    this.all_indices = this.model.view.indices; // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call\n    // mapping functions on the base Renderer class\n\n    this.glyph.model.setv({\n      x_range_name: this.model.x_range_name,\n      y_range_name: this.model.y_range_name\n    }, {\n      silent: true\n    });\n    this.glyph.set_data(source, this.all_indices, indices);\n    this.glyph.set_visuals(source);\n    this.decimated_glyph.set_visuals(source);\n\n    if (this.have_selection_glyphs()) {\n      this.selection_glyph.set_visuals(source);\n      this.nonselection_glyph.set_visuals(source);\n    }\n\n    if (this.hover_glyph != null) this.hover_glyph.set_visuals(source);\n    if (this.muted_glyph != null) this.muted_glyph.set_visuals(source);\n    const {\n      lod_factor\n    } = this.plot_model;\n    this.decimated = [];\n\n    for (let i = 0, end = Math.floor(this.all_indices.length / lod_factor); i < end; i++) {\n      this.decimated.push(i * lod_factor);\n    }\n\n    const dt = Date.now() - t0;\n    logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): set_data finished in ${dt}ms`);\n    this.set_data_timestamp = Date.now();\n    if (request_render) this.request_render();\n  }\n\n  get has_webgl() {\n    return this.glyph.has_webgl;\n  }\n\n  render() {\n    if (!this.model.visible) return;\n    const t0 = Date.now();\n    const glsupport = this.has_webgl;\n    this.glyph.map_data();\n    const dtmap = Date.now() - t0;\n    const tmask = Date.now(); // all_indices is in full data space, indices is converted to subset space\n    // either by mask_data (that uses the spatial index) or manually\n\n    let indices = this.glyph.mask_data(this.all_indices);\n\n    if (indices.length === this.all_indices.length) {\n      indices = range(0, this.all_indices.length);\n    }\n\n    const dtmask = Date.now() - tmask;\n    const {\n      ctx\n    } = this.plot_view.canvas_view;\n    ctx.save(); // selected is in full set space\n\n    const {\n      selected\n    } = this.model.data_source;\n    let selected_full_indices;\n    if (!selected || selected.is_empty()) selected_full_indices = [];else {\n      if (this.glyph instanceof LineView && selected.selected_glyph === this.glyph.model) selected_full_indices = this.model.view.convert_indices_from_subset(indices);else selected_full_indices = selected.indices;\n    } // inspected is in full set space\n\n    const {\n      inspected\n    } = this.model.data_source;\n    const inspected_full_indices = new Set((() => {\n      if (!inspected || inspected.is_empty()) return [];else {\n        if (inspected.selected_glyph) return this.model.view.convert_indices_from_subset(indices);else if (inspected.indices.length > 0) return inspected.indices;else return map(Object.keys(inspected.multiline_indices), i => parseInt(i));\n      }\n    })()); // inspected is transformed to subset space\n\n    const inspected_subset_indices = filter(indices, i => inspected_full_indices.has(this.all_indices[i]));\n    const {\n      lod_threshold\n    } = this.plot_model;\n    let glyph;\n    let nonselection_glyph;\n    let selection_glyph;\n\n    if ((this.model.document != null ? this.model.document.interactive_duration() > 0 : false) && !glsupport && lod_threshold != null && this.all_indices.length > lod_threshold) {\n      // Render decimated during interaction if too many elements and not using GL\n      indices = this.decimated;\n      glyph = this.decimated_glyph;\n      nonselection_glyph = this.decimated_glyph;\n      selection_glyph = this.selection_glyph;\n    } else {\n      glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;\n      nonselection_glyph = this.nonselection_glyph;\n      selection_glyph = this.selection_glyph;\n    }\n\n    if (this.hover_glyph != null && inspected_subset_indices.length) indices = difference(indices, inspected_subset_indices); // Render with no selection\n\n    let dtselect = null;\n    let trender;\n\n    if (!(selected_full_indices.length && this.have_selection_glyphs())) {\n      trender = Date.now();\n\n      if (this.glyph instanceof LineView) {\n        if (this.hover_glyph && inspected_subset_indices.length) this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);else glyph.render(ctx, this.all_indices, this.glyph);\n      } else if (this.glyph instanceof PatchView || this.glyph instanceof HAreaView || this.glyph instanceof VAreaView) {\n        if (inspected.selected_glyphs.length == 0 || this.hover_glyph == null) {\n          glyph.render(ctx, this.all_indices, this.glyph);\n        } else {\n          for (const sglyph of inspected.selected_glyphs) {\n            if (sglyph.id == this.glyph.model.id) this.hover_glyph.render(ctx, this.all_indices, this.glyph);\n          }\n        }\n      } else {\n        glyph.render(ctx, indices, this.glyph);\n        if (this.hover_glyph && inspected_subset_indices.length) this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n      } // Render with selection\n\n    } else {\n      // reset the selection mask\n      const tselect = Date.now();\n      const selected_mask = {};\n\n      for (const i of selected_full_indices) {\n        selected_mask[i] = true;\n      } // intersect/different selection with render mask\n\n\n      const selected_subset_indices = new Array();\n      const nonselected_subset_indices = new Array(); // now, selected is changed to subset space, except for Line glyph\n\n      if (this.glyph instanceof LineView) {\n        for (const i of this.all_indices) {\n          if (selected_mask[i] != null) selected_subset_indices.push(i);else nonselected_subset_indices.push(i);\n        }\n      } else {\n        for (const i of indices) {\n          if (selected_mask[this.all_indices[i]] != null) selected_subset_indices.push(i);else nonselected_subset_indices.push(i);\n        }\n      }\n\n      dtselect = Date.now() - tselect;\n      trender = Date.now();\n      nonselection_glyph.render(ctx, nonselected_subset_indices, this.glyph);\n      selection_glyph.render(ctx, selected_subset_indices, this.glyph);\n\n      if (this.hover_glyph != null) {\n        if (this.glyph instanceof LineView) this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);else this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n      }\n    }\n\n    const dtrender = Date.now() - trender;\n    this.last_dtrender = dtrender;\n    const dttot = Date.now() - t0;\n    logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): render finished in ${dttot}ms`);\n    logger.trace(` - map_data finished in       : ${dtmap}ms`);\n    logger.trace(` - mask_data finished in      : ${dtmask}ms`);\n\n    if (dtselect != null) {\n      logger.trace(` - selection mask finished in : ${dtselect}ms`);\n    }\n\n    logger.trace(` - glyph renders finished in  : ${dtrender}ms`);\n    ctx.restore();\n  }\n\n  draw_legend(ctx, x0, x1, y0, y1, field, label, index) {\n    if (index == null) index = this.model.get_reference_point(field, label);\n    this.glyph.draw_legend_for_index(ctx, {\n      x0,\n      x1,\n      y0,\n      y1\n    }, index);\n  }\n\n  hit_test(geometry) {\n    if (!this.model.visible) return null;\n    const hit_test_result = this.glyph.hit_test(geometry); // glyphs that don't have hit-testing implemented will return null\n\n    if (hit_test_result == null) return null;\n    return this.model.view.convert_selection_from_subset(hit_test_result);\n  }\n\n}\nGlyphRendererView.__name__ = \"GlyphRendererView\";\nexport class GlyphRenderer extends DataRenderer {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_GlyphRenderer() {\n    this.prototype.default_view = GlyphRendererView;\n    this.define({\n      data_source: [p.Instance],\n      view: [p.Instance, () => new CDSView()],\n      glyph: [p.Instance],\n      hover_glyph: [p.Instance],\n      nonselection_glyph: [p.Any, 'auto'],\n      selection_glyph: [p.Any, 'auto'],\n      muted_glyph: [p.Instance],\n      muted: [p.Boolean, false]\n    });\n  }\n\n  initialize() {\n    super.initialize();\n\n    if (this.view.source == null) {\n      this.view.source = this.data_source;\n      this.view.compute_indices();\n    }\n  }\n\n  get_reference_point(field, value) {\n    let index = 0;\n\n    if (field != null) {\n      const data = this.data_source.get_column(field);\n\n      if (data != null) {\n        const i = indexOf(data, value);\n        if (i != -1) index = i;\n      }\n    }\n\n    return index;\n  }\n\n  get_selection_manager() {\n    return this.data_source.selection_manager;\n  }\n\n}\nGlyphRenderer.__name__ = \"GlyphRenderer\";\nGlyphRenderer.init_GlyphRenderer();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/glyph_renderer.js"],"names":["DataRenderer","DataRendererView","LineView","PatchView","HAreaView","VAreaView","CDSView","logger","p","indexOf","map","filter","difference","includes","range","extend","clone","build_view","FactorRange","selection_defaults","fill","line","decimated_defaults","fill_alpha","fill_color","line_alpha","line_color","nonselection_defaults","GlyphRendererView","lazy_initialize","base_glyph","model","glyph","has_fill","mixins","has_line","glyph_attrs","attributes","id","mk_glyph","defaults","attrs","constructor","build_glyph_view","selection_glyph","nonselection_glyph","hover_glyph","muted_glyph","decimated_glyph","xscale","plot_view","frame","xscales","x_range_name","yscale","yscales","y_range_name","set_data","parent","remove","_a","_b","connect_signals","connect","change","request_render","data_source","streaming","patching","indices","selected","_select","inspect","properties","view","visible","update_dataranges","x_ranges","y_ranges","name","rng","transformchange","have_selection_glyphs","t0","Date","now","source","all_indices","setv","silent","set_visuals","lod_factor","plot_model","decimated","i","end","Math","floor","length","push","dt","debug","type","set_data_timestamp","has_webgl","render","glsupport","map_data","dtmap","tmask","mask_data","dtmask","ctx","canvas_view","save","selected_full_indices","is_empty","selected_glyph","convert_indices_from_subset","inspected","inspected_full_indices","Set","Object","keys","multiline_indices","parseInt","inspected_subset_indices","has","lod_threshold","document","interactive_duration","muted","dtselect","trender","selected_glyphs","sglyph","tselect","selected_mask","selected_subset_indices","Array","nonselected_subset_indices","dtrender","last_dtrender","dttot","trace","restore","draw_legend","x0","x1","y0","y1","field","label","index","get_reference_point","draw_legend_for_index","hit_test","geometry","hit_test_result","convert_selection_from_subset","__name__","GlyphRenderer","init_GlyphRenderer","prototype","default_view","define","Instance","Any","Boolean","initialize","compute_indices","value","data","get_column","get_selection_manager","selection_manager"],"mappings":"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","sourcesContent":["import { DataRenderer, DataRendererView } from \"./data_renderer\";\nimport { LineView } from \"../glyphs/line\";\nimport { PatchView } from \"../glyphs/patch\";\nimport { HAreaView } from \"../glyphs/harea\";\nimport { VAreaView } from \"../glyphs/varea\";\nimport { CDSView } from \"../sources/cds_view\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport { indexOf, map, filter } from \"../../core/util/arrayable\";\nimport { difference, includes, range } from \"../../core/util/array\";\nimport { extend, clone } from \"../../core/util/object\";\nimport { build_view } from \"../../core/build_views\";\nimport { FactorRange } from '../ranges/factor_range';\nconst selection_defaults = {\n    fill: {},\n    line: {},\n};\nconst decimated_defaults = {\n    fill: { fill_alpha: 0.3, fill_color: \"grey\" },\n    line: { line_alpha: 0.3, line_color: \"grey\" },\n};\nconst nonselection_defaults = {\n    fill: { fill_alpha: 0.2 },\n    line: {},\n};\nexport class GlyphRendererView extends DataRendererView {\n    async lazy_initialize() {\n        await super.lazy_initialize();\n        const base_glyph = this.model.glyph;\n        const has_fill = includes(base_glyph.mixins, \"fill\");\n        const has_line = includes(base_glyph.mixins, \"line\");\n        const glyph_attrs = clone(base_glyph.attributes);\n        delete glyph_attrs.id;\n        function mk_glyph(defaults) {\n            const attrs = clone(glyph_attrs);\n            if (has_fill)\n                extend(attrs, defaults.fill);\n            if (has_line)\n                extend(attrs, defaults.line);\n            return new base_glyph.constructor(attrs);\n        }\n        this.glyph = await this.build_glyph_view(base_glyph);\n        let { selection_glyph } = this.model;\n        if (selection_glyph == null)\n            selection_glyph = mk_glyph({ fill: {}, line: {} });\n        else if (selection_glyph === \"auto\")\n            selection_glyph = mk_glyph(selection_defaults);\n        this.selection_glyph = await this.build_glyph_view(selection_glyph);\n        let { nonselection_glyph } = this.model;\n        if ((nonselection_glyph == null))\n            nonselection_glyph = mk_glyph({ fill: {}, line: {} });\n        else if (nonselection_glyph === \"auto\")\n            nonselection_glyph = mk_glyph(nonselection_defaults);\n        this.nonselection_glyph = await this.build_glyph_view(nonselection_glyph);\n        const { hover_glyph } = this.model;\n        if (hover_glyph != null)\n            this.hover_glyph = await this.build_glyph_view(hover_glyph);\n        const { muted_glyph } = this.model;\n        if (muted_glyph != null)\n            this.muted_glyph = await this.build_glyph_view(muted_glyph);\n        const decimated_glyph = mk_glyph(decimated_defaults);\n        this.decimated_glyph = await this.build_glyph_view(decimated_glyph);\n        this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n        this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n        this.set_data(false);\n    }\n    async build_glyph_view(glyph) {\n        return build_view(glyph, { parent: this });\n    }\n    remove() {\n        var _a, _b;\n        this.glyph.remove();\n        this.selection_glyph.remove();\n        this.nonselection_glyph.remove();\n        (_a = this.hover_glyph) === null || _a === void 0 ? void 0 : _a.remove();\n        (_b = this.muted_glyph) === null || _b === void 0 ? void 0 : _b.remove();\n        this.decimated_glyph.remove();\n        super.remove();\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.change, () => this.request_render());\n        this.connect(this.model.glyph.change, () => this.set_data());\n        this.connect(this.model.data_source.change, () => this.set_data());\n        this.connect(this.model.data_source.streaming, () => this.set_data());\n        this.connect(this.model.data_source.patching, (indices /* XXX: WHY? */) => this.set_data(true, indices));\n        this.connect(this.model.data_source.selected.change, () => this.request_render());\n        this.connect(this.model.data_source._select, () => this.request_render());\n        if (this.hover_glyph != null)\n            this.connect(this.model.data_source.inspect, () => this.request_render());\n        this.connect(this.model.properties.view.change, () => this.set_data());\n        this.connect(this.model.view.change, () => this.set_data());\n        this.connect(this.model.properties.visible.change, () => this.plot_view.update_dataranges());\n        const { x_ranges, y_ranges } = this.plot_view.frame;\n        for (const name in x_ranges) {\n            const rng = x_ranges[name];\n            if (rng instanceof FactorRange)\n                this.connect(rng.change, () => this.set_data());\n        }\n        for (const name in y_ranges) {\n            const rng = y_ranges[name];\n            if (rng instanceof FactorRange)\n                this.connect(rng.change, () => this.set_data());\n        }\n        this.connect(this.model.glyph.transformchange, () => this.set_data());\n    }\n    have_selection_glyphs() {\n        return this.selection_glyph != null && this.nonselection_glyph != null;\n    }\n    // in case of partial updates like patching, the list of indices that actually\n    // changed may be passed as the \"indices\" parameter to afford any optional optimizations\n    set_data(request_render = true, indices = null) {\n        const t0 = Date.now();\n        const source = this.model.data_source;\n        this.all_indices = this.model.view.indices;\n        // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call\n        // mapping functions on the base Renderer class\n        this.glyph.model.setv({ x_range_name: this.model.x_range_name,\n            y_range_name: this.model.y_range_name }, { silent: true });\n        this.glyph.set_data(source, this.all_indices, indices);\n        this.glyph.set_visuals(source);\n        this.decimated_glyph.set_visuals(source);\n        if (this.have_selection_glyphs()) {\n            this.selection_glyph.set_visuals(source);\n            this.nonselection_glyph.set_visuals(source);\n        }\n        if (this.hover_glyph != null)\n            this.hover_glyph.set_visuals(source);\n        if (this.muted_glyph != null)\n            this.muted_glyph.set_visuals(source);\n        const { lod_factor } = this.plot_model;\n        this.decimated = [];\n        for (let i = 0, end = Math.floor(this.all_indices.length / lod_factor); i < end; i++) {\n            this.decimated.push(i * lod_factor);\n        }\n        const dt = Date.now() - t0;\n        logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): set_data finished in ${dt}ms`);\n        this.set_data_timestamp = Date.now();\n        if (request_render)\n            this.request_render();\n    }\n    get has_webgl() {\n        return this.glyph.has_webgl;\n    }\n    render() {\n        if (!this.model.visible)\n            return;\n        const t0 = Date.now();\n        const glsupport = this.has_webgl;\n        this.glyph.map_data();\n        const dtmap = Date.now() - t0;\n        const tmask = Date.now();\n        // all_indices is in full data space, indices is converted to subset space\n        // either by mask_data (that uses the spatial index) or manually\n        let indices = this.glyph.mask_data(this.all_indices);\n        if (indices.length === this.all_indices.length) {\n            indices = range(0, this.all_indices.length);\n        }\n        const dtmask = Date.now() - tmask;\n        const { ctx } = this.plot_view.canvas_view;\n        ctx.save();\n        // selected is in full set space\n        const { selected } = this.model.data_source;\n        let selected_full_indices;\n        if (!selected || selected.is_empty())\n            selected_full_indices = [];\n        else {\n            if (this.glyph instanceof LineView && selected.selected_glyph === this.glyph.model)\n                selected_full_indices = this.model.view.convert_indices_from_subset(indices);\n            else\n                selected_full_indices = selected.indices;\n        }\n        // inspected is in full set space\n        const { inspected } = this.model.data_source;\n        const inspected_full_indices = new Set((() => {\n            if (!inspected || inspected.is_empty())\n                return [];\n            else {\n                if (inspected.selected_glyph)\n                    return this.model.view.convert_indices_from_subset(indices);\n                else if (inspected.indices.length > 0)\n                    return inspected.indices;\n                else\n                    return map(Object.keys(inspected.multiline_indices), (i) => parseInt(i));\n            }\n        })());\n        // inspected is transformed to subset space\n        const inspected_subset_indices = filter(indices, (i) => inspected_full_indices.has(this.all_indices[i]));\n        const { lod_threshold } = this.plot_model;\n        let glyph;\n        let nonselection_glyph;\n        let selection_glyph;\n        if ((this.model.document != null ? this.model.document.interactive_duration() > 0 : false)\n            && !glsupport && lod_threshold != null && this.all_indices.length > lod_threshold) {\n            // Render decimated during interaction if too many elements and not using GL\n            indices = this.decimated;\n            glyph = this.decimated_glyph;\n            nonselection_glyph = this.decimated_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        else {\n            glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;\n            nonselection_glyph = this.nonselection_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        if (this.hover_glyph != null && inspected_subset_indices.length)\n            indices = difference(indices, inspected_subset_indices);\n        // Render with no selection\n        let dtselect = null;\n        let trender;\n        if (!(selected_full_indices.length && this.have_selection_glyphs())) {\n            trender = Date.now();\n            if (this.glyph instanceof LineView) {\n                if (this.hover_glyph && inspected_subset_indices.length)\n                    this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\n                else\n                    glyph.render(ctx, this.all_indices, this.glyph);\n            }\n            else if (this.glyph instanceof PatchView || this.glyph instanceof HAreaView || this.glyph instanceof VAreaView) {\n                if (inspected.selected_glyphs.length == 0 || this.hover_glyph == null) {\n                    glyph.render(ctx, this.all_indices, this.glyph);\n                }\n                else {\n                    for (const sglyph of inspected.selected_glyphs) {\n                        if (sglyph.id == this.glyph.model.id)\n                            this.hover_glyph.render(ctx, this.all_indices, this.glyph);\n                    }\n                }\n            }\n            else {\n                glyph.render(ctx, indices, this.glyph);\n                if (this.hover_glyph && inspected_subset_indices.length)\n                    this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n            }\n            // Render with selection\n        }\n        else {\n            // reset the selection mask\n            const tselect = Date.now();\n            const selected_mask = {};\n            for (const i of selected_full_indices) {\n                selected_mask[i] = true;\n            }\n            // intersect/different selection with render mask\n            const selected_subset_indices = new Array();\n            const nonselected_subset_indices = new Array();\n            // now, selected is changed to subset space, except for Line glyph\n            if (this.glyph instanceof LineView) {\n                for (const i of this.all_indices) {\n                    if (selected_mask[i] != null)\n                        selected_subset_indices.push(i);\n                    else\n                        nonselected_subset_indices.push(i);\n                }\n            }\n            else {\n                for (const i of indices) {\n                    if (selected_mask[this.all_indices[i]] != null)\n                        selected_subset_indices.push(i);\n                    else\n                        nonselected_subset_indices.push(i);\n                }\n            }\n            dtselect = Date.now() - tselect;\n            trender = Date.now();\n            nonselection_glyph.render(ctx, nonselected_subset_indices, this.glyph);\n            selection_glyph.render(ctx, selected_subset_indices, this.glyph);\n            if (this.hover_glyph != null) {\n                if (this.glyph instanceof LineView)\n                    this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\n                else\n                    this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n            }\n        }\n        const dtrender = Date.now() - trender;\n        this.last_dtrender = dtrender;\n        const dttot = Date.now() - t0;\n        logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): render finished in ${dttot}ms`);\n        logger.trace(` - map_data finished in       : ${dtmap}ms`);\n        logger.trace(` - mask_data finished in      : ${dtmask}ms`);\n        if (dtselect != null) {\n            logger.trace(` - selection mask finished in : ${dtselect}ms`);\n        }\n        logger.trace(` - glyph renders finished in  : ${dtrender}ms`);\n        ctx.restore();\n    }\n    draw_legend(ctx, x0, x1, y0, y1, field, label, index) {\n        if (index == null)\n            index = this.model.get_reference_point(field, label);\n        this.glyph.draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index);\n    }\n    hit_test(geometry) {\n        if (!this.model.visible)\n            return null;\n        const hit_test_result = this.glyph.hit_test(geometry);\n        // glyphs that don't have hit-testing implemented will return null\n        if (hit_test_result == null)\n            return null;\n        return this.model.view.convert_selection_from_subset(hit_test_result);\n    }\n}\nGlyphRendererView.__name__ = \"GlyphRendererView\";\nexport class GlyphRenderer extends DataRenderer {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_GlyphRenderer() {\n        this.prototype.default_view = GlyphRendererView;\n        this.define({\n            data_source: [p.Instance],\n            view: [p.Instance, () => new CDSView()],\n            glyph: [p.Instance],\n            hover_glyph: [p.Instance],\n            nonselection_glyph: [p.Any, 'auto'],\n            selection_glyph: [p.Any, 'auto'],\n            muted_glyph: [p.Instance],\n            muted: [p.Boolean, false],\n        });\n    }\n    initialize() {\n        super.initialize();\n        if (this.view.source == null) {\n            this.view.source = this.data_source;\n            this.view.compute_indices();\n        }\n    }\n    get_reference_point(field, value) {\n        let index = 0;\n        if (field != null) {\n            const data = this.data_source.get_column(field);\n            if (data != null) {\n                const i = indexOf(data, value);\n                if (i != -1)\n                    index = i;\n            }\n        }\n        return index;\n    }\n    get_selection_manager() {\n        return this.data_source.selection_manager;\n    }\n}\nGlyphRenderer.__name__ = \"GlyphRenderer\";\nGlyphRenderer.init_GlyphRenderer();\n//# sourceMappingURL=glyph_renderer.js.map"]},"metadata":{},"sourceType":"module"}