{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { map } from \"../../core/util/arrayable\";\nexport class CircleView extends XYGlyphView {\n  _map_data() {\n    // XXX: Order is important here: size is always present (at least\n    // a default), but radius is only present if a user specifies it.\n    if (this._radius != null) {\n      if (this.model.properties.radius.spec.units == \"data\") {\n        const rd = this.model.properties.radius_dimension.spec.value;\n\n        switch (rd) {\n          case \"x\":\n            {\n              this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n              break;\n            }\n\n          case \"y\":\n            {\n              this.sradius = this.sdist(this.renderer.yscale, this._y, this._radius);\n              break;\n            }\n\n          case \"max\":\n            {\n              const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n              const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n              this.sradius = map(sradius_x, (s, i) => Math.max(s, sradius_y[i]));\n              break;\n            }\n\n          case \"min\":\n            {\n              const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n              const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n              this.sradius = map(sradius_x, (s, i) => Math.min(s, sradius_y[i]));\n              break;\n            }\n        }\n      } else {\n        this.sradius = this._radius;\n        this.max_size = 2 * this.max_radius;\n      }\n    } else this.sradius = map(this._size, s => s / 2);\n  }\n\n  _mask_data() {\n    const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n    let x0, y0;\n    let x1, y1;\n\n    if (this._radius != null && this.model.properties.radius.units == \"data\") {\n      const sx0 = hr.start;\n      const sx1 = hr.end;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      x0 -= this.max_radius;\n      x1 += this.max_radius;\n      const sy0 = vr.start;\n      const sy1 = vr.end;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n      y0 -= this.max_radius;\n      y1 += this.max_radius;\n    } else {\n      const sx0 = hr.start - this.max_size;\n      const sx1 = hr.end + this.max_size;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      const sy0 = vr.start - this.max_size;\n      const sy1 = vr.end + this.max_size;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    return this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    sradius\n  }) {\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + sradius[i])) continue;\n      ctx.beginPath();\n      ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n        ctx.fill();\n      }\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy);\n    let x0, x1, y0, y1;\n\n    if (this._radius != null && this.model.properties.radius.units == \"data\") {\n      x0 = x - this.max_radius;\n      x1 = x + this.max_radius;\n      y0 = y - this.max_radius;\n      y1 = y + this.max_radius;\n    } else {\n      const sx0 = sx - this.max_size;\n      const sx1 = sx + this.max_size;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      const sy0 = sy - this.max_size;\n      const sy1 = sy + this.max_size;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    const candidates = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    const hits = [];\n\n    if (this._radius != null && this.model.properties.radius.units == \"data\") {\n      for (const i of candidates) {\n        const r2 = this.sradius[i] ** 2;\n        const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n        const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n        const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n\n        if (dist <= r2) {\n          hits.push([i, dist]);\n        }\n      }\n    } else {\n      for (const i of candidates) {\n        const r2 = this.sradius[i] ** 2;\n        const dist = (this.sx[i] - sx) ** 2 + (this.sy[i] - sy) ** 2;\n\n        if (dist <= r2) {\n          hits.push([i, dist]);\n        }\n      }\n    }\n\n    return hittest.create_hit_test_result_from_hits(hits);\n  }\n\n  _hit_span(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const bounds = this.bounds();\n    const result = hittest.create_empty_hit_test_result();\n    let x0, x1, y0, y1;\n\n    if (geometry.direction == 'h') {\n      // use circle bounds instead of current pointer y coordinates\n      let sx0, sx1;\n      y0 = bounds.y0;\n      y1 = bounds.y1;\n\n      if (this._radius != null && this.model.properties.radius.units == \"data\") {\n        sx0 = sx - this.max_radius;\n        sx1 = sx + this.max_radius;\n        [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      } else {\n        const ms = this.max_size / 2;\n        sx0 = sx - ms;\n        sx1 = sx + ms;\n        [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      }\n    } else {\n      // use circle bounds instead of current pointer x coordinates\n      let sy0, sy1;\n      x0 = bounds.x0;\n      x1 = bounds.x1;\n\n      if (this._radius != null && this.model.properties.radius.units == \"data\") {\n        sy0 = sy - this.max_radius;\n        sy1 = sy + this.max_radius;\n        [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n      } else {\n        const ms = this.max_size / 2;\n        sy0 = sy - ms;\n        sy1 = sy + ms;\n        [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n      }\n    }\n\n    const hits = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    result.indices = hits;\n    return result;\n  }\n\n  _hit_rect(geometry) {\n    const {\n      sx0,\n      sx1,\n      sy0,\n      sy1\n    } = geometry;\n    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    });\n    return result;\n  }\n\n  _hit_poly(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry; // TODO (bev) use spatial index to pare candidate list\n\n    const candidates = range(0, this.sx.length);\n    const hits = [];\n\n    for (let i = 0, end = candidates.length; i < end; i++) {\n      const idx = candidates[i];\n\n      if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n        hits.push(idx);\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  } // circle does not inherit from marker (since it also accepts radius) so we\n  // must supply a draw_legend for it  here\n\n\n  draw_legend_for_index(ctx, {\n    x0,\n    y0,\n    x1,\n    y1\n  }, index) {\n    // using objects like this seems a little wonky, since the keys are coerced to\n    // stings, but it works\n    const len = index + 1;\n    const sx = new Array(len);\n    sx[index] = (x0 + x1) / 2;\n    const sy = new Array(len);\n    sy[index] = (y0 + y1) / 2;\n    const sradius = new Array(len);\n    sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\n\n    this._render(ctx, [index], {\n      sx,\n      sy,\n      sradius\n    }); // XXX\n\n  }\n\n}\nCircleView.__name__ = \"CircleView\";\nexport class Circle extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Circle() {\n    this.prototype.default_view = CircleView;\n    this.mixins(['line', 'fill']);\n    this.define({\n      angle: [p.AngleSpec, 0],\n      size: [p.DistanceSpec, {\n        units: \"screen\",\n        value: 4\n      }],\n      radius: [p.DistanceSpec],\n      radius_dimension: [p.RadiusDimension, 'x']\n    });\n  }\n\n  initialize() {\n    super.initialize();\n    this.properties.radius.optional = true;\n  }\n\n}\nCircle.__name__ = \"Circle\";\nCircle.init_Circle();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/circle.js"],"names":["XYGlyph","XYGlyphView","hittest","p","range","map","CircleView","_map_data","_radius","model","properties","radius","spec","units","rd","radius_dimension","value","sradius","sdist","renderer","xscale","_x","yscale","_y","sradius_x","sradius_y","s","i","Math","max","min","max_size","max_radius","_size","_mask_data","hr","vr","plot_view","frame","bbox","ranges","x0","y0","x1","y1","sx0","start","sx1","end","r_invert","sy0","sy1","index","indices","_render","ctx","sx","sy","isNaN","beginPath","arc","PI","visuals","fill","doit","set_vectorize","line","stroke","_hit_point","geometry","x","invert","y","candidates","hits","r2","r_compute","dist","push","create_hit_test_result_from_hits","_hit_span","bounds","result","create_empty_hit_test_result","direction","ms","_hit_rect","_hit_poly","length","idx","point_in_poly","draw_legend_for_index","len","Array","abs","__name__","Circle","constructor","attrs","init_Circle","prototype","default_view","mixins","define","angle","AngleSpec","size","DistanceSpec","RadiusDimension","initialize","optional"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { map } from \"../../core/util/arrayable\";\nexport class CircleView extends XYGlyphView {\n    _map_data() {\n        // XXX: Order is important here: size is always present (at least\n        // a default), but radius is only present if a user specifies it.\n        if (this._radius != null) {\n            if (this.model.properties.radius.spec.units == \"data\") {\n                const rd = this.model.properties.radius_dimension.spec.value;\n                switch (rd) {\n                    case \"x\": {\n                        this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n                        break;\n                    }\n                    case \"y\": {\n                        this.sradius = this.sdist(this.renderer.yscale, this._y, this._radius);\n                        break;\n                    }\n                    case \"max\": {\n                        const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n                        const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n                        this.sradius = map(sradius_x, (s, i) => Math.max(s, sradius_y[i]));\n                        break;\n                    }\n                    case \"min\": {\n                        const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n                        const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n                        this.sradius = map(sradius_x, (s, i) => Math.min(s, sradius_y[i]));\n                        break;\n                    }\n                }\n            }\n            else {\n                this.sradius = this._radius;\n                this.max_size = 2 * this.max_radius;\n            }\n        }\n        else\n            this.sradius = map(this._size, (s) => s / 2);\n    }\n    _mask_data() {\n        const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n        let x0, y0;\n        let x1, y1;\n        if (this._radius != null && this.model.properties.radius.units == \"data\") {\n            const sx0 = hr.start;\n            const sx1 = hr.end;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            x0 -= this.max_radius;\n            x1 += this.max_radius;\n            const sy0 = vr.start;\n            const sy1 = vr.end;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            y0 -= this.max_radius;\n            y1 += this.max_radius;\n        }\n        else {\n            const sx0 = hr.start - this.max_size;\n            const sx1 = hr.end + this.max_size;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const sy0 = vr.start - this.max_size;\n            const sy1 = vr.end + this.max_size;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        return this.index.indices({ x0, x1, y0, y1 });\n    }\n    _render(ctx, indices, { sx, sy, sradius }) {\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + sradius[i]))\n                continue;\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        let x0, x1, y0, y1;\n        if (this._radius != null && this.model.properties.radius.units == \"data\") {\n            x0 = x - this.max_radius;\n            x1 = x + this.max_radius;\n            y0 = y - this.max_radius;\n            y1 = y + this.max_radius;\n        }\n        else {\n            const sx0 = sx - this.max_size;\n            const sx1 = sx + this.max_size;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const sy0 = sy - this.max_size;\n            const sy1 = sy + this.max_size;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        const candidates = this.index.indices({ x0, x1, y0, y1 });\n        const hits = [];\n        if (this._radius != null && this.model.properties.radius.units == \"data\") {\n            for (const i of candidates) {\n                const r2 = this.sradius[i] ** 2;\n                const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        else {\n            for (const i of candidates) {\n                const r2 = this.sradius[i] ** 2;\n                const dist = (this.sx[i] - sx) ** 2 + (this.sy[i] - sy) ** 2;\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        return hittest.create_hit_test_result_from_hits(hits);\n    }\n    _hit_span(geometry) {\n        const { sx, sy } = geometry;\n        const bounds = this.bounds();\n        const result = hittest.create_empty_hit_test_result();\n        let x0, x1, y0, y1;\n        if (geometry.direction == 'h') {\n            // use circle bounds instead of current pointer y coordinates\n            let sx0, sx1;\n            y0 = bounds.y0;\n            y1 = bounds.y1;\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\n                sx0 = sx - this.max_radius;\n                sx1 = sx + this.max_radius;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            }\n            else {\n                const ms = this.max_size / 2;\n                sx0 = sx - ms;\n                sx1 = sx + ms;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            }\n        }\n        else {\n            // use circle bounds instead of current pointer x coordinates\n            let sy0, sy1;\n            x0 = bounds.x0;\n            x1 = bounds.x1;\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\n                sy0 = sy - this.max_radius;\n                sy1 = sy + this.max_radius;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            else {\n                const ms = this.max_size / 2;\n                sy0 = sy - ms;\n                sy1 = sy + ms;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n        }\n        const hits = this.index.indices({ x0, x1, y0, y1 });\n        result.indices = hits;\n        return result;\n    }\n    _hit_rect(geometry) {\n        const { sx0, sx1, sy0, sy1 } = geometry;\n        const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n        const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = this.index.indices({ x0, x1, y0, y1 });\n        return result;\n    }\n    _hit_poly(geometry) {\n        const { sx, sy } = geometry;\n        // TODO (bev) use spatial index to pare candidate list\n        const candidates = range(0, this.sx.length);\n        const hits = [];\n        for (let i = 0, end = candidates.length; i < end; i++) {\n            const idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                hits.push(idx);\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    // circle does not inherit from marker (since it also accepts radius) so we\n    // must supply a draw_legend for it  here\n    draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\n        // using objects like this seems a little wonky, since the keys are coerced to\n        // stings, but it works\n        const len = index + 1;\n        const sx = new Array(len);\n        sx[index] = (x0 + x1) / 2;\n        const sy = new Array(len);\n        sy[index] = (y0 + y1) / 2;\n        const sradius = new Array(len);\n        sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\n        this._render(ctx, [index], { sx, sy, sradius }); // XXX\n    }\n}\nCircleView.__name__ = \"CircleView\";\nexport class Circle extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Circle() {\n        this.prototype.default_view = CircleView;\n        this.mixins(['line', 'fill']);\n        this.define({\n            angle: [p.AngleSpec, 0],\n            size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\n            radius: [p.DistanceSpec],\n            radius_dimension: [p.RadiusDimension, 'x'],\n        });\n    }\n    initialize() {\n        super.initialize();\n        this.properties.radius.optional = true;\n    }\n}\nCircle.__name__ = \"Circle\";\nCircle.init_Circle();\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}