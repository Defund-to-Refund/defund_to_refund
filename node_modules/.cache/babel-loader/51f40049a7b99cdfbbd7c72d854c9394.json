{"ast":null,"code":"import { Signal0, Signal, Signalable } from \"./signaling\";\nimport * as property_mixins from \"./property_mixins\";\nimport { is_ref } from \"./util/refs\";\nimport * as p from \"./properties\";\nimport { uniqueId } from \"./util/string\";\nimport { max, copy } from \"./util/array\";\nimport { values, clone, isEmpty } from \"./util/object\";\nimport { isPlainObject, isObject, isArray, isFunction } from \"./util/types\";\nimport { isEqual } from './util/eq';\nexport class HasProps extends Signalable() {\n  constructor(attrs = {}) {\n    super();\n    this._subtype = undefined;\n    this.document = null;\n    this.destroyed = new Signal0(this, \"destroyed\");\n    this.change = new Signal0(this, \"change\");\n    this.transformchange = new Signal0(this, \"transformchange\");\n    this.attributes = {};\n    this.properties = {};\n    this._set_after_defaults = {};\n    this._pending = false;\n    this._changing = false;\n\n    for (const name in this.props) {\n      const {\n        type,\n        default_value\n      } = this.props[name];\n      if (type != null) this.properties[name] = new type(this, name, default_value);else throw new Error(`undefined property type for ${this.type}.${name}`);\n    } // auto generating ID\n\n\n    if (attrs.id == null) this.setv({\n      id: uniqueId()\n    }, {\n      silent: true\n    });\n    const deferred = attrs.__deferred__ || false;\n\n    if (deferred) {\n      attrs = clone(attrs);\n      delete attrs.__deferred__;\n    }\n\n    this.setv(attrs, {\n      silent: true\n    }); // allowing us to defer initialization when loading many models\n    // when loading a bunch of models, we want to do initialization as a second pass\n    // because other objects that this one depends on might not be loaded yet\n\n    if (!deferred) this.finalize();\n  } // XXX: setter is only required for backwards compatibility\n\n\n  set type(name) {\n    console.warn(\"prototype.type = 'ModelName' is deprecated, use static __name__ instead\");\n    this.constructor.__name__ = name;\n  }\n\n  get type() {\n    return this.constructor.__qualified__;\n  }\n\n  static get __qualified__() {\n    const {\n      __module__,\n      __name__\n    } = this;\n    return __module__ != null ? `${__module__}.${__name__}` : __name__;\n  }\n\n  static init_HasProps() {\n    this.prototype.props = {};\n    this.prototype.mixins = [];\n    this.define({\n      id: [p.Any]\n    });\n  } // }}}\n\n\n  static _fix_default(default_value, _attr) {\n    if (default_value === undefined) return undefined;else if (isFunction(default_value)) return default_value;else if (!isObject(default_value)) return () => default_value;else {\n      //logger.warn(`${this.prototype.type}.${attr} uses unwrapped non-primitive default value`)\n      if (isArray(default_value)) return () => copy(default_value);else return () => clone(default_value);\n    }\n  } // TODO: don't use Partial<>, but exclude inherited properties\n\n\n  static define(obj) {\n    for (const name in obj) {\n      const prop = obj[name];\n      if (this.prototype.props[name] != null) throw new Error(`attempted to redefine property '${this.prototype.type}.${name}'`);\n      if (this.prototype[name] != null) throw new Error(`attempted to redefine attribute '${this.prototype.type}.${name}'`);\n      Object.defineProperty(this.prototype, name, {\n        // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306\n        get() {\n          const value = this.getv(name);\n          return value;\n        },\n\n        set(value) {\n          this.setv({\n            [name]: value\n          });\n          return this;\n        },\n\n        configurable: false,\n        enumerable: true\n      });\n      const [type, default_value, internal] = prop;\n      const refined_prop = {\n        type,\n        default_value: this._fix_default(default_value, name),\n        internal: internal || false\n      };\n      const props = clone(this.prototype.props);\n      props[name] = refined_prop;\n      this.prototype.props = props;\n    }\n  }\n\n  static internal(obj) {\n    const _object = {};\n\n    for (const name in obj) {\n      const prop = obj[name];\n      const [type, default_value] = prop;\n      _object[name] = [type, default_value, true];\n    }\n\n    this.define(_object);\n  }\n\n  static mixin(...names) {\n    this.define(property_mixins.create(names));\n    const mixins = this.prototype.mixins.concat(names);\n    this.prototype.mixins = mixins;\n  }\n\n  static mixins(names) {\n    this.mixin(...names);\n  }\n\n  static override(obj) {\n    for (const name in obj) {\n      const default_value = this._fix_default(obj[name], name);\n\n      const value = this.prototype.props[name];\n      if (value == null) throw new Error(`attempted to override nonexistent '${this.prototype.type}.${name}'`);\n      const props = clone(this.prototype.props);\n      props[name] = Object.assign(Object.assign({}, value), {\n        default_value\n      });\n      this.prototype.props = props;\n    }\n  }\n\n  toString() {\n    return `${this.type}(${this.id})`;\n  }\n\n  finalize() {\n    // This is necessary because the initial creation of properties relies on\n    // model.get which is not usable at that point yet in the constructor. This\n    // initializer is called when deferred initialization happens for all models\n    // and insures that the Bokeh properties are initialized from Backbone\n    // attributes in a consistent way.\n    //\n    // TODO (bev) split property creation up into two parts so that only the\n    // portion of init that can be done happens in HasProps constructor and so\n    // that subsequent updates do not duplicate that setup work.\n    for (const name in this.properties) {\n      const prop = this.properties[name];\n      prop.update();\n      if (prop.spec.transform != null) this.connect(prop.spec.transform.change, () => this.transformchange.emit());\n    }\n\n    this.initialize();\n    this.connect_signals();\n  }\n\n  initialize() {}\n\n  connect_signals() {}\n\n  disconnect_signals() {\n    Signal.disconnectReceiver(this);\n  }\n\n  destroy() {\n    this.disconnect_signals();\n    this.destroyed.emit();\n  } // Create a new model with identical attributes to this one.\n\n\n  clone() {\n    return new this.constructor(this.attributes);\n  } // Set a hash of model attributes on the object, firing `\"change\"`. This is\n  // the core primitive operation of a model, updating the data and notifying\n  // anyone who needs to know about the change in state. The heart of the beast.\n\n\n  _setv(attrs, options) {\n    // Extract attributes and options.\n    const check_eq = options.check_eq;\n    const silent = options.silent;\n    const changes = [];\n    const changing = this._changing;\n    this._changing = true;\n    const current = this.attributes; // For each `set` attribute, update or delete the current value.\n\n    for (const attr in attrs) {\n      const val = attrs[attr];\n\n      if (check_eq !== false) {\n        if (!isEqual(current[attr], val)) changes.push(attr);\n      } else changes.push(attr);\n\n      current[attr] = val;\n    } // Trigger all relevant attribute changes.\n\n\n    if (!silent) {\n      if (changes.length > 0) this._pending = true;\n\n      for (let i = 0; i < changes.length; i++) this.properties[changes[i]].change.emit();\n    } // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n\n\n    if (changing) return;\n\n    if (!silent && !options.no_change) {\n      while (this._pending) {\n        this._pending = false;\n        this.change.emit();\n      }\n    }\n\n    this._pending = false;\n    this._changing = false;\n  }\n\n  setv(attrs, options = {}) {\n    for (const key in attrs) {\n      if (!attrs.hasOwnProperty(key)) continue;\n      const prop_name = key;\n      if (this.props[prop_name] == null) throw new Error(`property ${this.type}.${prop_name} wasn't declared`);\n      if (!(options != null && options.defaults)) this._set_after_defaults[key] = true;\n    }\n\n    if (!isEmpty(attrs)) {\n      const old = {};\n\n      for (const key in attrs) old[key] = this.getv(key);\n\n      this._setv(attrs, options);\n\n      const silent = options.silent;\n\n      if (silent == null || !silent) {\n        for (const key in attrs) this._tell_document_about_change(key, old[key], this.getv(key), options);\n      }\n    }\n  }\n\n  getv(prop_name) {\n    if (this.props[prop_name] == null) throw new Error(`property ${this.type}.${prop_name} wasn't declared`);else return this.attributes[prop_name];\n  }\n\n  ref() {\n    return {\n      id: this.id\n    };\n  }\n\n  struct() {\n    const struct = {\n      type: this.type,\n      id: this.id,\n      attributes: {}\n    };\n\n    if (this._subtype != null) {\n      struct.subtype = this._subtype;\n    }\n\n    return struct;\n  } // we only keep the subtype so we match Python;\n  // only Python cares about this\n\n\n  set_subtype(subtype) {\n    this._subtype = subtype;\n  }\n\n  attribute_is_serializable(attr) {\n    const prop = this.props[attr];\n    if (prop == null) throw new Error(`${this.type}.attribute_is_serializable('${attr}'): ${attr} wasn't declared`);else return !prop.internal;\n  } // dict of attributes that should be serialized to the server. We\n  // sometimes stick things in attributes that aren't part of the\n  // Document's models, subtypes that do that have to remove their\n  // extra attributes here.\n\n\n  serializable_attributes() {\n    const attrs = {};\n\n    for (const name in this.attributes) {\n      const value = this.attributes[name];\n      if (this.attribute_is_serializable(name)) attrs[name] = value;\n    }\n\n    return attrs;\n  }\n\n  static _value_to_json(_key, value, _optional_parent_object) {\n    if (value instanceof HasProps) return value.ref();else if (isArray(value)) {\n      const ref_array = [];\n\n      for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        ref_array.push(HasProps._value_to_json(i.toString(), v, value));\n      }\n\n      return ref_array;\n    } else if (isPlainObject(value)) {\n      const ref_obj = {};\n\n      for (const subkey in value) {\n        if (value.hasOwnProperty(subkey)) ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);\n      }\n\n      return ref_obj;\n    } else return value;\n  } // Convert attributes to \"shallow\" JSON (values which are themselves models\n  // are included as just references)\n\n\n  attributes_as_json(include_defaults = true, value_to_json = HasProps._value_to_json) {\n    const serializable = this.serializable_attributes();\n    const attrs = {};\n\n    for (const key in serializable) {\n      if (serializable.hasOwnProperty(key)) {\n        const value = serializable[key];\n        if (include_defaults) attrs[key] = value;else if (key in this._set_after_defaults) attrs[key] = value;\n      }\n    }\n\n    return value_to_json(\"attributes\", attrs, this);\n  } // this is like _value_record_references but expects to find refs\n  // instead of models, and takes a doc to look up the refs in\n\n\n  static _json_record_references(doc, v, result, recurse) {\n    if (v == null) {} else if (is_ref(v)) {\n      if (!(v.id in result)) {\n        const model = doc.get_model_by_id(v.id);\n\n        HasProps._value_record_references(model, result, recurse);\n      }\n    } else if (isArray(v)) {\n      for (const elem of v) HasProps._json_record_references(doc, elem, result, recurse);\n    } else if (isPlainObject(v)) {\n      for (const k in v) {\n        if (v.hasOwnProperty(k)) {\n          const elem = v[k];\n\n          HasProps._json_record_references(doc, elem, result, recurse);\n        }\n      }\n    }\n  } // add all references from 'v' to 'result', if recurse\n  // is true then descend into refs, if false only\n  // descend into non-refs\n\n\n  static _value_record_references(v, result, recurse) {\n    if (v == null) {} else if (v instanceof HasProps) {\n      if (!(v.id in result)) {\n        result[v.id] = v;\n\n        if (recurse) {\n          const immediate = v._immediate_references();\n\n          for (const obj of immediate) HasProps._value_record_references(obj, result, true); // true=recurse\n\n        }\n      }\n    } else if (v.buffer instanceof ArrayBuffer) {} else if (isArray(v)) {\n      for (const elem of v) HasProps._value_record_references(elem, result, recurse);\n    } else if (isPlainObject(v)) {\n      for (const k in v) {\n        if (v.hasOwnProperty(k)) {\n          const elem = v[k];\n\n          HasProps._value_record_references(elem, result, recurse);\n        }\n      }\n    }\n  } // Get models that are immediately referenced by our properties\n  // (do not recurse, do not include ourselves)\n\n\n  _immediate_references() {\n    const result = {};\n    const attrs = this.serializable_attributes();\n\n    for (const key in attrs) {\n      const value = attrs[key];\n\n      HasProps._value_record_references(value, result, false); // false = no recurse\n\n    }\n\n    return values(result);\n  }\n\n  references() {\n    const references = {};\n\n    HasProps._value_record_references(this, references, true);\n\n    return values(references);\n  }\n\n  _doc_attached() {}\n\n  attach_document(doc) {\n    // This should only be called by the Document implementation to set the document field\n    if (this.document != null && this.document != doc) throw new Error(\"models must be owned by only a single document\");\n    this.document = doc;\n\n    this._doc_attached();\n  }\n\n  detach_document() {\n    // This should only be called by the Document implementation to unset the document field\n    this.document = null;\n  }\n\n  _tell_document_about_change(attr, old, new_, options) {\n    if (!this.attribute_is_serializable(attr)) return;\n\n    if (this.document != null) {\n      const new_refs = {};\n\n      HasProps._value_record_references(new_, new_refs, false);\n\n      const old_refs = {};\n\n      HasProps._value_record_references(old, old_refs, false);\n\n      let need_invalidate = false;\n\n      for (const new_id in new_refs) {\n        if (!(new_id in old_refs)) {\n          need_invalidate = true;\n          break;\n        }\n      }\n\n      if (!need_invalidate) {\n        for (const old_id in old_refs) {\n          if (!(old_id in new_refs)) {\n            need_invalidate = true;\n            break;\n          }\n        }\n      }\n\n      if (need_invalidate) this.document._invalidate_all_models();\n\n      this.document._notify_change(this, attr, old, new_, options);\n    }\n  }\n\n  materialize_dataspecs(source) {\n    // Note: this should be moved to a function separate from HasProps\n    const data = {};\n\n    for (const name in this.properties) {\n      const prop = this.properties[name];\n      if (!(prop instanceof p.VectorSpec)) continue; // this skips optional properties like radius for circles\n\n      if (prop.optional && prop.spec.value == null && !(name in this._set_after_defaults)) continue;\n      const array = prop.array(source);\n      data[`_${name}`] = array; // the shapes are indexed by the column name, but when we materialize the dataspec, we should\n      // store under the canonical field name, e.g. _image_shape, even if the column name is \"foo\"\n\n      if (prop.spec.field != null && prop.spec.field in source._shapes) data[`_${name}_shape`] = source._shapes[prop.spec.field];\n      if (prop instanceof p.DistanceSpec) data[`max_${name}`] = max(array);\n    }\n\n    return data;\n  }\n\n}\nHasProps.init_HasProps();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/has_props.js"],"names":["Signal0","Signal","Signalable","property_mixins","is_ref","p","uniqueId","max","copy","values","clone","isEmpty","isPlainObject","isObject","isArray","isFunction","isEqual","HasProps","constructor","attrs","_subtype","undefined","document","destroyed","change","transformchange","attributes","properties","_set_after_defaults","_pending","_changing","name","props","type","default_value","Error","id","setv","silent","deferred","__deferred__","finalize","console","warn","__name__","__qualified__","__module__","init_HasProps","prototype","mixins","define","Any","_fix_default","_attr","obj","prop","Object","defineProperty","get","value","getv","set","configurable","enumerable","internal","refined_prop","_object","mixin","names","create","concat","override","assign","toString","update","spec","transform","connect","emit","initialize","connect_signals","disconnect_signals","disconnectReceiver","destroy","_setv","options","check_eq","changes","changing","current","attr","val","push","length","i","no_change","key","hasOwnProperty","prop_name","defaults","old","_tell_document_about_change","ref","struct","subtype","set_subtype","attribute_is_serializable","serializable_attributes","_value_to_json","_key","_optional_parent_object","ref_array","v","ref_obj","subkey","attributes_as_json","include_defaults","value_to_json","serializable","_json_record_references","doc","result","recurse","model","get_model_by_id","_value_record_references","elem","k","immediate","_immediate_references","buffer","ArrayBuffer","references","_doc_attached","attach_document","detach_document","new_","new_refs","old_refs","need_invalidate","new_id","old_id","_invalidate_all_models","_notify_change","materialize_dataspecs","source","data","VectorSpec","optional","array","field","_shapes","DistanceSpec"],"mappings":"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","sourcesContent":["import { Signal0, Signal, Signalable } from \"./signaling\";\nimport * as property_mixins from \"./property_mixins\";\nimport { is_ref } from \"./util/refs\";\nimport * as p from \"./properties\";\nimport { uniqueId } from \"./util/string\";\nimport { max, copy } from \"./util/array\";\nimport { values, clone, isEmpty } from \"./util/object\";\nimport { isPlainObject, isObject, isArray, isFunction } from \"./util/types\";\nimport { isEqual } from './util/eq';\nexport class HasProps extends Signalable() {\n    constructor(attrs = {}) {\n        super();\n        this._subtype = undefined;\n        this.document = null;\n        this.destroyed = new Signal0(this, \"destroyed\");\n        this.change = new Signal0(this, \"change\");\n        this.transformchange = new Signal0(this, \"transformchange\");\n        this.attributes = {};\n        this.properties = {};\n        this._set_after_defaults = {};\n        this._pending = false;\n        this._changing = false;\n        for (const name in this.props) {\n            const { type, default_value } = this.props[name];\n            if (type != null)\n                this.properties[name] = new type(this, name, default_value);\n            else\n                throw new Error(`undefined property type for ${this.type}.${name}`);\n        }\n        // auto generating ID\n        if (attrs.id == null)\n            this.setv({ id: uniqueId() }, { silent: true });\n        const deferred = attrs.__deferred__ || false;\n        if (deferred) {\n            attrs = clone(attrs);\n            delete attrs.__deferred__;\n        }\n        this.setv(attrs, { silent: true });\n        // allowing us to defer initialization when loading many models\n        // when loading a bunch of models, we want to do initialization as a second pass\n        // because other objects that this one depends on might not be loaded yet\n        if (!deferred)\n            this.finalize();\n    }\n    // XXX: setter is only required for backwards compatibility\n    set type(name) {\n        console.warn(\"prototype.type = 'ModelName' is deprecated, use static __name__ instead\");\n        this.constructor.__name__ = name;\n    }\n    get type() {\n        return this.constructor.__qualified__;\n    }\n    static get __qualified__() {\n        const { __module__, __name__ } = this;\n        return __module__ != null ? `${__module__}.${__name__}` : __name__;\n    }\n    static init_HasProps() {\n        this.prototype.props = {};\n        this.prototype.mixins = [];\n        this.define({\n            id: [p.Any],\n        });\n    }\n    // }}}\n    static _fix_default(default_value, _attr) {\n        if (default_value === undefined)\n            return undefined;\n        else if (isFunction(default_value))\n            return default_value;\n        else if (!isObject(default_value))\n            return () => default_value;\n        else {\n            //logger.warn(`${this.prototype.type}.${attr} uses unwrapped non-primitive default value`)\n            if (isArray(default_value))\n                return () => copy(default_value);\n            else\n                return () => clone(default_value);\n        }\n    }\n    // TODO: don't use Partial<>, but exclude inherited properties\n    static define(obj) {\n        for (const name in obj) {\n            const prop = obj[name];\n            if (this.prototype.props[name] != null)\n                throw new Error(`attempted to redefine property '${this.prototype.type}.${name}'`);\n            if (this.prototype[name] != null)\n                throw new Error(`attempted to redefine attribute '${this.prototype.type}.${name}'`);\n            Object.defineProperty(this.prototype, name, {\n                // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306\n                get() {\n                    const value = this.getv(name);\n                    return value;\n                },\n                set(value) {\n                    this.setv({ [name]: value });\n                    return this;\n                },\n                configurable: false,\n                enumerable: true,\n            });\n            const [type, default_value, internal] = prop;\n            const refined_prop = {\n                type,\n                default_value: this._fix_default(default_value, name),\n                internal: internal || false,\n            };\n            const props = clone(this.prototype.props);\n            props[name] = refined_prop;\n            this.prototype.props = props;\n        }\n    }\n    static internal(obj) {\n        const _object = {};\n        for (const name in obj) {\n            const prop = obj[name];\n            const [type, default_value] = prop;\n            _object[name] = [type, default_value, true];\n        }\n        this.define(_object);\n    }\n    static mixin(...names) {\n        this.define(property_mixins.create(names));\n        const mixins = this.prototype.mixins.concat(names);\n        this.prototype.mixins = mixins;\n    }\n    static mixins(names) {\n        this.mixin(...names);\n    }\n    static override(obj) {\n        for (const name in obj) {\n            const default_value = this._fix_default(obj[name], name);\n            const value = this.prototype.props[name];\n            if (value == null)\n                throw new Error(`attempted to override nonexistent '${this.prototype.type}.${name}'`);\n            const props = clone(this.prototype.props);\n            props[name] = Object.assign(Object.assign({}, value), { default_value });\n            this.prototype.props = props;\n        }\n    }\n    toString() {\n        return `${this.type}(${this.id})`;\n    }\n    finalize() {\n        // This is necessary because the initial creation of properties relies on\n        // model.get which is not usable at that point yet in the constructor. This\n        // initializer is called when deferred initialization happens for all models\n        // and insures that the Bokeh properties are initialized from Backbone\n        // attributes in a consistent way.\n        //\n        // TODO (bev) split property creation up into two parts so that only the\n        // portion of init that can be done happens in HasProps constructor and so\n        // that subsequent updates do not duplicate that setup work.\n        for (const name in this.properties) {\n            const prop = this.properties[name];\n            prop.update();\n            if (prop.spec.transform != null)\n                this.connect(prop.spec.transform.change, () => this.transformchange.emit());\n        }\n        this.initialize();\n        this.connect_signals();\n    }\n    initialize() { }\n    connect_signals() { }\n    disconnect_signals() {\n        Signal.disconnectReceiver(this);\n    }\n    destroy() {\n        this.disconnect_signals();\n        this.destroyed.emit();\n    }\n    // Create a new model with identical attributes to this one.\n    clone() {\n        return new this.constructor(this.attributes);\n    }\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    _setv(attrs, options) {\n        // Extract attributes and options.\n        const check_eq = options.check_eq;\n        const silent = options.silent;\n        const changes = [];\n        const changing = this._changing;\n        this._changing = true;\n        const current = this.attributes;\n        // For each `set` attribute, update or delete the current value.\n        for (const attr in attrs) {\n            const val = attrs[attr];\n            if (check_eq !== false) {\n                if (!isEqual(current[attr], val))\n                    changes.push(attr);\n            }\n            else\n                changes.push(attr);\n            current[attr] = val;\n        }\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length > 0)\n                this._pending = true;\n            for (let i = 0; i < changes.length; i++)\n                this.properties[changes[i]].change.emit();\n        }\n        // You might be wondering why there's a `while` loop here. Changes can\n        // be recursively nested within `\"change\"` events.\n        if (changing)\n            return;\n        if (!silent && !options.no_change) {\n            while (this._pending) {\n                this._pending = false;\n                this.change.emit();\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n    }\n    setv(attrs, options = {}) {\n        for (const key in attrs) {\n            if (!attrs.hasOwnProperty(key))\n                continue;\n            const prop_name = key;\n            if (this.props[prop_name] == null)\n                throw new Error(`property ${this.type}.${prop_name} wasn't declared`);\n            if (!(options != null && options.defaults))\n                this._set_after_defaults[key] = true;\n        }\n        if (!isEmpty(attrs)) {\n            const old = {};\n            for (const key in attrs)\n                old[key] = this.getv(key);\n            this._setv(attrs, options);\n            const silent = options.silent;\n            if (silent == null || !silent) {\n                for (const key in attrs)\n                    this._tell_document_about_change(key, old[key], this.getv(key), options);\n            }\n        }\n    }\n    getv(prop_name) {\n        if (this.props[prop_name] == null)\n            throw new Error(`property ${this.type}.${prop_name} wasn't declared`);\n        else\n            return this.attributes[prop_name];\n    }\n    ref() {\n        return { id: this.id };\n    }\n    struct() {\n        const struct = {\n            type: this.type,\n            id: this.id,\n            attributes: {},\n        };\n        if (this._subtype != null) {\n            struct.subtype = this._subtype;\n        }\n        return struct;\n    }\n    // we only keep the subtype so we match Python;\n    // only Python cares about this\n    set_subtype(subtype) {\n        this._subtype = subtype;\n    }\n    attribute_is_serializable(attr) {\n        const prop = this.props[attr];\n        if (prop == null)\n            throw new Error(`${this.type}.attribute_is_serializable('${attr}'): ${attr} wasn't declared`);\n        else\n            return !prop.internal;\n    }\n    // dict of attributes that should be serialized to the server. We\n    // sometimes stick things in attributes that aren't part of the\n    // Document's models, subtypes that do that have to remove their\n    // extra attributes here.\n    serializable_attributes() {\n        const attrs = {};\n        for (const name in this.attributes) {\n            const value = this.attributes[name];\n            if (this.attribute_is_serializable(name))\n                attrs[name] = value;\n        }\n        return attrs;\n    }\n    static _value_to_json(_key, value, _optional_parent_object) {\n        if (value instanceof HasProps)\n            return value.ref();\n        else if (isArray(value)) {\n            const ref_array = [];\n            for (let i = 0; i < value.length; i++) {\n                const v = value[i];\n                ref_array.push(HasProps._value_to_json(i.toString(), v, value));\n            }\n            return ref_array;\n        }\n        else if (isPlainObject(value)) {\n            const ref_obj = {};\n            for (const subkey in value) {\n                if (value.hasOwnProperty(subkey))\n                    ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);\n            }\n            return ref_obj;\n        }\n        else\n            return value;\n    }\n    // Convert attributes to \"shallow\" JSON (values which are themselves models\n    // are included as just references)\n    attributes_as_json(include_defaults = true, value_to_json = HasProps._value_to_json) {\n        const serializable = this.serializable_attributes();\n        const attrs = {};\n        for (const key in serializable) {\n            if (serializable.hasOwnProperty(key)) {\n                const value = serializable[key];\n                if (include_defaults)\n                    attrs[key] = value;\n                else if (key in this._set_after_defaults)\n                    attrs[key] = value;\n            }\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    }\n    // this is like _value_record_references but expects to find refs\n    // instead of models, and takes a doc to look up the refs in\n    static _json_record_references(doc, v, result, recurse) {\n        if (v == null) {\n        }\n        else if (is_ref(v)) {\n            if (!(v.id in result)) {\n                const model = doc.get_model_by_id(v.id);\n                HasProps._value_record_references(model, result, recurse);\n            }\n        }\n        else if (isArray(v)) {\n            for (const elem of v)\n                HasProps._json_record_references(doc, elem, result, recurse);\n        }\n        else if (isPlainObject(v)) {\n            for (const k in v) {\n                if (v.hasOwnProperty(k)) {\n                    const elem = v[k];\n                    HasProps._json_record_references(doc, elem, result, recurse);\n                }\n            }\n        }\n    }\n    // add all references from 'v' to 'result', if recurse\n    // is true then descend into refs, if false only\n    // descend into non-refs\n    static _value_record_references(v, result, recurse) {\n        if (v == null) {\n        }\n        else if (v instanceof HasProps) {\n            if (!(v.id in result)) {\n                result[v.id] = v;\n                if (recurse) {\n                    const immediate = v._immediate_references();\n                    for (const obj of immediate)\n                        HasProps._value_record_references(obj, result, true); // true=recurse\n                }\n            }\n        }\n        else if (v.buffer instanceof ArrayBuffer) {\n        }\n        else if (isArray(v)) {\n            for (const elem of v)\n                HasProps._value_record_references(elem, result, recurse);\n        }\n        else if (isPlainObject(v)) {\n            for (const k in v) {\n                if (v.hasOwnProperty(k)) {\n                    const elem = v[k];\n                    HasProps._value_record_references(elem, result, recurse);\n                }\n            }\n        }\n    }\n    // Get models that are immediately referenced by our properties\n    // (do not recurse, do not include ourselves)\n    _immediate_references() {\n        const result = {};\n        const attrs = this.serializable_attributes();\n        for (const key in attrs) {\n            const value = attrs[key];\n            HasProps._value_record_references(value, result, false); // false = no recurse\n        }\n        return values(result);\n    }\n    references() {\n        const references = {};\n        HasProps._value_record_references(this, references, true);\n        return values(references);\n    }\n    _doc_attached() { }\n    attach_document(doc) {\n        // This should only be called by the Document implementation to set the document field\n        if (this.document != null && this.document != doc)\n            throw new Error(\"models must be owned by only a single document\");\n        this.document = doc;\n        this._doc_attached();\n    }\n    detach_document() {\n        // This should only be called by the Document implementation to unset the document field\n        this.document = null;\n    }\n    _tell_document_about_change(attr, old, new_, options) {\n        if (!this.attribute_is_serializable(attr))\n            return;\n        if (this.document != null) {\n            const new_refs = {};\n            HasProps._value_record_references(new_, new_refs, false);\n            const old_refs = {};\n            HasProps._value_record_references(old, old_refs, false);\n            let need_invalidate = false;\n            for (const new_id in new_refs) {\n                if (!(new_id in old_refs)) {\n                    need_invalidate = true;\n                    break;\n                }\n            }\n            if (!need_invalidate) {\n                for (const old_id in old_refs) {\n                    if (!(old_id in new_refs)) {\n                        need_invalidate = true;\n                        break;\n                    }\n                }\n            }\n            if (need_invalidate)\n                this.document._invalidate_all_models();\n            this.document._notify_change(this, attr, old, new_, options);\n        }\n    }\n    materialize_dataspecs(source) {\n        // Note: this should be moved to a function separate from HasProps\n        const data = {};\n        for (const name in this.properties) {\n            const prop = this.properties[name];\n            if (!(prop instanceof p.VectorSpec))\n                continue;\n            // this skips optional properties like radius for circles\n            if (prop.optional && prop.spec.value == null && !(name in this._set_after_defaults))\n                continue;\n            const array = prop.array(source);\n            data[`_${name}`] = array;\n            // the shapes are indexed by the column name, but when we materialize the dataspec, we should\n            // store under the canonical field name, e.g. _image_shape, even if the column name is \"foo\"\n            if (prop.spec.field != null && prop.spec.field in source._shapes)\n                data[`_${name}_shape`] = source._shapes[prop.spec.field];\n            if (prop instanceof p.DistanceSpec)\n                data[`max_${name}`] = max(array);\n        }\n        return data;\n    }\n}\nHasProps.init_HasProps();\n//# sourceMappingURL=has_props.js.map"]},"metadata":{},"sourceType":"module"}