{"ast":null,"code":"//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nimport { isFunction } from \"./types\";\nconst toString = Object.prototype.toString; // Internal recursive comparison function for `isEqual`.\n\nfunction eq(a, b, aStack, bStack) {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`.\n\n  if (a == null || b == null) return a === b; // Compare `[[Class]]` names.\n\n  const className = toString.call(a);\n  if (className !== toString.call(b)) return false;\n\n  switch (className) {\n    // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n    case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n\n    case '[object String]':\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return '' + a === '' + b;\n\n    case '[object Number]':\n      // `NaN`s are equivalent, but non-reflexive.\n      // Object(NaN) is equivalent to NaN\n      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.\n\n      return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n\n    case '[object Date]':\n    case '[object Boolean]':\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a === +b;\n  }\n\n  const areArrays = className === '[object Array]';\n\n  if (!areArrays) {\n    if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n    // from different frames are.\n\n    const aCtor = a.constructor,\n          bCtor = b.constructor;\n\n    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {\n      return false;\n    }\n  } // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n  // Initializing stack of traversed objects.\n  // It's done here since we only need them for objects and arrays comparison.\n\n\n  aStack = aStack || [];\n  bStack = bStack || [];\n  let length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] === a) return bStack[length] === b;\n  } // Add the first object to the stack of traversed objects.\n\n\n  aStack.push(a);\n  bStack.push(b); // Recursively compare objects and arrays.\n\n  if (areArrays) {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    length = a.length;\n    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.\n\n    while (length--) {\n      if (!eq(a[length], b[length], aStack, bStack)) return false;\n    }\n  } else {\n    // Deep compare objects.\n    const keys = Object.keys(a);\n    let key;\n    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.\n\n    if (Object.keys(b).length !== length) return false;\n\n    while (length--) {\n      // Deep compare each member\n      key = keys[length];\n      if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack))) return false;\n    }\n  } // Remove the first object from the stack of traversed objects.\n\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n} // Perform a deep comparison to check if two objects are equal.\n\n\nexport function isEqual(a, b) {\n  return eq(a, b);\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/eq.js"],"names":["isFunction","toString","Object","prototype","eq","a","b","aStack","bStack","className","call","areArrays","aCtor","constructor","bCtor","length","push","keys","key","hasOwnProperty","pop","isEqual"],"mappings":"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","sourcesContent":["//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\nimport { isFunction } from \"./types\";\nconst toString = Object.prototype.toString;\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b)\n        return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null)\n        return a === b;\n    // Compare `[[Class]]` names.\n    const className = toString.call(a);\n    if (className !== toString.call(b))\n        return false;\n    switch (className) {\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case '[object String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return '' + a === '' + b;\n        case '[object Number]':\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN\n            if (+a !== +a)\n                return +b !== +b;\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case '[object Date]':\n        case '[object Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n    }\n    const areArrays = className === '[object Array]';\n    if (!areArrays) {\n        if (typeof a != 'object' || typeof b != 'object')\n            return false;\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        const aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\n            isFunction(bCtor) && bCtor instanceof bCtor)\n            && ('constructor' in a && 'constructor' in b)) {\n            return false;\n        }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    let length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a)\n            return bStack[length] === b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length)\n            return false;\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (length--) {\n            if (!eq(a[length], b[length], aStack, bStack))\n                return false;\n        }\n    }\n    else {\n        // Deep compare objects.\n        const keys = Object.keys(a);\n        let key;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== length)\n            return false;\n        while (length--) {\n            // Deep compare each member\n            key = keys[length];\n            if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))\n                return false;\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\n// Perform a deep comparison to check if two objects are equal.\nexport function isEqual(a, b) {\n    return eq(a, b);\n}\n//# sourceMappingURL=eq.js.map"]},"metadata":{},"sourceType":"module"}