{"ast":null,"code":"import { isTypedArray, isArray, isObject } from \"./types\";\nimport { is_little_endian } from \"./compat\";\nexport const ARRAY_TYPES = {\n  uint8: Uint8Array,\n  int8: Int8Array,\n  uint16: Uint16Array,\n  int16: Int16Array,\n  uint32: Uint32Array,\n  int32: Int32Array,\n  float32: Float32Array,\n  float64: Float64Array\n};\nexport const DTYPES = {\n  Uint8Array: \"uint8\",\n  Int8Array: \"int8\",\n  Uint16Array: \"uint16\",\n  Int16Array: \"int16\",\n  Uint32Array: \"uint32\",\n  Int32Array: \"int32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\"\n};\n\nfunction arrayName(array) {\n  if (\"name\" in array.constructor) return array.constructor.name;else {\n    switch (true) {\n      case array instanceof Uint8Array:\n        return \"Uint8Array\";\n\n      case array instanceof Int8Array:\n        return \"Int8Array\";\n\n      case array instanceof Uint16Array:\n        return \"Uint16Array\";\n\n      case array instanceof Int16Array:\n        return \"Int16Array\";\n\n      case array instanceof Uint32Array:\n        return \"Uint32Array\";\n\n      case array instanceof Int32Array:\n        return \"Int32Array\";\n\n      case array instanceof Float32Array:\n        return \"Float32Array\";\n\n      case array instanceof Float64Array:\n        return \"Float64Array\";\n\n      default:\n        throw new Error(\"unsupported typed array\");\n    }\n  }\n}\n\nexport const BYTE_ORDER = is_little_endian ? \"little\" : \"big\";\nexport function swap16(a) {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2);\n\n  for (let i = 0, end = x.length; i < end; i += 2) {\n    const t = x[i];\n    x[i] = x[i + 1];\n    x[i + 1] = t;\n  }\n}\nexport function swap32(a) {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4);\n\n  for (let i = 0, end = x.length; i < end; i += 4) {\n    let t = x[i];\n    x[i] = x[i + 3];\n    x[i + 3] = t;\n    t = x[i + 1];\n    x[i + 1] = x[i + 2];\n    x[i + 2] = t;\n  }\n}\nexport function swap64(a) {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8);\n\n  for (let i = 0, end = x.length; i < end; i += 8) {\n    let t = x[i];\n    x[i] = x[i + 7];\n    x[i + 7] = t;\n    t = x[i + 1];\n    x[i + 1] = x[i + 6];\n    x[i + 6] = t;\n    t = x[i + 2];\n    x[i + 2] = x[i + 5];\n    x[i + 5] = t;\n    t = x[i + 3];\n    x[i + 3] = x[i + 4];\n    x[i + 4] = t;\n  }\n}\nexport function process_buffer(specification, buffers) {\n  const need_swap = specification.order !== BYTE_ORDER;\n  const {\n    shape\n  } = specification;\n  let bytes = null;\n\n  for (const buf of buffers) {\n    const header = JSON.parse(buf[0]);\n\n    if (header.id === specification.__buffer__) {\n      bytes = buf[1];\n      break;\n    }\n  }\n\n  const arr = new ARRAY_TYPES[specification.dtype](bytes);\n\n  if (need_swap) {\n    if (arr.BYTES_PER_ELEMENT === 2) {\n      swap16(arr);\n    } else if (arr.BYTES_PER_ELEMENT === 4) {\n      swap32(arr);\n    } else if (arr.BYTES_PER_ELEMENT === 8) {\n      swap64(arr);\n    }\n  }\n\n  return [arr, shape];\n}\nexport function process_array(obj, buffers) {\n  if (isObject(obj) && '__ndarray__' in obj) return decode_base64(obj);else if (isObject(obj) && '__buffer__' in obj) return process_buffer(obj, buffers);else if (isArray(obj) || isTypedArray(obj)) return [obj, []];else return undefined;\n}\nexport function arrayBufferToBase64(buffer) {\n  const bytes = new Uint8Array(buffer);\n  const chars = Array.from(bytes).map(b => String.fromCharCode(b));\n  return btoa(chars.join(\"\"));\n}\nexport function base64ToArrayBuffer(base64) {\n  const binary_string = atob(base64);\n  const len = binary_string.length;\n  const bytes = new Uint8Array(len);\n\n  for (let i = 0, end = len; i < end; i++) {\n    bytes[i] = binary_string.charCodeAt(i);\n  }\n\n  return bytes.buffer;\n}\nexport function decode_base64(input) {\n  const bytes = base64ToArrayBuffer(input.__ndarray__);\n  const dtype = input.dtype;\n  const shape = input.shape;\n  let array;\n  if (dtype in ARRAY_TYPES) array = new ARRAY_TYPES[dtype](bytes);else throw new Error(`unknown dtype: ${dtype}`);\n  return [array, shape];\n}\nexport function encode_base64(array, shape) {\n  const b64 = arrayBufferToBase64(array.buffer);\n  const name = arrayName(array);\n  let dtype;\n  if (name in DTYPES) dtype = DTYPES[name];else throw new Error(`unknown array type: ${name}`);\n  const data = {\n    __ndarray__: b64,\n    shape,\n    dtype\n  };\n  return data;\n}\n\nfunction decode_traverse_data(v, buffers) {\n  // v is just a regular array of scalars\n  if (v.length == 0 || !(isObject(v[0]) || isArray(v[0]))) {\n    return [v, []];\n  }\n\n  const arrays = [];\n  const shapes = [];\n\n  for (const obj of v) {\n    const [arr, shape] = isArray(obj) ? decode_traverse_data(obj, buffers) : process_array(obj, buffers);\n    arrays.push(arr);\n    shapes.push(shape);\n  } // If there is a list of empty lists, reduce that to just a list\n\n\n  const filtered_shapes = shapes.map(shape => shape.filter(v => v.length != 0));\n  return [arrays, filtered_shapes];\n}\n\nexport function decode_column_data(data, buffers = []) {\n  const new_data = {};\n  const new_shapes = {};\n\n  for (const k in data) {\n    // might be array of scalars, or might be ragged array or arrays\n    const v = data[k];\n\n    if (isArray(v)) {\n      // v is just a regular array of scalars\n      if (v.length == 0 || !(isObject(v[0]) || isArray(v[0]))) {\n        new_data[k] = v;\n        continue;\n      } // v is a ragged array of arrays\n\n\n      const [arrays, shapes] = decode_traverse_data(v, buffers);\n      new_data[k] = arrays;\n      new_shapes[k] = shapes; // must be object or array (single array case)\n    } else {\n      const [arr, shape] = process_array(v, buffers);\n      new_data[k] = arr;\n      new_shapes[k] = shape;\n    }\n  }\n\n  return [new_data, new_shapes];\n}\n\nfunction encode_traverse_data(v, shapes) {\n  const new_array = [];\n\n  for (let i = 0, end = v.length; i < end; i++) {\n    const item = v[i];\n\n    if (isTypedArray(item)) {\n      const shape = shapes[i] ? shapes[i] : undefined;\n      new_array.push(encode_base64(item, shape));\n    } else if (isArray(item)) {\n      new_array.push(encode_traverse_data(item, shapes ? shapes[i] : []));\n    } else new_array.push(item);\n  }\n\n  return new_array;\n}\n\nexport function encode_column_data(data, shapes) {\n  const new_data = {};\n\n  for (const k in data) {\n    const v = data[k];\n    const shapes_k = shapes != null ? shapes[k] : undefined;\n    let new_v;\n\n    if (isTypedArray(v)) {\n      new_v = encode_base64(v, shapes_k);\n    } else if (isArray(v)) {\n      new_v = encode_traverse_data(v, shapes_k || []);\n    } else new_v = v;\n\n    new_data[k] = new_v;\n  }\n\n  return new_data;\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/serialization.js"],"names":["isTypedArray","isArray","isObject","is_little_endian","ARRAY_TYPES","uint8","Uint8Array","int8","Int8Array","uint16","Uint16Array","int16","Int16Array","uint32","Uint32Array","int32","Int32Array","float32","Float32Array","float64","Float64Array","DTYPES","arrayName","array","constructor","name","Error","BYTE_ORDER","swap16","a","x","buffer","byteOffset","length","i","end","t","swap32","swap64","process_buffer","specification","buffers","need_swap","order","shape","bytes","buf","header","JSON","parse","id","__buffer__","arr","dtype","BYTES_PER_ELEMENT","process_array","obj","decode_base64","undefined","arrayBufferToBase64","chars","Array","from","map","b","String","fromCharCode","btoa","join","base64ToArrayBuffer","base64","binary_string","atob","len","charCodeAt","input","__ndarray__","encode_base64","b64","data","decode_traverse_data","v","arrays","shapes","push","filtered_shapes","filter","decode_column_data","new_data","new_shapes","k","encode_traverse_data","new_array","item","encode_column_data","shapes_k","new_v"],"mappings":"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","sourcesContent":["import { isTypedArray, isArray, isObject } from \"./types\";\nimport { is_little_endian } from \"./compat\";\nexport const ARRAY_TYPES = {\n    uint8: Uint8Array,\n    int8: Int8Array,\n    uint16: Uint16Array,\n    int16: Int16Array,\n    uint32: Uint32Array,\n    int32: Int32Array,\n    float32: Float32Array,\n    float64: Float64Array,\n};\nexport const DTYPES = {\n    Uint8Array: \"uint8\",\n    Int8Array: \"int8\",\n    Uint16Array: \"uint16\",\n    Int16Array: \"int16\",\n    Uint32Array: \"uint32\",\n    Int32Array: \"int32\",\n    Float32Array: \"float32\",\n    Float64Array: \"float64\",\n};\nfunction arrayName(array) {\n    if (\"name\" in array.constructor)\n        return array.constructor.name;\n    else {\n        switch (true) {\n            case array instanceof Uint8Array: return \"Uint8Array\";\n            case array instanceof Int8Array: return \"Int8Array\";\n            case array instanceof Uint16Array: return \"Uint16Array\";\n            case array instanceof Int16Array: return \"Int16Array\";\n            case array instanceof Uint32Array: return \"Uint32Array\";\n            case array instanceof Int32Array: return \"Int32Array\";\n            case array instanceof Float32Array: return \"Float32Array\";\n            case array instanceof Float64Array: return \"Float64Array\";\n            default:\n                throw new Error(\"unsupported typed array\");\n        }\n    }\n}\nexport const BYTE_ORDER = is_little_endian ? \"little\" : \"big\";\nexport function swap16(a) {\n    const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2);\n    for (let i = 0, end = x.length; i < end; i += 2) {\n        const t = x[i];\n        x[i] = x[i + 1];\n        x[i + 1] = t;\n    }\n}\nexport function swap32(a) {\n    const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4);\n    for (let i = 0, end = x.length; i < end; i += 4) {\n        let t = x[i];\n        x[i] = x[i + 3];\n        x[i + 3] = t;\n        t = x[i + 1];\n        x[i + 1] = x[i + 2];\n        x[i + 2] = t;\n    }\n}\nexport function swap64(a) {\n    const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8);\n    for (let i = 0, end = x.length; i < end; i += 8) {\n        let t = x[i];\n        x[i] = x[i + 7];\n        x[i + 7] = t;\n        t = x[i + 1];\n        x[i + 1] = x[i + 6];\n        x[i + 6] = t;\n        t = x[i + 2];\n        x[i + 2] = x[i + 5];\n        x[i + 5] = t;\n        t = x[i + 3];\n        x[i + 3] = x[i + 4];\n        x[i + 4] = t;\n    }\n}\nexport function process_buffer(specification, buffers) {\n    const need_swap = specification.order !== BYTE_ORDER;\n    const { shape } = specification;\n    let bytes = null;\n    for (const buf of buffers) {\n        const header = JSON.parse(buf[0]);\n        if (header.id === specification.__buffer__) {\n            bytes = buf[1];\n            break;\n        }\n    }\n    const arr = new (ARRAY_TYPES[specification.dtype])(bytes);\n    if (need_swap) {\n        if (arr.BYTES_PER_ELEMENT === 2) {\n            swap16(arr);\n        }\n        else if (arr.BYTES_PER_ELEMENT === 4) {\n            swap32(arr);\n        }\n        else if (arr.BYTES_PER_ELEMENT === 8) {\n            swap64(arr);\n        }\n    }\n    return [arr, shape];\n}\nexport function process_array(obj, buffers) {\n    if (isObject(obj) && '__ndarray__' in obj)\n        return decode_base64(obj);\n    else if (isObject(obj) && '__buffer__' in obj)\n        return process_buffer(obj, buffers);\n    else if (isArray(obj) || isTypedArray(obj))\n        return [obj, []];\n    else\n        return undefined;\n}\nexport function arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    const chars = Array.from(bytes).map((b) => String.fromCharCode(b));\n    return btoa(chars.join(\"\"));\n}\nexport function base64ToArrayBuffer(base64) {\n    const binary_string = atob(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0, end = len; i < end; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\nexport function decode_base64(input) {\n    const bytes = base64ToArrayBuffer(input.__ndarray__);\n    const dtype = input.dtype;\n    const shape = input.shape;\n    let array;\n    if (dtype in ARRAY_TYPES)\n        array = new (ARRAY_TYPES[dtype])(bytes);\n    else\n        throw new Error(`unknown dtype: ${dtype}`);\n    return [array, shape];\n}\nexport function encode_base64(array, shape) {\n    const b64 = arrayBufferToBase64(array.buffer);\n    const name = arrayName(array);\n    let dtype;\n    if (name in DTYPES)\n        dtype = DTYPES[name];\n    else\n        throw new Error(`unknown array type: ${name}`);\n    const data = {\n        __ndarray__: b64,\n        shape,\n        dtype,\n    };\n    return data;\n}\nfunction decode_traverse_data(v, buffers) {\n    // v is just a regular array of scalars\n    if (v.length == 0 || !(isObject(v[0]) || isArray(v[0]))) {\n        return [v, []];\n    }\n    const arrays = [];\n    const shapes = [];\n    for (const obj of v) {\n        const [arr, shape] = isArray(obj) ? decode_traverse_data(obj, buffers)\n            : process_array(obj, buffers);\n        arrays.push(arr);\n        shapes.push(shape);\n    }\n    // If there is a list of empty lists, reduce that to just a list\n    const filtered_shapes = shapes.map((shape) => shape.filter((v) => v.length != 0));\n    return [arrays, filtered_shapes];\n}\nexport function decode_column_data(data, buffers = []) {\n    const new_data = {};\n    const new_shapes = {};\n    for (const k in data) {\n        // might be array of scalars, or might be ragged array or arrays\n        const v = data[k];\n        if (isArray(v)) {\n            // v is just a regular array of scalars\n            if (v.length == 0 || !(isObject(v[0]) || isArray(v[0]))) {\n                new_data[k] = v;\n                continue;\n            }\n            // v is a ragged array of arrays\n            const [arrays, shapes] = decode_traverse_data(v, buffers);\n            new_data[k] = arrays;\n            new_shapes[k] = shapes;\n            // must be object or array (single array case)\n        }\n        else {\n            const [arr, shape] = process_array(v, buffers);\n            new_data[k] = arr;\n            new_shapes[k] = shape;\n        }\n    }\n    return [new_data, new_shapes];\n}\nfunction encode_traverse_data(v, shapes) {\n    const new_array = [];\n    for (let i = 0, end = v.length; i < end; i++) {\n        const item = v[i];\n        if (isTypedArray(item)) {\n            const shape = shapes[i] ? shapes[i] : undefined;\n            new_array.push(encode_base64(item, shape));\n        }\n        else if (isArray(item)) {\n            new_array.push(encode_traverse_data(item, shapes ? shapes[i] : []));\n        }\n        else\n            new_array.push(item);\n    }\n    return new_array;\n}\nexport function encode_column_data(data, shapes) {\n    const new_data = {};\n    for (const k in data) {\n        const v = data[k];\n        const shapes_k = shapes != null ? shapes[k] : undefined;\n        let new_v;\n        if (isTypedArray(v)) {\n            new_v = encode_base64(v, shapes_k);\n        }\n        else if (isArray(v)) {\n            new_v = encode_traverse_data(v, shapes_k || []);\n        }\n        else\n            new_v = v;\n        new_data[k] = new_v;\n    }\n    return new_data;\n}\n//# sourceMappingURL=serialization.js.map"]},"metadata":{},"sourceType":"module"}