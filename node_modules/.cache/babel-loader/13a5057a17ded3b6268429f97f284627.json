{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { measure_font } from \"../../core/util/text\";\nexport class TextView extends XYGlyphView {\n  _rotate_point(x, y, xoff, yoff, angle) {\n    const sxr = (x - xoff) * Math.cos(angle) - (y - yoff) * Math.sin(angle) + xoff;\n    const syr = (x - xoff) * Math.sin(angle) + (y - yoff) * Math.cos(angle) + yoff;\n    return [sxr, syr];\n  }\n\n  _text_bounds(x0, y0, width, height) {\n    const xvals = [x0, x0 + width, x0 + width, x0, x0];\n    const yvals = [y0, y0, y0 - height, y0 - height, y0];\n    return [xvals, yvals];\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    _x_offset,\n    _y_offset,\n    _angle,\n    _text\n  }) {\n    this._sys = [];\n    this._sxs = [];\n\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null) continue;\n      this._sxs[i] = [];\n      this._sys[i] = [];\n\n      if (this.visuals.text.doit) {\n        const text = `${_text[i]}`;\n        ctx.save();\n        ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\n        ctx.rotate(_angle[i]);\n        this.visuals.text.set_vectorize(ctx, i);\n        const font = this.visuals.text.cache_select(\"font\", i);\n        const {\n          height\n        } = measure_font(font);\n        const line_height = this.visuals.text.text_line_height.value() * height;\n\n        if (text.indexOf(\"\\n\") == -1) {\n          ctx.fillText(text, 0, 0);\n          const x0 = sx[i] + _x_offset[i];\n          const y0 = sy[i] + _y_offset[i];\n          const width = ctx.measureText(text).width;\n\n          const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n\n          this._sxs[i].push(xvalues);\n\n          this._sys[i].push(yvalues);\n        } else {\n          const lines = text.split(\"\\n\");\n          const block_height = line_height * lines.length;\n          const baseline = this.visuals.text.cache_select(\"text_baseline\", i);\n          let y;\n\n          switch (baseline) {\n            case \"top\":\n              {\n                y = 0;\n                break;\n              }\n\n            case \"middle\":\n              {\n                y = -block_height / 2 + line_height / 2;\n                break;\n              }\n\n            case \"bottom\":\n              {\n                y = -block_height + line_height;\n                break;\n              }\n\n            default:\n              {\n                y = 0;\n                console.warn(`'${baseline}' baseline not supported with multi line text`);\n              }\n          }\n\n          for (const line of lines) {\n            ctx.fillText(line, 0, y);\n            const x0 = sx[i] + _x_offset[i];\n            const y0 = y + sy[i] + _y_offset[i];\n            const width = ctx.measureText(line).width;\n\n            const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n\n            this._sxs[i].push(xvalues);\n\n            this._sys[i].push(yvalues);\n\n            y += line_height;\n          }\n        }\n\n        ctx.restore();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const hits = [];\n\n    for (let i = 0; i < this._sxs.length; i++) {\n      const sxs = this._sxs[i];\n      const sys = this._sys[i];\n      const n = sxs.length;\n\n      for (let j = 0, endj = n; j < endj; j++) {\n        const [sxr, syr] = this._rotate_point(sx, sy, sxs[n - 1][0], sys[n - 1][0], -this._angle[i]);\n\n        if (hittest.point_in_poly(sxr, syr, sxs[j], sys[j])) {\n          hits.push(i);\n        }\n      }\n    }\n\n    const result = hittest.create_empty_hit_test_result();\n    result.indices = hits;\n    return result;\n  }\n\n  _scenterxy(i) {\n    const sx0 = this._sxs[i][0][0];\n    const sy0 = this._sys[i][0][0];\n    const sxc = (this._sxs[i][0][2] + sx0) / 2;\n    const syc = (this._sys[i][0][2] + sy0) / 2;\n\n    const [sxcr, sycr] = this._rotate_point(sxc, syc, sx0, sy0, this._angle[i]);\n\n    return {\n      x: sxcr,\n      y: sycr\n    };\n  }\n\n  scenterx(i) {\n    return this._scenterxy(i).x;\n  }\n\n  scentery(i) {\n    return this._scenterxy(i).y;\n  }\n\n}\nTextView.__name__ = \"TextView\";\nexport class Text extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_Text() {\n    this.prototype.default_view = TextView;\n    this.mixins(['text']);\n    this.define({\n      text: [p.NullStringSpec, {\n        field: \"text\"\n      }],\n      angle: [p.AngleSpec, 0],\n      x_offset: [p.NumberSpec, 0],\n      y_offset: [p.NumberSpec, 0]\n    });\n  }\n\n}\nText.__name__ = \"Text\";\nText.init_Text();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/text.js"],"names":["XYGlyph","XYGlyphView","hittest","p","measure_font","TextView","_rotate_point","x","y","xoff","yoff","angle","sxr","Math","cos","sin","syr","_text_bounds","x0","y0","width","height","xvals","yvals","_render","ctx","indices","sx","sy","_x_offset","_y_offset","_angle","_text","_sys","_sxs","i","isNaN","visuals","text","doit","save","translate","rotate","set_vectorize","font","cache_select","line_height","text_line_height","value","indexOf","fillText","measureText","xvalues","yvalues","push","lines","split","block_height","length","baseline","console","warn","line","restore","_hit_point","geometry","hits","sxs","sys","n","j","endj","point_in_poly","result","create_empty_hit_test_result","_scenterxy","sx0","sy0","sxc","syc","sxcr","sycr","scenterx","scentery","__name__","Text","constructor","attrs","init_Text","prototype","default_view","mixins","define","NullStringSpec","field","AngleSpec","x_offset","NumberSpec","y_offset"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { measure_font } from \"../../core/util/text\";\nexport class TextView extends XYGlyphView {\n    _rotate_point(x, y, xoff, yoff, angle) {\n        const sxr = (x - xoff) * Math.cos(angle) - (y - yoff) * Math.sin(angle) + xoff;\n        const syr = (x - xoff) * Math.sin(angle) + (y - yoff) * Math.cos(angle) + yoff;\n        return [sxr, syr];\n    }\n    _text_bounds(x0, y0, width, height) {\n        const xvals = [x0, x0 + width, x0 + width, x0, x0];\n        const yvals = [y0, y0, y0 - height, y0 - height, y0];\n        return [xvals, yvals];\n    }\n    _render(ctx, indices, { sx, sy, _x_offset, _y_offset, _angle, _text }) {\n        this._sys = [];\n        this._sxs = [];\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null)\n                continue;\n            this._sxs[i] = [];\n            this._sys[i] = [];\n            if (this.visuals.text.doit) {\n                const text = `${_text[i]}`;\n                ctx.save();\n                ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\n                ctx.rotate(_angle[i]);\n                this.visuals.text.set_vectorize(ctx, i);\n                const font = this.visuals.text.cache_select(\"font\", i);\n                const { height } = measure_font(font);\n                const line_height = this.visuals.text.text_line_height.value() * height;\n                if (text.indexOf(\"\\n\") == -1) {\n                    ctx.fillText(text, 0, 0);\n                    const x0 = sx[i] + _x_offset[i];\n                    const y0 = sy[i] + _y_offset[i];\n                    const width = ctx.measureText(text).width;\n                    const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n                    this._sxs[i].push(xvalues);\n                    this._sys[i].push(yvalues);\n                }\n                else {\n                    const lines = text.split(\"\\n\");\n                    const block_height = line_height * lines.length;\n                    const baseline = this.visuals.text.cache_select(\"text_baseline\", i);\n                    let y;\n                    switch (baseline) {\n                        case \"top\": {\n                            y = 0;\n                            break;\n                        }\n                        case \"middle\": {\n                            y = (-block_height / 2) + (line_height / 2);\n                            break;\n                        }\n                        case \"bottom\": {\n                            y = -block_height + line_height;\n                            break;\n                        }\n                        default: {\n                            y = 0;\n                            console.warn(`'${baseline}' baseline not supported with multi line text`);\n                        }\n                    }\n                    for (const line of lines) {\n                        ctx.fillText(line, 0, y);\n                        const x0 = sx[i] + _x_offset[i];\n                        const y0 = y + sy[i] + _y_offset[i];\n                        const width = ctx.measureText(line).width;\n                        const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n                        this._sxs[i].push(xvalues);\n                        this._sys[i].push(yvalues);\n                        y += line_height;\n                    }\n                }\n                ctx.restore();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const hits = [];\n        for (let i = 0; i < this._sxs.length; i++) {\n            const sxs = this._sxs[i];\n            const sys = this._sys[i];\n            const n = sxs.length;\n            for (let j = 0, endj = n; j < endj; j++) {\n                const [sxr, syr] = this._rotate_point(sx, sy, sxs[n - 1][0], sys[n - 1][0], -this._angle[i]);\n                if (hittest.point_in_poly(sxr, syr, sxs[j], sys[j])) {\n                    hits.push(i);\n                }\n            }\n        }\n        const result = hittest.create_empty_hit_test_result();\n        result.indices = hits;\n        return result;\n    }\n    _scenterxy(i) {\n        const sx0 = this._sxs[i][0][0];\n        const sy0 = this._sys[i][0][0];\n        const sxc = (this._sxs[i][0][2] + sx0) / 2;\n        const syc = (this._sys[i][0][2] + sy0) / 2;\n        const [sxcr, sycr] = this._rotate_point(sxc, syc, sx0, sy0, this._angle[i]);\n        return { x: sxcr, y: sycr };\n    }\n    scenterx(i) {\n        return this._scenterxy(i).x;\n    }\n    scentery(i) {\n        return this._scenterxy(i).y;\n    }\n}\nTextView.__name__ = \"TextView\";\nexport class Text extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_Text() {\n        this.prototype.default_view = TextView;\n        this.mixins(['text']);\n        this.define({\n            text: [p.NullStringSpec, { field: \"text\" }],\n            angle: [p.AngleSpec, 0],\n            x_offset: [p.NumberSpec, 0],\n            y_offset: [p.NumberSpec, 0],\n        });\n    }\n}\nText.__name__ = \"Text\";\nText.init_Text();\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}