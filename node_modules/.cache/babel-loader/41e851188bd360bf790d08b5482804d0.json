{"ast":null,"code":"import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { angle_between } from \"../../core/util/math\";\nexport class AnnularWedgeView extends XYGlyphView {\n  _map_data() {\n    if (this.model.properties.inner_radius.units == \"data\") this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);else this.sinner_radius = this._inner_radius;\n    if (this.model.properties.outer_radius.units == \"data\") this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);else this.souter_radius = this._outer_radius;\n    this._angle = new Float32Array(this._start_angle.length);\n\n    for (let i = 0, end = this._start_angle.length; i < end; i++) {\n      this._angle[i] = this._end_angle[i] - this._start_angle[i];\n    }\n  }\n\n  _render(ctx, indices, {\n    sx,\n    sy,\n    _start_angle,\n    _angle,\n    sinner_radius,\n    souter_radius\n  }) {\n    const direction = this.model.properties.direction.value();\n\n    for (const i of indices) {\n      if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i])) continue;\n      ctx.translate(sx[i], sy[i]);\n      ctx.rotate(_start_angle[i]);\n      ctx.moveTo(souter_radius[i], 0);\n      ctx.beginPath();\n      ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\n      ctx.rotate(_angle[i]);\n      ctx.lineTo(sinner_radius[i], 0);\n      ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\n      ctx.closePath();\n      ctx.rotate(-_angle[i] - _start_angle[i]);\n      ctx.translate(-sx[i], -sy[i]);\n\n      if (this.visuals.fill.doit) {\n        this.visuals.fill.set_vectorize(ctx, i);\n        ctx.fill();\n      }\n\n      if (this.visuals.line.doit) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.stroke();\n      }\n    }\n  }\n\n  _hit_point(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const x = this.renderer.xscale.invert(sx);\n    const y = this.renderer.yscale.invert(sy); // check radius first\n\n    let x0, y0;\n    let x1, y1;\n\n    if (this.model.properties.outer_radius.units == \"data\") {\n      x0 = x - this.max_outer_radius;\n      x1 = x + this.max_outer_radius;\n      y0 = y - this.max_outer_radius;\n      y1 = y + this.max_outer_radius;\n    } else {\n      const sx0 = sx - this.max_outer_radius;\n      const sx1 = sx + this.max_outer_radius;\n      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n      const sy0 = sy - this.max_outer_radius;\n      const sy1 = sy + this.max_outer_radius;\n      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n    }\n\n    const candidates = [];\n\n    for (const i of this.index.indices({\n      x0,\n      x1,\n      y0,\n      y1\n    })) {\n      const or2 = this.souter_radius[i] ** 2;\n      const ir2 = this.sinner_radius[i] ** 2;\n      const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n      const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n      const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n      if (dist <= or2 && dist >= ir2) candidates.push([i, dist]);\n    }\n\n    const direction = this.model.properties.direction.value();\n    const hits = [];\n\n    for (const [i, dist] of candidates) {\n      // NOTE: minus the angle because JS uses non-mathy convention for angles\n      const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n\n      if (angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n        hits.push([i, dist]);\n      }\n    }\n\n    return hittest.create_hit_test_result_from_hits(hits);\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_area_legend(this.visuals, ctx, bbox, index);\n  }\n\n  _scenterxy(i) {\n    const r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\n    const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n    return {\n      x: this.sx[i] + r * Math.cos(a),\n      y: this.sy[i] + r * Math.sin(a)\n    };\n  }\n\n  scenterx(i) {\n    return this._scenterxy(i).x;\n  }\n\n  scentery(i) {\n    return this._scenterxy(i).y;\n  }\n\n}\nAnnularWedgeView.__name__ = \"AnnularWedgeView\";\nexport class AnnularWedge extends XYGlyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_AnnularWedge() {\n    this.prototype.default_view = AnnularWedgeView;\n    this.mixins(['line', 'fill']);\n    this.define({\n      direction: [p.Direction, 'anticlock'],\n      inner_radius: [p.DistanceSpec],\n      outer_radius: [p.DistanceSpec],\n      start_angle: [p.AngleSpec],\n      end_angle: [p.AngleSpec]\n    });\n  }\n\n}\nAnnularWedge.__name__ = \"AnnularWedge\";\nAnnularWedge.init_AnnularWedge();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/annular_wedge.js"],"names":["XYGlyph","XYGlyphView","generic_area_legend","hittest","p","angle_between","AnnularWedgeView","_map_data","model","properties","inner_radius","units","sinner_radius","sdist","renderer","xscale","_x","_inner_radius","outer_radius","souter_radius","_outer_radius","_angle","Float32Array","_start_angle","length","i","end","_end_angle","_render","ctx","indices","sx","sy","direction","value","isNaN","translate","rotate","moveTo","beginPath","arc","lineTo","closePath","visuals","fill","doit","set_vectorize","line","stroke","_hit_point","geometry","x","invert","y","yscale","x0","y0","x1","y1","max_outer_radius","sx0","sx1","r_invert","sy0","sy1","candidates","index","or2","ir2","r_compute","_y","dist","push","hits","angle","Math","atan2","create_hit_test_result_from_hits","draw_legend_for_index","bbox","_scenterxy","r","a","cos","sin","scenterx","scentery","__name__","AnnularWedge","constructor","attrs","init_AnnularWedge","prototype","default_view","mixins","define","Direction","DistanceSpec","start_angle","AngleSpec","end_angle"],"mappings":"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","sourcesContent":["import { XYGlyph, XYGlyphView } from \"./xy_glyph\";\nimport { generic_area_legend } from \"./utils\";\nimport * as hittest from \"../../core/hittest\";\nimport * as p from \"../../core/properties\";\nimport { angle_between } from \"../../core/util/math\";\nexport class AnnularWedgeView extends XYGlyphView {\n    _map_data() {\n        if (this.model.properties.inner_radius.units == \"data\")\n            this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\n        else\n            this.sinner_radius = this._inner_radius;\n        if (this.model.properties.outer_radius.units == \"data\")\n            this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\n        else\n            this.souter_radius = this._outer_radius;\n        this._angle = new Float32Array(this._start_angle.length);\n        for (let i = 0, end = this._start_angle.length; i < end; i++) {\n            this._angle[i] = this._end_angle[i] - this._start_angle[i];\n        }\n    }\n    _render(ctx, indices, { sx, sy, _start_angle, _angle, sinner_radius, souter_radius }) {\n        const direction = this.model.properties.direction.value();\n        for (const i of indices) {\n            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i]))\n                continue;\n            ctx.translate(sx[i], sy[i]);\n            ctx.rotate(_start_angle[i]);\n            ctx.moveTo(souter_radius[i], 0);\n            ctx.beginPath();\n            ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\n            ctx.rotate(_angle[i]);\n            ctx.lineTo(sinner_radius[i], 0);\n            ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\n            ctx.closePath();\n            ctx.rotate(-_angle[i] - _start_angle[i]);\n            ctx.translate(-sx[i], -sy[i]);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n        }\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        // check radius first\n        let x0, y0;\n        let x1, y1;\n        if (this.model.properties.outer_radius.units == \"data\") {\n            x0 = x - this.max_outer_radius;\n            x1 = x + this.max_outer_radius;\n            y0 = y - this.max_outer_radius;\n            y1 = y + this.max_outer_radius;\n        }\n        else {\n            const sx0 = sx - this.max_outer_radius;\n            const sx1 = sx + this.max_outer_radius;\n            [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const sy0 = sy - this.max_outer_radius;\n            const sy1 = sy + this.max_outer_radius;\n            [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n        }\n        const candidates = [];\n        for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n            const or2 = this.souter_radius[i] ** 2;\n            const ir2 = this.sinner_radius[i] ** 2;\n            const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n            const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n            const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\n            if (dist <= or2 && dist >= ir2)\n                candidates.push([i, dist]);\n        }\n        const direction = this.model.properties.direction.value();\n        const hits = [];\n        for (const [i, dist] of candidates) {\n            // NOTE: minus the angle because JS uses non-mathy convention for angles\n            const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_hit_test_result_from_hits(hits);\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_area_legend(this.visuals, ctx, bbox, index);\n    }\n    _scenterxy(i) {\n        const r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\n        const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n        return { x: this.sx[i] + (r * Math.cos(a)), y: this.sy[i] + (r * Math.sin(a)) };\n    }\n    scenterx(i) {\n        return this._scenterxy(i).x;\n    }\n    scentery(i) {\n        return this._scenterxy(i).y;\n    }\n}\nAnnularWedgeView.__name__ = \"AnnularWedgeView\";\nexport class AnnularWedge extends XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_AnnularWedge() {\n        this.prototype.default_view = AnnularWedgeView;\n        this.mixins(['line', 'fill']);\n        this.define({\n            direction: [p.Direction, 'anticlock'],\n            inner_radius: [p.DistanceSpec],\n            outer_radius: [p.DistanceSpec],\n            start_angle: [p.AngleSpec],\n            end_angle: [p.AngleSpec],\n        });\n    }\n}\nAnnularWedge.__name__ = \"AnnularWedge\";\nAnnularWedge.init_AnnularWedge();\n//# sourceMappingURL=annular_wedge.js.map"]},"metadata":{},"sourceType":"module"}