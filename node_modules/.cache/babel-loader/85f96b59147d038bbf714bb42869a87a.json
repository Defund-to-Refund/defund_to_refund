{"ast":null,"code":"import { Ticker } from \"./ticker\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { isStrictNaN } from \"../../core/util/types\";\nexport class ContinuousTicker extends Ticker {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_ContinuousTicker() {\n    this.define({\n      num_minor_ticks: [p.Number, 5],\n      desired_num_ticks: [p.Number, 6]\n    });\n  }\n\n  get_ticks(data_low, data_high, _range, cross_loc, _) {\n    return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\n  } // The version of get_ticks() that does the work (and the version that\n  // should be overridden in subclasses).\n\n\n  get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n    const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n    const start_factor = Math.floor(data_low / interval);\n    const end_factor = Math.ceil(data_high / interval);\n    let factors;\n    if (isStrictNaN(start_factor) || isStrictNaN(end_factor)) factors = [];else factors = range(start_factor, end_factor + 1);\n    const ticks = factors.map(factor => factor * interval).filter(tick => data_low <= tick && tick <= data_high);\n    const num_minor_ticks = this.num_minor_ticks;\n    const minor_ticks = [];\n\n    if (num_minor_ticks > 0 && ticks.length > 0) {\n      const minor_interval = interval / num_minor_ticks;\n      const minor_offsets = range(0, num_minor_ticks).map(i => i * minor_interval);\n\n      for (const x of minor_offsets.slice(1)) {\n        const mt = ticks[0] - x;\n\n        if (data_low <= mt && mt <= data_high) {\n          minor_ticks.push(mt);\n        }\n      }\n\n      for (const tick of ticks) {\n        for (const x of minor_offsets) {\n          const mt = tick + x;\n\n          if (data_low <= mt && mt <= data_high) {\n            minor_ticks.push(mt);\n          }\n        }\n      }\n    }\n\n    return {\n      major: ticks,\n      minor: minor_ticks\n    };\n  } // Returns the smallest interval that can be returned by get_interval().\n\n\n  get_min_interval() {\n    return this.min_interval;\n  } // Returns the largest interval that can be returned by get_interval().\n\n\n  get_max_interval() {\n    return this.max_interval != null ? this.max_interval : Infinity;\n  } // Returns the interval size that would produce exactly the number of\n  // desired ticks.  (In general we won't use exactly this interval, because\n  // we want the ticks to be round numbers.)\n\n\n  get_ideal_interval(data_low, data_high, desired_n_ticks) {\n    const data_range = data_high - data_low;\n    return data_range / desired_n_ticks;\n  }\n\n}\nContinuousTicker.__name__ = \"ContinuousTicker\";\nContinuousTicker.init_ContinuousTicker();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/continuous_ticker.js"],"names":["Ticker","p","range","isStrictNaN","ContinuousTicker","constructor","attrs","init_ContinuousTicker","define","num_minor_ticks","Number","desired_num_ticks","get_ticks","data_low","data_high","_range","cross_loc","_","get_ticks_no_defaults","_cross_loc","desired_n_ticks","interval","get_interval","start_factor","Math","floor","end_factor","ceil","factors","ticks","map","factor","filter","tick","minor_ticks","length","minor_interval","minor_offsets","i","x","slice","mt","push","major","minor","get_min_interval","min_interval","get_max_interval","max_interval","Infinity","get_ideal_interval","data_range","__name__"],"mappings":"AAAA,SAASA,MAAT,QAAuB,UAAvB;AACA,OAAO,KAAKC,CAAZ,MAAmB,uBAAnB;AACA,SAASC,KAAT,QAAsB,uBAAtB;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,OAAO,MAAMC,gBAAN,SAA+BJ,MAA/B,CAAsC;AACzCK,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACH;;AACD,SAAOC,qBAAP,GAA+B;AAC3B,SAAKC,MAAL,CAAY;AACRC,MAAAA,eAAe,EAAE,CAACR,CAAC,CAACS,MAAH,EAAW,CAAX,CADT;AAERC,MAAAA,iBAAiB,EAAE,CAACV,CAAC,CAACS,MAAH,EAAW,CAAX;AAFX,KAAZ;AAIH;;AACDE,EAAAA,SAAS,CAACC,QAAD,EAAWC,SAAX,EAAsBC,MAAtB,EAA8BC,SAA9B,EAAyCC,CAAzC,EAA4C;AACjD,WAAO,KAAKC,qBAAL,CAA2BL,QAA3B,EAAqCC,SAArC,EAAgDE,SAAhD,EAA2D,KAAKL,iBAAhE,CAAP;AACH,GAZwC,CAazC;AACA;;;AACAO,EAAAA,qBAAqB,CAACL,QAAD,EAAWC,SAAX,EAAsBK,UAAtB,EAAkCC,eAAlC,EAAmD;AACpE,UAAMC,QAAQ,GAAG,KAAKC,YAAL,CAAkBT,QAAlB,EAA4BC,SAA5B,EAAuCM,eAAvC,CAAjB;AACA,UAAMG,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWZ,QAAQ,GAAGQ,QAAtB,CAArB;AACA,UAAMK,UAAU,GAAGF,IAAI,CAACG,IAAL,CAAUb,SAAS,GAAGO,QAAtB,CAAnB;AACA,QAAIO,OAAJ;AACA,QAAIzB,WAAW,CAACoB,YAAD,CAAX,IAA6BpB,WAAW,CAACuB,UAAD,CAA5C,EACIE,OAAO,GAAG,EAAV,CADJ,KAGIA,OAAO,GAAG1B,KAAK,CAACqB,YAAD,EAAeG,UAAU,GAAG,CAA5B,CAAf;AACJ,UAAMG,KAAK,GAAGD,OAAO,CAChBE,GADS,CACJC,MAAD,IAAYA,MAAM,GAAGV,QADhB,EAETW,MAFS,CAEDC,IAAD,IAAUpB,QAAQ,IAAIoB,IAAZ,IAAoBA,IAAI,IAAInB,SAFpC,CAAd;AAGA,UAAML,eAAe,GAAG,KAAKA,eAA7B;AACA,UAAMyB,WAAW,GAAG,EAApB;;AACA,QAAIzB,eAAe,GAAG,CAAlB,IAAuBoB,KAAK,CAACM,MAAN,GAAe,CAA1C,EAA6C;AACzC,YAAMC,cAAc,GAAGf,QAAQ,GAAGZ,eAAlC;AACA,YAAM4B,aAAa,GAAGnC,KAAK,CAAC,CAAD,EAAIO,eAAJ,CAAL,CAA0BqB,GAA1B,CAA+BQ,CAAD,IAAOA,CAAC,GAAGF,cAAzC,CAAtB;;AACA,WAAK,MAAMG,CAAX,IAAgBF,aAAa,CAACG,KAAd,CAAoB,CAApB,CAAhB,EAAwC;AACpC,cAAMC,EAAE,GAAGZ,KAAK,CAAC,CAAD,CAAL,GAAWU,CAAtB;;AACA,YAAI1B,QAAQ,IAAI4B,EAAZ,IAAkBA,EAAE,IAAI3B,SAA5B,EAAuC;AACnCoB,UAAAA,WAAW,CAACQ,IAAZ,CAAiBD,EAAjB;AACH;AACJ;;AACD,WAAK,MAAMR,IAAX,IAAmBJ,KAAnB,EAA0B;AACtB,aAAK,MAAMU,CAAX,IAAgBF,aAAhB,EAA+B;AAC3B,gBAAMI,EAAE,GAAGR,IAAI,GAAGM,CAAlB;;AACA,cAAI1B,QAAQ,IAAI4B,EAAZ,IAAkBA,EAAE,IAAI3B,SAA5B,EAAuC;AACnCoB,YAAAA,WAAW,CAACQ,IAAZ,CAAiBD,EAAjB;AACH;AACJ;AACJ;AACJ;;AACD,WAAO;AACHE,MAAAA,KAAK,EAAEd,KADJ;AAEHe,MAAAA,KAAK,EAAEV;AAFJ,KAAP;AAIH,GAnDwC,CAoDzC;;;AACAW,EAAAA,gBAAgB,GAAG;AACf,WAAO,KAAKC,YAAZ;AACH,GAvDwC,CAwDzC;;;AACAC,EAAAA,gBAAgB,GAAG;AACf,WAAO,KAAKC,YAAL,IAAqB,IAArB,GAA4B,KAAKA,YAAjC,GAAgDC,QAAvD;AACH,GA3DwC,CA4DzC;AACA;AACA;;;AACAC,EAAAA,kBAAkB,CAACrC,QAAD,EAAWC,SAAX,EAAsBM,eAAtB,EAAuC;AACrD,UAAM+B,UAAU,GAAGrC,SAAS,GAAGD,QAA/B;AACA,WAAOsC,UAAU,GAAG/B,eAApB;AACH;;AAlEwC;AAoE7ChB,gBAAgB,CAACgD,QAAjB,GAA4B,kBAA5B;AACAhD,gBAAgB,CAACG,qBAAjB","sourcesContent":["import { Ticker } from \"./ticker\";\nimport * as p from \"../../core/properties\";\nimport { range } from \"../../core/util/array\";\nimport { isStrictNaN } from \"../../core/util/types\";\nexport class ContinuousTicker extends Ticker {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ContinuousTicker() {\n        this.define({\n            num_minor_ticks: [p.Number, 5],\n            desired_num_ticks: [p.Number, 6],\n        });\n    }\n    get_ticks(data_low, data_high, _range, cross_loc, _) {\n        return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\n    }\n    // The version of get_ticks() that does the work (and the version that\n    // should be overridden in subclasses).\n    get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n        const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n        const start_factor = Math.floor(data_low / interval);\n        const end_factor = Math.ceil(data_high / interval);\n        let factors;\n        if (isStrictNaN(start_factor) || isStrictNaN(end_factor))\n            factors = [];\n        else\n            factors = range(start_factor, end_factor + 1);\n        const ticks = factors\n            .map((factor) => factor * interval)\n            .filter((tick) => data_low <= tick && tick <= data_high);\n        const num_minor_ticks = this.num_minor_ticks;\n        const minor_ticks = [];\n        if (num_minor_ticks > 0 && ticks.length > 0) {\n            const minor_interval = interval / num_minor_ticks;\n            const minor_offsets = range(0, num_minor_ticks).map((i) => i * minor_interval);\n            for (const x of minor_offsets.slice(1)) {\n                const mt = ticks[0] - x;\n                if (data_low <= mt && mt <= data_high) {\n                    minor_ticks.push(mt);\n                }\n            }\n            for (const tick of ticks) {\n                for (const x of minor_offsets) {\n                    const mt = tick + x;\n                    if (data_low <= mt && mt <= data_high) {\n                        minor_ticks.push(mt);\n                    }\n                }\n            }\n        }\n        return {\n            major: ticks,\n            minor: minor_ticks,\n        };\n    }\n    // Returns the smallest interval that can be returned by get_interval().\n    get_min_interval() {\n        return this.min_interval;\n    }\n    // Returns the largest interval that can be returned by get_interval().\n    get_max_interval() {\n        return this.max_interval != null ? this.max_interval : Infinity;\n    }\n    // Returns the interval size that would produce exactly the number of\n    // desired ticks.  (In general we won't use exactly this interval, because\n    // we want the ticks to be round numbers.)\n    get_ideal_interval(data_low, data_high, desired_n_ticks) {\n        const data_range = data_high - data_low;\n        return data_range / desired_n_ticks;\n    }\n}\nContinuousTicker.__name__ = \"ContinuousTicker\";\nContinuousTicker.init_ContinuousTicker();\n//# sourceMappingURL=continuous_ticker.js.map"]},"metadata":{},"sourceType":"module"}