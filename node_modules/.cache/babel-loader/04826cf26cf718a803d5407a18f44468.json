{"ast":null,"code":"import { DataRange } from \"./data_range\";\nimport { GlyphRenderer } from \"../renderers/glyph_renderer\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport * as bbox from \"../../core/util/bbox\";\nimport { includes } from \"../../core/util/array\";\nexport class DataRange1d extends DataRange {\n  constructor(attrs) {\n    super(attrs);\n    this._plot_bounds = {};\n    this.have_updated_interactively = false;\n  }\n\n  static init_DataRange1d() {\n    this.define({\n      start: [p.Number],\n      end: [p.Number],\n      range_padding: [p.Number, 0.1],\n      range_padding_units: [p.PaddingUnits, \"percent\"],\n      flipped: [p.Boolean, false],\n      follow: [p.StartEnd],\n      follow_interval: [p.Number],\n      default_span: [p.Number, 2],\n      only_visible: [p.Boolean, false]\n    });\n    this.internal({\n      scale_hint: [p.String, 'auto']\n    });\n  }\n\n  initialize() {\n    super.initialize();\n    this._initial_start = this.start;\n    this._initial_end = this.end;\n    this._initial_range_padding = this.range_padding;\n    this._initial_range_padding_units = this.range_padding_units;\n    this._initial_follow = this.follow;\n    this._initial_follow_interval = this.follow_interval;\n    this._initial_default_span = this.default_span;\n  }\n\n  get min() {\n    return Math.min(this.start, this.end);\n  }\n\n  get max() {\n    return Math.max(this.start, this.end);\n  }\n\n  computed_renderers() {\n    // TODO (bev) check that renderers actually configured with this range\n    const names = this.names;\n    let renderers = this.renderers;\n\n    if (renderers.length == 0) {\n      for (const plot of this.plots) {\n        const rs = plot.renderers.filter(r => r instanceof GlyphRenderer);\n        renderers = renderers.concat(rs);\n      }\n    }\n\n    if (names.length > 0) renderers = renderers.filter(r => includes(names, r.name));\n    logger.debug(`computed ${renderers.length} renderers for DataRange1d ${this.id}`);\n\n    for (const r of renderers) {\n      logger.trace(` - ${r.type} ${r.id}`);\n    }\n\n    return renderers;\n  }\n  /*protected*/\n\n\n  _compute_plot_bounds(renderers, bounds) {\n    let result = bbox.empty();\n\n    for (const r of renderers) {\n      if (bounds[r.id] != null && (r.visible || !this.only_visible)) result = bbox.union(result, bounds[r.id]);\n    }\n\n    return result;\n  }\n\n  adjust_bounds_for_aspect(bounds, ratio) {\n    const result = bbox.empty();\n    let width = bounds.x1 - bounds.x0;\n\n    if (width <= 0) {\n      width = 1.0;\n    }\n\n    let height = bounds.y1 - bounds.y0;\n\n    if (height <= 0) {\n      height = 1.0;\n    }\n\n    const xcenter = 0.5 * (bounds.x1 + bounds.x0);\n    const ycenter = 0.5 * (bounds.y1 + bounds.y0);\n\n    if (width < ratio * height) {\n      width = ratio * height;\n    } else {\n      height = width / ratio;\n    }\n\n    result.x1 = xcenter + 0.5 * width;\n    result.x0 = xcenter - 0.5 * width;\n    result.y1 = ycenter + 0.5 * height;\n    result.y0 = ycenter - 0.5 * height;\n    return result;\n  }\n  /*protected*/\n\n\n  _compute_min_max(plot_bounds, dimension) {\n    let overall = bbox.empty();\n\n    for (const k in plot_bounds) {\n      const v = plot_bounds[k];\n      overall = bbox.union(overall, v);\n    }\n\n    let min, max;\n    if (dimension == 0) [min, max] = [overall.x0, overall.x1];else [min, max] = [overall.y0, overall.y1];\n    return [min, max];\n  }\n  /*protected*/\n\n\n  _compute_range(min, max) {\n    const range_padding = this.range_padding; // XXX: ? 0\n\n    let start, end;\n    if (this._initial_start != null) min = this._initial_start;\n    if (this._initial_end != null) max = this._initial_end;\n\n    if (this.scale_hint == \"log\") {\n      if (isNaN(min) || !isFinite(min) || min <= 0) {\n        if (isNaN(max) || !isFinite(max) || max <= 0) min = 0.1;else min = max / 100;\n        logger.warn(`could not determine minimum data value for log axis, DataRange1d using value ${min}`);\n      }\n\n      if (isNaN(max) || !isFinite(max) || max <= 0) {\n        if (isNaN(min) || !isFinite(min) || min <= 0) max = 10;else max = min * 100;\n        logger.warn(`could not determine maximum data value for log axis, DataRange1d using value ${max}`);\n      }\n\n      let center, span;\n\n      if (max == min) {\n        span = this.default_span + 0.001;\n        center = Math.log(min) / Math.log(10);\n      } else {\n        let log_min, log_max;\n\n        if (this.range_padding_units == \"percent\") {\n          log_min = Math.log(min) / Math.log(10);\n          log_max = Math.log(max) / Math.log(10);\n          span = (log_max - log_min) * (1 + range_padding);\n        } else {\n          log_min = Math.log(min - range_padding) / Math.log(10);\n          log_max = Math.log(max + range_padding) / Math.log(10);\n          span = log_max - log_min;\n        }\n\n        center = (log_min + log_max) / 2.0;\n      }\n\n      start = 10 ** (center - span / 2.0);\n      end = 10 ** (center + span / 2.0);\n    } else {\n      let span;\n      if (max == min) span = this.default_span;else {\n        if (this.range_padding_units == \"percent\") span = (max - min) * (1 + range_padding);else span = max - min + 2 * range_padding;\n      }\n      const center = (max + min) / 2.0;\n      start = center - span / 2.0;\n      end = center + span / 2.0;\n    }\n\n    let follow_sign = +1;\n\n    if (this.flipped) {\n      [start, end] = [end, start];\n      follow_sign = -1;\n    }\n\n    const follow_interval = this.follow_interval;\n\n    if (follow_interval != null && Math.abs(start - end) > follow_interval) {\n      if (this.follow == 'start') end = start + follow_sign * follow_interval;else if (this.follow == 'end') start = end - follow_sign * follow_interval;\n    }\n\n    return [start, end];\n  }\n\n  update(bounds, dimension, bounds_id, ratio) {\n    if (this.have_updated_interactively) return;\n    const renderers = this.computed_renderers(); // update the raw data bounds for all renderers we care about\n\n    let total_bounds = this._compute_plot_bounds(renderers, bounds);\n\n    if (ratio != null) total_bounds = this.adjust_bounds_for_aspect(total_bounds, ratio);\n    this._plot_bounds[bounds_id] = total_bounds; // compute the min/mix for our specified dimension\n\n    const [min, max] = this._compute_min_max(this._plot_bounds, dimension); // derive start, end from bounds and data range config\n\n\n    let [start, end] = this._compute_range(min, max);\n\n    if (this._initial_start != null) {\n      if (this.scale_hint == \"log\") {\n        if (this._initial_start > 0) start = this._initial_start;\n      } else start = this._initial_start;\n    }\n\n    if (this._initial_end != null) {\n      if (this.scale_hint == \"log\") {\n        if (this._initial_end > 0) end = this._initial_end;\n      } else end = this._initial_end;\n    } // only trigger updates when there are changes\n\n\n    const [_start, _end] = [this.start, this.end];\n\n    if (start != _start || end != _end) {\n      const new_range = {};\n      if (start != _start) new_range.start = start;\n      if (end != _end) new_range.end = end;\n      this.setv(new_range);\n    }\n\n    if (this.bounds == 'auto') this.setv({\n      bounds: [start, end]\n    }, {\n      silent: true\n    });\n    this.change.emit();\n  }\n\n  reset() {\n    this.have_updated_interactively = false; // change events silenced as PlotView.update_dataranges triggers property callbacks\n\n    this.setv({\n      range_padding: this._initial_range_padding,\n      range_padding_units: this._initial_range_padding_units,\n      follow: this._initial_follow,\n      follow_interval: this._initial_follow_interval,\n      default_span: this._initial_default_span\n    }, {\n      silent: true\n    });\n    this.change.emit();\n  }\n\n}\nDataRange1d.__name__ = \"DataRange1d\";\nDataRange1d.init_DataRange1d();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/data_range1d.js"],"names":["DataRange","GlyphRenderer","logger","p","bbox","includes","DataRange1d","constructor","attrs","_plot_bounds","have_updated_interactively","init_DataRange1d","define","start","Number","end","range_padding","range_padding_units","PaddingUnits","flipped","Boolean","follow","StartEnd","follow_interval","default_span","only_visible","internal","scale_hint","String","initialize","_initial_start","_initial_end","_initial_range_padding","_initial_range_padding_units","_initial_follow","_initial_follow_interval","_initial_default_span","min","Math","max","computed_renderers","names","renderers","length","plot","plots","rs","filter","r","concat","name","debug","id","trace","type","_compute_plot_bounds","bounds","result","empty","visible","union","adjust_bounds_for_aspect","ratio","width","x1","x0","height","y1","y0","xcenter","ycenter","_compute_min_max","plot_bounds","dimension","overall","k","v","_compute_range","isNaN","isFinite","warn","center","span","log","log_min","log_max","follow_sign","abs","update","bounds_id","total_bounds","_start","_end","new_range","setv","silent","change","emit","reset","__name__"],"mappings":"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","sourcesContent":["import { DataRange } from \"./data_range\";\nimport { GlyphRenderer } from \"../renderers/glyph_renderer\";\nimport { logger } from \"../../core/logging\";\nimport * as p from \"../../core/properties\";\nimport * as bbox from \"../../core/util/bbox\";\nimport { includes } from \"../../core/util/array\";\nexport class DataRange1d extends DataRange {\n    constructor(attrs) {\n        super(attrs);\n        this._plot_bounds = {};\n        this.have_updated_interactively = false;\n    }\n    static init_DataRange1d() {\n        this.define({\n            start: [p.Number],\n            end: [p.Number],\n            range_padding: [p.Number, 0.1],\n            range_padding_units: [p.PaddingUnits, \"percent\"],\n            flipped: [p.Boolean, false],\n            follow: [p.StartEnd],\n            follow_interval: [p.Number],\n            default_span: [p.Number, 2],\n            only_visible: [p.Boolean, false],\n        });\n        this.internal({\n            scale_hint: [p.String, 'auto'],\n        });\n    }\n    initialize() {\n        super.initialize();\n        this._initial_start = this.start;\n        this._initial_end = this.end;\n        this._initial_range_padding = this.range_padding;\n        this._initial_range_padding_units = this.range_padding_units;\n        this._initial_follow = this.follow;\n        this._initial_follow_interval = this.follow_interval;\n        this._initial_default_span = this.default_span;\n    }\n    get min() {\n        return Math.min(this.start, this.end);\n    }\n    get max() {\n        return Math.max(this.start, this.end);\n    }\n    computed_renderers() {\n        // TODO (bev) check that renderers actually configured with this range\n        const names = this.names;\n        let renderers = this.renderers;\n        if (renderers.length == 0) {\n            for (const plot of this.plots) {\n                const rs = plot.renderers.filter((r) => r instanceof GlyphRenderer);\n                renderers = renderers.concat(rs);\n            }\n        }\n        if (names.length > 0)\n            renderers = renderers.filter((r) => includes(names, r.name));\n        logger.debug(`computed ${renderers.length} renderers for DataRange1d ${this.id}`);\n        for (const r of renderers) {\n            logger.trace(` - ${r.type} ${r.id}`);\n        }\n        return renderers;\n    }\n    /*protected*/ _compute_plot_bounds(renderers, bounds) {\n        let result = bbox.empty();\n        for (const r of renderers) {\n            if (bounds[r.id] != null && (r.visible || !this.only_visible))\n                result = bbox.union(result, bounds[r.id]);\n        }\n        return result;\n    }\n    adjust_bounds_for_aspect(bounds, ratio) {\n        const result = bbox.empty();\n        let width = bounds.x1 - bounds.x0;\n        if (width <= 0) {\n            width = 1.0;\n        }\n        let height = bounds.y1 - bounds.y0;\n        if (height <= 0) {\n            height = 1.0;\n        }\n        const xcenter = 0.5 * (bounds.x1 + bounds.x0);\n        const ycenter = 0.5 * (bounds.y1 + bounds.y0);\n        if (width < ratio * height) {\n            width = ratio * height;\n        }\n        else {\n            height = width / ratio;\n        }\n        result.x1 = xcenter + 0.5 * width;\n        result.x0 = xcenter - 0.5 * width;\n        result.y1 = ycenter + 0.5 * height;\n        result.y0 = ycenter - 0.5 * height;\n        return result;\n    }\n    /*protected*/ _compute_min_max(plot_bounds, dimension) {\n        let overall = bbox.empty();\n        for (const k in plot_bounds) {\n            const v = plot_bounds[k];\n            overall = bbox.union(overall, v);\n        }\n        let min, max;\n        if (dimension == 0)\n            [min, max] = [overall.x0, overall.x1];\n        else\n            [min, max] = [overall.y0, overall.y1];\n        return [min, max];\n    }\n    /*protected*/ _compute_range(min, max) {\n        const range_padding = this.range_padding; // XXX: ? 0\n        let start, end;\n        if (this._initial_start != null)\n            min = this._initial_start;\n        if (this._initial_end != null)\n            max = this._initial_end;\n        if (this.scale_hint == \"log\") {\n            if (isNaN(min) || !isFinite(min) || min <= 0) {\n                if (isNaN(max) || !isFinite(max) || max <= 0)\n                    min = 0.1;\n                else\n                    min = max / 100;\n                logger.warn(`could not determine minimum data value for log axis, DataRange1d using value ${min}`);\n            }\n            if (isNaN(max) || !isFinite(max) || max <= 0) {\n                if (isNaN(min) || !isFinite(min) || min <= 0)\n                    max = 10;\n                else\n                    max = min * 100;\n                logger.warn(`could not determine maximum data value for log axis, DataRange1d using value ${max}`);\n            }\n            let center, span;\n            if (max == min) {\n                span = this.default_span + 0.001;\n                center = Math.log(min) / Math.log(10);\n            }\n            else {\n                let log_min, log_max;\n                if (this.range_padding_units == \"percent\") {\n                    log_min = Math.log(min) / Math.log(10);\n                    log_max = Math.log(max) / Math.log(10);\n                    span = (log_max - log_min) * (1 + range_padding);\n                }\n                else {\n                    log_min = Math.log(min - range_padding) / Math.log(10);\n                    log_max = Math.log(max + range_padding) / Math.log(10);\n                    span = log_max - log_min;\n                }\n                center = (log_min + log_max) / 2.0;\n            }\n            start = 10 ** (center - span / 2.0);\n            end = 10 ** (center + span / 2.0);\n        }\n        else {\n            let span;\n            if (max == min)\n                span = this.default_span;\n            else {\n                if (this.range_padding_units == \"percent\")\n                    span = (max - min) * (1 + range_padding);\n                else\n                    span = (max - min) + 2 * range_padding;\n            }\n            const center = (max + min) / 2.0;\n            start = center - span / 2.0;\n            end = center + span / 2.0;\n        }\n        let follow_sign = +1;\n        if (this.flipped) {\n            [start, end] = [end, start];\n            follow_sign = -1;\n        }\n        const follow_interval = this.follow_interval;\n        if (follow_interval != null && Math.abs(start - end) > follow_interval) {\n            if (this.follow == 'start')\n                end = start + follow_sign * follow_interval;\n            else if (this.follow == 'end')\n                start = end - follow_sign * follow_interval;\n        }\n        return [start, end];\n    }\n    update(bounds, dimension, bounds_id, ratio) {\n        if (this.have_updated_interactively)\n            return;\n        const renderers = this.computed_renderers();\n        // update the raw data bounds for all renderers we care about\n        let total_bounds = this._compute_plot_bounds(renderers, bounds);\n        if (ratio != null)\n            total_bounds = this.adjust_bounds_for_aspect(total_bounds, ratio);\n        this._plot_bounds[bounds_id] = total_bounds;\n        // compute the min/mix for our specified dimension\n        const [min, max] = this._compute_min_max(this._plot_bounds, dimension);\n        // derive start, end from bounds and data range config\n        let [start, end] = this._compute_range(min, max);\n        if (this._initial_start != null) {\n            if (this.scale_hint == \"log\") {\n                if (this._initial_start > 0)\n                    start = this._initial_start;\n            }\n            else\n                start = this._initial_start;\n        }\n        if (this._initial_end != null) {\n            if (this.scale_hint == \"log\") {\n                if (this._initial_end > 0)\n                    end = this._initial_end;\n            }\n            else\n                end = this._initial_end;\n        }\n        // only trigger updates when there are changes\n        const [_start, _end] = [this.start, this.end];\n        if (start != _start || end != _end) {\n            const new_range = {};\n            if (start != _start)\n                new_range.start = start;\n            if (end != _end)\n                new_range.end = end;\n            this.setv(new_range);\n        }\n        if (this.bounds == 'auto')\n            this.setv({ bounds: [start, end] }, { silent: true });\n        this.change.emit();\n    }\n    reset() {\n        this.have_updated_interactively = false;\n        // change events silenced as PlotView.update_dataranges triggers property callbacks\n        this.setv({\n            range_padding: this._initial_range_padding,\n            range_padding_units: this._initial_range_padding_units,\n            follow: this._initial_follow,\n            follow_interval: this._initial_follow_interval,\n            default_span: this._initial_default_span,\n        }, { silent: true });\n        this.change.emit();\n    }\n}\nDataRange1d.__name__ = \"DataRange1d\";\nDataRange1d.init_DataRange1d();\n//# sourceMappingURL=data_range1d.js.map"]},"metadata":{},"sourceType":"module"}