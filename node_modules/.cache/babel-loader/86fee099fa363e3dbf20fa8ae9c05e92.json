{"ast":null,"code":"import { color2rgba } from \"../../../core/util/color\";\nimport { logger } from \"../../../core/logging\";\nexport class BaseGLGlyph {\n  constructor(gl, glyph) {\n    this.gl = gl;\n    this.glyph = glyph;\n    this.nvertices = 0;\n    this.size_changed = false;\n    this.data_changed = false;\n    this.visuals_changed = false;\n    this.init();\n  }\n\n  set_data_changed(n) {\n    if (n != this.nvertices) {\n      this.nvertices = n;\n      this.size_changed = true;\n    }\n\n    this.data_changed = true;\n  }\n\n  set_visuals_changed() {\n    this.visuals_changed = true;\n  }\n\n  render(_ctx, indices, mainglyph) {\n    if (indices.length == 0) {\n      // Implementations assume at least one index to draw. We return true,\n      // because there is no need to switch back to a fallback renderer.\n      return true;\n    } // Get transform\n\n\n    const [a, b, c] = [0, 1, 2];\n    let wx = 1; // Weights to scale our vectors\n\n    let wy = 1;\n    let [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]);\n\n    if (isNaN(dx[0] + dx[1] + dx[2] + dy[0] + dy[1] + dy[2])) {\n      logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n      return false;\n    } // Try again, but with weighs so we're looking at ~100 in screen coordinates\n\n\n    wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12);\n    wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12);\n    [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]); // Test how linear it is\n\n    if (Math.abs(dx[1] - dx[0] - (dx[2] - dx[1])) > 1e-6 || Math.abs(dy[1] - dy[0] - (dy[2] - dy[1])) > 1e-6) {\n      logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n      return false;\n    }\n\n    const [sx, sy] = [(dx[1] - dx[0]) / wx, (dy[1] - dy[0]) / wy];\n    const {\n      width,\n      height\n    } = this.glyph.renderer.plot_view.canvas_view.webgl.canvas;\n    const trans = {\n      pixel_ratio: this.glyph.renderer.plot_view.canvas.pixel_ratio,\n      width,\n      height,\n      dx: dx[0] / sx,\n      dy: dy[0] / sy,\n      sx,\n      sy\n    };\n    this.draw(indices, mainglyph, trans);\n    return true;\n  }\n\n}\nBaseGLGlyph.__name__ = \"BaseGLGlyph\";\nexport function line_width(width) {\n  // Increase small values to make it more similar to canvas\n  if (width < 2) {\n    width = Math.sqrt(width * 2);\n  }\n\n  return width;\n}\nexport function fill_array_with_float(n, val) {\n  const a = new Float32Array(n);\n\n  for (let i = 0, end = n; i < end; i++) {\n    a[i] = val;\n  }\n\n  return a;\n}\nexport function fill_array_with_vec(n, m, val) {\n  const a = new Float32Array(n * m);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      a[i * m + j] = val[j];\n    }\n  }\n\n  return a;\n}\nexport function visual_prop_is_singular(visual, propname) {\n  // This touches the internals of the visual, so we limit use in this function\n  // See renderer.ts:cache_select() for similar code\n  return visual[propname].spec.value !== undefined;\n}\nexport function attach_float(prog, vbo, att_name, n, visual, name) {\n  // Attach a float attribute to the program. Use singleton value if we can,\n  // otherwise use VBO to apply array.\n  if (!visual.doit) {\n    vbo.used = false;\n    prog.set_attribute(att_name, 'float', [0]);\n  } else if (visual_prop_is_singular(visual, name)) {\n    vbo.used = false;\n    prog.set_attribute(att_name, 'float', visual[name].value());\n  } else {\n    vbo.used = true;\n    const a = new Float32Array(visual.cache[name + '_array']);\n    vbo.set_size(n * 4);\n    vbo.set_data(0, a);\n    prog.set_attribute(att_name, 'float', vbo);\n  }\n}\nexport function attach_color(prog, vbo, att_name, n, visual, prefix) {\n  // Attach the color attribute to the program. If there's just one color,\n  // then use this single color for all vertices (no VBO). Otherwise we\n  // create an array and upload that to the VBO, which we attahce to the prog.\n  let rgba;\n  const m = 4;\n  const colorname = prefix + '_color';\n  const alphaname = prefix + '_alpha';\n\n  if (!visual.doit) {\n    // Don't draw (draw transparent)\n    vbo.used = false;\n    prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\n  } else if (visual_prop_is_singular(visual, colorname) && visual_prop_is_singular(visual, alphaname)) {\n    // Nice and simple; both color and alpha are singular\n    vbo.used = false;\n    rgba = color2rgba(visual[colorname].value(), visual[alphaname].value());\n    prog.set_attribute(att_name, 'vec4', rgba);\n  } else {\n    // Use vbo; we need an array for both the color and the alpha\n    let alphas, colors;\n    vbo.used = true; // Get array of colors\n\n    if (visual_prop_is_singular(visual, colorname)) {\n      colors = (() => {\n        const result = [];\n\n        for (let i = 0, end = n; i < end; i++) {\n          result.push(visual[colorname].value());\n        }\n\n        return result;\n      })();\n    } else {\n      colors = visual.cache[colorname + '_array'];\n    } // Get array of alphas\n\n\n    if (visual_prop_is_singular(visual, alphaname)) {\n      alphas = fill_array_with_float(n, visual[alphaname].value());\n    } else {\n      alphas = visual.cache[alphaname + '_array'];\n    } // Create array of rgbs\n\n\n    const a = new Float32Array(n * m);\n\n    for (let i = 0, end = n; i < end; i++) {\n      rgba = color2rgba(colors[i], alphas[i]);\n\n      for (let j = 0, endj = m; j < endj; j++) {\n        a[i * m + j] = rgba[j];\n      }\n    } // Attach vbo\n\n\n    vbo.set_size(n * m * 4);\n    vbo.set_data(0, a);\n    prog.set_attribute(att_name, 'vec4', vbo);\n  }\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/base.js"],"names":["color2rgba","logger","BaseGLGlyph","constructor","gl","glyph","nvertices","size_changed","data_changed","visuals_changed","init","set_data_changed","n","set_visuals_changed","render","_ctx","indices","mainglyph","length","a","b","c","wx","wy","dx","dy","renderer","map_to_screen","isNaN","warn","model","type","Math","min","max","abs","sx","sy","width","height","plot_view","canvas_view","webgl","canvas","trans","pixel_ratio","draw","__name__","line_width","sqrt","fill_array_with_float","val","Float32Array","i","end","fill_array_with_vec","m","j","visual_prop_is_singular","visual","propname","spec","value","undefined","attach_float","prog","vbo","att_name","name","doit","used","set_attribute","cache","set_size","set_data","attach_color","prefix","rgba","colorname","alphaname","alphas","colors","result","push","endj"],"mappings":"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","sourcesContent":["import { color2rgba } from \"../../../core/util/color\";\nimport { logger } from \"../../../core/logging\";\nexport class BaseGLGlyph {\n    constructor(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    set_data_changed(n) {\n        if (n != this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        this.data_changed = true;\n    }\n    set_visuals_changed() {\n        this.visuals_changed = true;\n    }\n    render(_ctx, indices, mainglyph) {\n        if (indices.length == 0) {\n            // Implementations assume at least one index to draw. We return true,\n            // because there is no need to switch back to a fallback renderer.\n            return true;\n        }\n        // Get transform\n        const [a, b, c] = [0, 1, 2];\n        let wx = 1; // Weights to scale our vectors\n        let wy = 1;\n        let [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]);\n        if (isNaN(dx[0] + dx[1] + dx[2] + dy[0] + dy[1] + dy[2])) {\n            logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n            return false;\n        }\n        // Try again, but with weighs so we're looking at ~100 in screen coordinates\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12);\n        [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]);\n        // Test how linear it is\n        if ((Math.abs((dx[1] - dx[0]) - (dx[2] - dx[1])) > 1e-6) ||\n            (Math.abs((dy[1] - dy[0]) - (dy[2] - dy[1])) > 1e-6)) {\n            logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n            return false;\n        }\n        const [sx, sy] = [(dx[1] - dx[0]) / wx, (dy[1] - dy[0]) / wy];\n        const { width, height } = this.glyph.renderer.plot_view.canvas_view.webgl.canvas;\n        const trans = {\n            pixel_ratio: this.glyph.renderer.plot_view.canvas.pixel_ratio,\n            width, height,\n            dx: dx[0] / sx, dy: dy[0] / sy, sx, sy,\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n    }\n}\nBaseGLGlyph.__name__ = \"BaseGLGlyph\";\nexport function line_width(width) {\n    // Increase small values to make it more similar to canvas\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n}\nexport function fill_array_with_float(n, val) {\n    const a = new Float32Array(n);\n    for (let i = 0, end = n; i < end; i++) {\n        a[i] = val;\n    }\n    return a;\n}\nexport function fill_array_with_vec(n, m, val) {\n    const a = new Float32Array(n * m);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n}\nexport function visual_prop_is_singular(visual, propname) {\n    // This touches the internals of the visual, so we limit use in this function\n    // See renderer.ts:cache_select() for similar code\n    return visual[propname].spec.value !== undefined;\n}\nexport function attach_float(prog, vbo, att_name, n, visual, name) {\n    // Attach a float attribute to the program. Use singleton value if we can,\n    // otherwise use VBO to apply array.\n    if (!visual.doit) {\n        vbo.used = false;\n        prog.set_attribute(att_name, 'float', [0]);\n    }\n    else if (visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        prog.set_attribute(att_name, 'float', visual[name].value());\n    }\n    else {\n        vbo.used = true;\n        const a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        prog.set_attribute(att_name, 'float', vbo);\n    }\n}\nexport function attach_color(prog, vbo, att_name, n, visual, prefix) {\n    // Attach the color attribute to the program. If there's just one color,\n    // then use this single color for all vertices (no VBO). Otherwise we\n    // create an array and upload that to the VBO, which we attahce to the prog.\n    let rgba;\n    const m = 4;\n    const colorname = prefix + '_color';\n    const alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        // Don't draw (draw transparent)\n        vbo.used = false;\n        prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\n    }\n    else if (visual_prop_is_singular(visual, colorname) && visual_prop_is_singular(visual, alphaname)) {\n        // Nice and simple; both color and alpha are singular\n        vbo.used = false;\n        rgba = color2rgba(visual[colorname].value(), visual[alphaname].value());\n        prog.set_attribute(att_name, 'vec4', rgba);\n    }\n    else {\n        // Use vbo; we need an array for both the color and the alpha\n        let alphas, colors;\n        vbo.used = true;\n        // Get array of colors\n        if (visual_prop_is_singular(visual, colorname)) {\n            colors = ((() => {\n                const result = [];\n                for (let i = 0, end = n; i < end; i++) {\n                    result.push(visual[colorname].value());\n                }\n                return result;\n            })());\n        }\n        else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        // Get array of alphas\n        if (visual_prop_is_singular(visual, alphaname)) {\n            alphas = fill_array_with_float(n, visual[alphaname].value());\n        }\n        else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        // Create array of rgbs\n        const a = new Float32Array(n * m);\n        for (let i = 0, end = n; i < end; i++) {\n            rgba = color2rgba(colors[i], alphas[i]);\n            for (let j = 0, endj = m; j < endj; j++) {\n                a[(i * m) + j] = rgba[j];\n            }\n        }\n        // Attach vbo\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        prog.set_attribute(att_name, 'vec4', vbo);\n    }\n}\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}