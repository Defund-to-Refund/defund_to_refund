{"ast":null,"code":"import { SpatialIndex } from \"../../core/util/spatial\";\nimport * as hittest from \"../../core/hittest\";\nimport { keys } from \"../../core/util/object\";\nimport { min, max } from \"../../core/util/array\";\nimport { isStrictNaN } from \"../../core/util/types\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_line_legend, line_interpolation } from \"./utils\";\nexport class MultiLineView extends GlyphView {\n  _index_data() {\n    const points = [];\n\n    for (let i = 0, end = this._xs.length; i < end; i++) {\n      if (this._xs[i] == null || this._xs[i].length === 0) continue;\n      const _xsi = this._xs[i];\n      const xs = [];\n\n      for (let j = 0, n = _xsi.length; j < n; j++) {\n        const x = _xsi[j];\n        if (!isStrictNaN(x)) xs.push(x);\n      }\n\n      const _ysi = this._ys[i];\n      const ys = [];\n\n      for (let j = 0, n = _ysi.length; j < n; j++) {\n        const y = _ysi[j];\n        if (!isStrictNaN(y)) ys.push(y);\n      }\n\n      const [x0, x1] = [min(xs), max(xs)];\n      const [y0, y1] = [min(ys), max(ys)];\n      points.push({\n        x0,\n        y0,\n        x1,\n        y1,\n        i\n      });\n    }\n\n    return new SpatialIndex(points);\n  }\n\n  _render(ctx, indices, {\n    sxs,\n    sys\n  }) {\n    for (const i of indices) {\n      const [sx, sy] = [sxs[i], sys[i]];\n      this.visuals.line.set_vectorize(ctx, i);\n\n      for (let j = 0, end = sx.length; j < end; j++) {\n        if (j == 0) {\n          ctx.beginPath();\n          ctx.moveTo(sx[j], sy[j]);\n          continue;\n        } else if (isNaN(sx[j]) || isNaN(sy[j])) {\n          ctx.stroke();\n          ctx.beginPath();\n          continue;\n        } else ctx.lineTo(sx[j], sy[j]);\n      }\n\n      ctx.stroke();\n    }\n  }\n\n  _hit_point(geometry) {\n    const result = hittest.create_empty_hit_test_result();\n    const point = {\n      x: geometry.sx,\n      y: geometry.sy\n    };\n    let shortest = 9999;\n    const hits = {};\n\n    for (let i = 0, end = this.sxs.length; i < end; i++) {\n      const threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\n      let points = null;\n\n      for (let j = 0, endj = this.sxs[i].length - 1; j < endj; j++) {\n        const p0 = {\n          x: this.sxs[i][j],\n          y: this.sys[i][j]\n        };\n        const p1 = {\n          x: this.sxs[i][j + 1],\n          y: this.sys[i][j + 1]\n        };\n        const dist = hittest.dist_to_segment(point, p0, p1);\n\n        if (dist < threshold && dist < shortest) {\n          shortest = dist;\n          points = [j];\n        }\n      }\n\n      if (points) hits[i] = points;\n    }\n\n    result.indices = keys(hits).map(x => parseInt(x, 10));\n    result.multiline_indices = hits;\n    return result;\n  }\n\n  _hit_span(geometry) {\n    const {\n      sx,\n      sy\n    } = geometry;\n    const result = hittest.create_empty_hit_test_result();\n    let val;\n    let values;\n\n    if (geometry.direction === 'v') {\n      val = this.renderer.yscale.invert(sy);\n      values = this._ys;\n    } else {\n      val = this.renderer.xscale.invert(sx);\n      values = this._xs;\n    }\n\n    const hits = {};\n\n    for (let i = 0, end = values.length; i < end; i++) {\n      const points = [];\n\n      for (let j = 0, endj = values[i].length - 1; j < endj; j++) {\n        if (values[i][j] <= val && val <= values[i][j + 1]) points.push(j);\n      }\n\n      if (points.length > 0) hits[i] = points;\n    }\n\n    result.indices = keys(hits).map(x => parseInt(x, 10));\n    result.multiline_indices = hits;\n    return result;\n  }\n\n  get_interpolation_hit(i, point_i, geometry) {\n    const [x2, y2, x3, y3] = [this._xs[i][point_i], this._ys[i][point_i], this._xs[i][point_i + 1], this._ys[i][point_i + 1]];\n    return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n  }\n\n  draw_legend_for_index(ctx, bbox, index) {\n    generic_line_legend(this.visuals, ctx, bbox, index);\n  }\n\n  scenterx() {\n    throw new Error(\"not implemented\");\n  }\n\n  scentery() {\n    throw new Error(\"not implemented\");\n  }\n\n}\nMultiLineView.__name__ = \"MultiLineView\";\nexport class MultiLine extends Glyph {\n  constructor(attrs) {\n    super(attrs);\n  }\n\n  static init_MultiLine() {\n    this.prototype.default_view = MultiLineView;\n    this.coords([['xs', 'ys']]);\n    this.mixins(['line']);\n  }\n\n}\nMultiLine.__name__ = \"MultiLine\";\nMultiLine.init_MultiLine();","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/multi_line.js"],"names":["SpatialIndex","hittest","keys","min","max","isStrictNaN","Glyph","GlyphView","generic_line_legend","line_interpolation","MultiLineView","_index_data","points","i","end","_xs","length","_xsi","xs","j","n","x","push","_ysi","_ys","ys","y","x0","x1","y0","y1","_render","ctx","indices","sxs","sys","sx","sy","visuals","line","set_vectorize","beginPath","moveTo","isNaN","stroke","lineTo","_hit_point","geometry","result","create_empty_hit_test_result","point","shortest","hits","threshold","Math","cache_select","endj","p0","p1","dist","dist_to_segment","map","parseInt","multiline_indices","_hit_span","val","values","direction","renderer","yscale","invert","xscale","get_interpolation_hit","point_i","x2","y2","x3","y3","draw_legend_for_index","bbox","index","scenterx","Error","scentery","__name__","MultiLine","constructor","attrs","init_MultiLine","prototype","default_view","coords","mixins"],"mappings":"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","sourcesContent":["import { SpatialIndex } from \"../../core/util/spatial\";\nimport * as hittest from \"../../core/hittest\";\nimport { keys } from \"../../core/util/object\";\nimport { min, max } from \"../../core/util/array\";\nimport { isStrictNaN } from \"../../core/util/types\";\nimport { Glyph, GlyphView } from \"./glyph\";\nimport { generic_line_legend, line_interpolation } from \"./utils\";\nexport class MultiLineView extends GlyphView {\n    _index_data() {\n        const points = [];\n        for (let i = 0, end = this._xs.length; i < end; i++) {\n            if (this._xs[i] == null || this._xs[i].length === 0)\n                continue;\n            const _xsi = this._xs[i];\n            const xs = [];\n            for (let j = 0, n = _xsi.length; j < n; j++) {\n                const x = _xsi[j];\n                if (!isStrictNaN(x))\n                    xs.push(x);\n            }\n            const _ysi = this._ys[i];\n            const ys = [];\n            for (let j = 0, n = _ysi.length; j < n; j++) {\n                const y = _ysi[j];\n                if (!isStrictNaN(y))\n                    ys.push(y);\n            }\n            const [x0, x1] = [min(xs), max(xs)];\n            const [y0, y1] = [min(ys), max(ys)];\n            points.push({ x0, y0, x1, y1, i });\n        }\n        return new SpatialIndex(points);\n    }\n    _render(ctx, indices, { sxs, sys }) {\n        for (const i of indices) {\n            const [sx, sy] = [sxs[i], sys[i]];\n            this.visuals.line.set_vectorize(ctx, i);\n            for (let j = 0, end = sx.length; j < end; j++) {\n                if (j == 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[j], sy[j]);\n                    continue;\n                }\n                else if (isNaN(sx[j]) || isNaN(sy[j])) {\n                    ctx.stroke();\n                    ctx.beginPath();\n                    continue;\n                }\n                else\n                    ctx.lineTo(sx[j], sy[j]);\n            }\n            ctx.stroke();\n        }\n    }\n    _hit_point(geometry) {\n        const result = hittest.create_empty_hit_test_result();\n        const point = { x: geometry.sx, y: geometry.sy };\n        let shortest = 9999;\n        const hits = {};\n        for (let i = 0, end = this.sxs.length; i < end; i++) {\n            const threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\n            let points = null;\n            for (let j = 0, endj = this.sxs[i].length - 1; j < endj; j++) {\n                const p0 = { x: this.sxs[i][j], y: this.sys[i][j] };\n                const p1 = { x: this.sxs[i][j + 1], y: this.sys[i][j + 1] };\n                const dist = hittest.dist_to_segment(point, p0, p1);\n                if (dist < threshold && dist < shortest) {\n                    shortest = dist;\n                    points = [j];\n                }\n            }\n            if (points)\n                hits[i] = points;\n        }\n        result.indices = keys(hits).map((x) => parseInt(x, 10));\n        result.multiline_indices = hits;\n        return result;\n    }\n    _hit_span(geometry) {\n        const { sx, sy } = geometry;\n        const result = hittest.create_empty_hit_test_result();\n        let val;\n        let values;\n        if (geometry.direction === 'v') {\n            val = this.renderer.yscale.invert(sy);\n            values = this._ys;\n        }\n        else {\n            val = this.renderer.xscale.invert(sx);\n            values = this._xs;\n        }\n        const hits = {};\n        for (let i = 0, end = values.length; i < end; i++) {\n            const points = [];\n            for (let j = 0, endj = values[i].length - 1; j < endj; j++) {\n                if (values[i][j] <= val && val <= values[i][j + 1])\n                    points.push(j);\n            }\n            if (points.length > 0)\n                hits[i] = points;\n        }\n        result.indices = keys(hits).map((x) => parseInt(x, 10));\n        result.multiline_indices = hits;\n        return result;\n    }\n    get_interpolation_hit(i, point_i, geometry) {\n        const [x2, y2, x3, y3] = [this._xs[i][point_i], this._ys[i][point_i], this._xs[i][point_i + 1], this._ys[i][point_i + 1]];\n        return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n    }\n    draw_legend_for_index(ctx, bbox, index) {\n        generic_line_legend(this.visuals, ctx, bbox, index);\n    }\n    scenterx() {\n        throw new Error(\"not implemented\");\n    }\n    scentery() {\n        throw new Error(\"not implemented\");\n    }\n}\nMultiLineView.__name__ = \"MultiLineView\";\nexport class MultiLine extends Glyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_MultiLine() {\n        this.prototype.default_view = MultiLineView;\n        this.coords([['xs', 'ys']]);\n        this.mixins(['line']);\n    }\n}\nMultiLine.__name__ = \"MultiLine\";\nMultiLine.init_MultiLine();\n//# sourceMappingURL=multi_line.js.map"]},"metadata":{},"sourceType":"module"}