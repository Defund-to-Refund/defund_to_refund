{"ast":null,"code":"function fixup_line_dash(ctx) {\n  if (!ctx.setLineDash) {\n    ctx.setLineDash = dash => {\n      ctx.mozDash = dash;\n      ctx.webkitLineDash = dash;\n    };\n  }\n\n  if (!ctx.getLineDash) {\n    ctx.getLineDash = () => {\n      return ctx.mozDash;\n    };\n  }\n}\n\nfunction fixup_line_dash_offset(ctx) {\n  ctx.setLineDashOffset = offset => {\n    ctx.lineDashOffset = offset;\n    ctx.mozDashOffset = offset;\n    ctx.webkitLineDashOffset = offset;\n  };\n\n  ctx.getLineDashOffset = () => {\n    return ctx.mozDashOffset;\n  };\n}\n\nfunction fixup_image_smoothing(ctx) {\n  ctx.setImageSmoothingEnabled = value => {\n    ctx.imageSmoothingEnabled = value;\n    ctx.mozImageSmoothingEnabled = value;\n    ctx.oImageSmoothingEnabled = value;\n    ctx.webkitImageSmoothingEnabled = value;\n    ctx.msImageSmoothingEnabled = value;\n  };\n\n  ctx.getImageSmoothingEnabled = () => {\n    const val = ctx.imageSmoothingEnabled;\n    return val != null ? val : true;\n  };\n}\n\nfunction fixup_measure_text(ctx) {\n  if (ctx.measureText && ctx.html5MeasureText == null) {\n    ctx.html5MeasureText = ctx.measureText;\n\n    ctx.measureText = text => {\n      const textMetrics = ctx.html5MeasureText(text); // fake it til you make it\n\n      textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\n      return textMetrics;\n    };\n  }\n}\n\nfunction fixup_ellipse(ctx) {\n  // implementing the ctx.ellipse function with bezier curves\n  // we don't implement the startAngle, endAngle and anticlockwise arguments.\n  function ellipse_bezier(x, y, radiusX, radiusY, rotation, _startAngle, _endAngle, anticlockwise = false) {\n    const c = 0.551784; // see http://www.tinaja.com/glib/ellipse4.pdf\n\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    let rx = radiusX;\n    let ry = radiusY;\n\n    if (anticlockwise) {\n      rx = -radiusX;\n      ry = -radiusY;\n    }\n\n    ctx.moveTo(-rx, 0); // start point of first curve\n\n    ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\n    ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\n    ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\n    ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\n    ctx.rotate(-rotation);\n    ctx.translate(-x, -y);\n  }\n\n  if (!ctx.ellipse) ctx.ellipse = ellipse_bezier;\n}\n\nexport function fixup_ctx(ctx) {\n  fixup_line_dash(ctx);\n  fixup_line_dash_offset(ctx);\n  fixup_image_smoothing(ctx);\n  fixup_measure_text(ctx);\n  fixup_ellipse(ctx);\n}","map":{"version":3,"sources":["/Users/gen/Desktop/defund_to_refund/node_modules/@bokeh/bokehjs/build/js/lib/core/util/canvas.js"],"names":["fixup_line_dash","ctx","setLineDash","dash","mozDash","webkitLineDash","getLineDash","fixup_line_dash_offset","setLineDashOffset","offset","lineDashOffset","mozDashOffset","webkitLineDashOffset","getLineDashOffset","fixup_image_smoothing","setImageSmoothingEnabled","value","imageSmoothingEnabled","mozImageSmoothingEnabled","oImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","getImageSmoothingEnabled","val","fixup_measure_text","measureText","html5MeasureText","text","textMetrics","ascent","width","fixup_ellipse","ellipse_bezier","x","y","radiusX","radiusY","rotation","_startAngle","_endAngle","anticlockwise","c","translate","rotate","rx","ry","moveTo","bezierCurveTo","ellipse","fixup_ctx"],"mappings":"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","sourcesContent":["function fixup_line_dash(ctx) {\n    if (!ctx.setLineDash) {\n        ctx.setLineDash = (dash) => {\n            ctx.mozDash = dash;\n            ctx.webkitLineDash = dash;\n        };\n    }\n    if (!ctx.getLineDash) {\n        ctx.getLineDash = () => {\n            return ctx.mozDash;\n        };\n    }\n}\nfunction fixup_line_dash_offset(ctx) {\n    ctx.setLineDashOffset = (offset) => {\n        ctx.lineDashOffset = offset;\n        ctx.mozDashOffset = offset;\n        ctx.webkitLineDashOffset = offset;\n    };\n    ctx.getLineDashOffset = () => {\n        return ctx.mozDashOffset;\n    };\n}\nfunction fixup_image_smoothing(ctx) {\n    ctx.setImageSmoothingEnabled = (value) => {\n        ctx.imageSmoothingEnabled = value;\n        ctx.mozImageSmoothingEnabled = value;\n        ctx.oImageSmoothingEnabled = value;\n        ctx.webkitImageSmoothingEnabled = value;\n        ctx.msImageSmoothingEnabled = value;\n    };\n    ctx.getImageSmoothingEnabled = () => {\n        const val = ctx.imageSmoothingEnabled;\n        return val != null ? val : true;\n    };\n}\nfunction fixup_measure_text(ctx) {\n    if (ctx.measureText && ctx.html5MeasureText == null) {\n        ctx.html5MeasureText = ctx.measureText;\n        ctx.measureText = (text) => {\n            const textMetrics = ctx.html5MeasureText(text);\n            // fake it til you make it\n            textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\n            return textMetrics;\n        };\n    }\n}\nfunction fixup_ellipse(ctx) {\n    // implementing the ctx.ellipse function with bezier curves\n    // we don't implement the startAngle, endAngle and anticlockwise arguments.\n    function ellipse_bezier(x, y, radiusX, radiusY, rotation, _startAngle, _endAngle, anticlockwise = false) {\n        const c = 0.551784; // see http://www.tinaja.com/glib/ellipse4.pdf\n        ctx.translate(x, y);\n        ctx.rotate(rotation);\n        let rx = radiusX;\n        let ry = radiusY;\n        if (anticlockwise) {\n            rx = -radiusX;\n            ry = -radiusY;\n        }\n        ctx.moveTo(-rx, 0); // start point of first curve\n        ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\n        ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\n        ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\n        ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\n        ctx.rotate(-rotation);\n        ctx.translate(-x, -y);\n    }\n    if (!ctx.ellipse)\n        ctx.ellipse = ellipse_bezier;\n}\nexport function fixup_ctx(ctx) {\n    fixup_line_dash(ctx);\n    fixup_line_dash_offset(ctx);\n    fixup_image_smoothing(ctx);\n    fixup_measure_text(ctx);\n    fixup_ellipse(ctx);\n}\n//# sourceMappingURL=canvas.js.map"]},"metadata":{},"sourceType":"module"}